{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"[Hub] [Releases] Warning For crowdsec versions <= 1.0 please refer to v0.3.X For crowdsec versions >= 1.0 please refer to v1.X What is Crowdsec-agent ? \u00b6 Crowdsec-agent is an open-source and lightweight software that allows you to detect peers with malevolent behaviors and block them from accessing your systems at various level (infrastructural, system, applicative). To achieve this, Crowdsec-agent reads logs from different sources (files, streams ...) to parse, normalize and enrich them before matching them to threats patterns called scenarios. Crowdsec-agent is a modular and plug-able framework, it ships a large variety of well known popular scenarios ; users can choose what scenarios they want to be protected from as well as easily adding new custom ones to better fit their environment. Detected malevolent peers can then be prevented from accessing your resources by deploying bouncers at various levels (applicative, system, infrastructural) of your stack. One of the advantages of Crowdsec when compared to other solutions is its crowd-sourced aspect : Meta information about detected attacks (source IP, time and triggered scenario) are sent to a central API and then shared amongst all users. Thanks to this, besides detecting and stopping attacks in real time based on your logs, it allows you to preemptively block known bad actors from accessing your information system. Main features \u00b6 Crowdsec-agent, besides the core \"detect and react\" mechanism, is committed to a few other key points : Easy Installation : The provided wizard allows a trivial deployment on most standard setups Easy daily operations : Using cscli and the Crowdsec Hub , keeping your detection mechanisms up-to-date is trivial Reproducibility : Crowdsec can run not only against live logs, but as well against cold logs. It makes it a lot easier to detect potential false-positives, perform forensic ou generate reporting Observability : Providing strongs insights on what is going on and what crowdsec-agent is doing : Humans have access to a trivially deployable web interface OPs have access to detailed prometheus metrics Admins have a friendly command-line interface tool About this documentation \u00b6 This document is split according to major Crowdsec-agent versions : Crowdsec v0 Refers to versions 0.3.X , before the local API was introduced. ( note: this is going to be deprecated and your are strongly incited to migrate to versions 1.X ) Crowdsec v1 Refers to versions 1.X , it is the current version","title":"Home"},{"location":"index.html#what-is-crowdsec-agent","text":"Crowdsec-agent is an open-source and lightweight software that allows you to detect peers with malevolent behaviors and block them from accessing your systems at various level (infrastructural, system, applicative). To achieve this, Crowdsec-agent reads logs from different sources (files, streams ...) to parse, normalize and enrich them before matching them to threats patterns called scenarios. Crowdsec-agent is a modular and plug-able framework, it ships a large variety of well known popular scenarios ; users can choose what scenarios they want to be protected from as well as easily adding new custom ones to better fit their environment. Detected malevolent peers can then be prevented from accessing your resources by deploying bouncers at various levels (applicative, system, infrastructural) of your stack. One of the advantages of Crowdsec when compared to other solutions is its crowd-sourced aspect : Meta information about detected attacks (source IP, time and triggered scenario) are sent to a central API and then shared amongst all users. Thanks to this, besides detecting and stopping attacks in real time based on your logs, it allows you to preemptively block known bad actors from accessing your information system.","title":"What is Crowdsec-agent ?"},{"location":"index.html#main-features","text":"Crowdsec-agent, besides the core \"detect and react\" mechanism, is committed to a few other key points : Easy Installation : The provided wizard allows a trivial deployment on most standard setups Easy daily operations : Using cscli and the Crowdsec Hub , keeping your detection mechanisms up-to-date is trivial Reproducibility : Crowdsec can run not only against live logs, but as well against cold logs. It makes it a lot easier to detect potential false-positives, perform forensic ou generate reporting Observability : Providing strongs insights on what is going on and what crowdsec-agent is doing : Humans have access to a trivially deployable web interface OPs have access to detailed prometheus metrics Admins have a friendly command-line interface tool","title":"Main features"},{"location":"index.html#about-this-documentation","text":"This document is split according to major Crowdsec-agent versions : Crowdsec v0 Refers to versions 0.3.X , before the local API was introduced. ( note: this is going to be deprecated and your are strongly incited to migrate to versions 1.X ) Crowdsec v1 Refers to versions 1.X , it is the current version","title":"About this documentation"},{"location":"contributing.html","text":"Contributing \u00b6 You have an idea, a suggestion or you spotted a mistake ? Help us improve the software and the user experience, to make the internet a safer place together ! Contributing to the documentation \u00b6 If you spotted some mistakes in the documentation or have improvement suggestions, you can : open a new documentation issue if you are comfortable with github let us know on CrowdSecurity discourse if you want to discuss about it Let us as well know if you have some improvement suggestions ! Preview your documentation changes locally python3 -m venv cs-env source cs-env/bin/activate pip install -r docs/requirements.txt mkdocs serve Contributing to the code \u00b6 If you want to report a bug, you can use the github bugtracker If you want to suggest an improvement you can use either the github bugtracker or the CrowdSecurity discourse if you want to discuss Contributing to the parsers/scenarios \u00b6 If you want to contribute your parser or scenario to the community and have them appear on the Crowdsec Hub , you should open a merge request on the hub. We are currently working on a proper CI for the Crowdsec Hub , so for now all contribution are subject to peer-review, please bear with us ! Contacting the team \u00b6 If you want to contact us using non-public media, you can contact us on support AT crowdsec DOT net with the following gpg-key : -----BEGIN PGP PUBLIC KEY BLOCK----- mQGNBF+VOSUBDADP6bxKDv88CdLBNhQMFNI37LE82vyfIAQmrGszON1m1EtL/LSQ b/vC9mmlkUmJHM+bdxJ0BSl/xlWwrXjHVpaZNoluQDngVUe62cybN4tpFCvtVTMr lo4Y0UhETgOmBFxaQLVd7Xc/jaSZGoHtSzh9hpGHg9pKrcYviG0MR173JYQfilw3 L8yJ+K/oUUpvh2MRRwXiCNUVLtTppb7oxlcdExb0Px2PcaC34e/M30xFwiu7VJFj 0D7IIdKs6gvZuqwkNSUBF8/jtuzzM/YGzJHIdvOj15z+81/o/e6p3xvY/IKmyXC/ 1FMD8f4g5T/5fNDVq6QgJLel/g0bJ+kG75ccXfY45xKFo/YhdQ2Wg9JQX5Yjc5k7 5AI0iuJjatXlym2Ek1niPEqR5H0C/KXFG4mPyCu9wzJu11jtY34e5TNYl9DA31F6 81BbMmVFg4EbhYSN/2DuxpCvt2qQpk33bmdT7tFWcd2hYB/bSq2f8+K6ho50Sqwk PK68LNZzi5ZXqGEAEQEAAbQnQ3Jvd2RTZWMgc3VwcG9ydCA8c3VwcG9ydEBjcm93 ZHNlYy5uZXQ+iQHUBBMBCgA+FiEEpRXNfWM+DON/Satp2MpQXYwzLTEFAl+VOSUC GwMFCQPCZwAFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQ2MpQXYwzLTEhuwwA wWdsuSrTC4ryVOYnfHRcT2b/rfbJXIUYXqAy75qsdUGwvueYdYSBMCMXqRB65J+J juofCF0kTQKuhjtyJezwUfr5C+Sd08JWlZwf9F7CO83/ztLOPIUUp69H3m9heW7C +A/Lpq3epALytC/QSkDHYnKBBZbLhoR/7WXhdLFvh+A475/ggn4GAOnZMg8WULpR Kisu1GbEBPcVr1Xl6VTYVX5ghA/1W2WTY/NxAcLhCiJO/ENeka7xy4EKdCE5pDxM QO/fnpCHsWDIHTxpCx+JAhdkb2BIvzSiF2+o+9y+vwzcPxdGemx7y8MjSGXIp1xp TJparq309nljh+wqI6w/K+NjzNn/qJL0tpGqiHQXtYDbi86KaAXT9IYCGAIP36w8 XUHYGgo0s6zMEP1NEFHWAgGy5elO403vm+NO5vpHv59FTjgoK2UcjeSjqtAYwzvc bWQ6wZHwhoqD0WevFcAMmgdbebyOdPoA7+8eCPnkjER4eKxE23ffFU75HDuQNRYk uQGNBF+VOSUBDADNHEm33IcwhO+uJQxjKtcF0DdAMqbjU5cXxeryo1i7A1WkTH5/ wHfyJAmtLrY4abkQ1LEJ4bMYKdJz2vmvWq0fKCAXC18yLnxU+l0Ld4tWME8hJ/Wh p+aePsW5BdLpHQeqmQ5MCsw1cZllbURcee22hLJ/PIM2bRsZp7goSj4wXBFjhJyq EepVmasI17dBbIBFWBSSIJW4UnSBk+Zqbj6C6PDmsket68qcEebsqduWXPxegAzh IIFD2qhC5t+nn5i+hPwKZN5ZYLQJeAjI4Z7wi3FIBZCzZ214421BbohxPo+GKkFp mUQ7ZrIa+goHXAcj6ZHMeNNP0lsJRl91lK6NVu3p+Ygl0+wbMOAqDRguMfFdbnV8 gcoYpAyk4YFCfgVQLuKGaYcGjcMP8+nZnPsbaTwbUKkjDAUo+JGmrB4XyAQPugZq TiUN+lYgTs0cJALEQkKTh2w10TPyV6/YsYDSSnwJeVDIpNCQVg5EB0eRvhaCs9fd dVni1C5RMcb+Q4MAEQEAAYkBvAQYAQoAJhYhBKUVzX1jPgzjf0mradjKUF2MMy0x BQJflTklAhsMBQkDwmcAAAoJENjKUF2MMy0xkIcL/johqZbyHskQIaTfQUgASbbu bdLXSrIkB8Ort9WULxdqs8hveFy6RjXFJWFitFHk46Bj6FJ1ZykfozL+k9uOGrL9 lBk1e3bhqMVhW1o00DufgawNU2FU9NuH/rCuGpum9DE0cc1fFmQ3pjeiHV55GYxr BGuyyals1ORwK06h+1VFMHrGB12SR7Imgo7FWuexhgLyOK4t1MXg3E4h72qaowpj 5B45qG9jUXgIFKR1D8G8tPeDYLbd37pskNDFozzfAe/H2fqmEjQxMLHrk7J8I3wQ FPvKIvUF8M3NqZjyaFSiisOn32AS3RAsI8RuD4T2XgpE2L6e29u3RpJkvhPbcAN6 w0W8yw3z1/2uHSvYbwoH1cn4akAikYR9aVVHv86AvNlr0BguqWdzEfiGT6mcJ/hH 2sGQJ1nJRgGpAlx/2HpsLJxhJwLVbXSDSk6Bu2T9G/VIda95niVgq6MfE9GSS+MS ucVcwqjIXn/9V6+pFZ11soXNKuTk4Wx+uO2r/i5bVA== =Edl+ -----END PGP PUBLIC KEY BLOCK----- Publishing bouncers \u00b6 We do welcome bouncers from the community, and will gladly publish them on the hub. Why ? \u00b6 Sharing your bouncer on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it. How ? \u00b6 To have your bouncer published on the hub, please simply open a new issue on the hub , requesting \"bouncer inclusion\". The bouncer will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it ! The information that should be stated in your issue are : The source repository of your bouncer (for example https://github.com/crowdsecurity/cs-firewall-bouncer/ ) The software licence used The current status of the bouncer (stage : dev/unstable/stable) Documentation (can be simply in the README.md) : must contains : installing, uninstalling should contains : configuration documentation Link to existing tests if applicable (functional tests or unit tests) Please take care of the following : Ensure your repository has a About/Short description meaningful enough : it will be displayed in the hub Ensure your repository has a decent README.md file : it will be displayed in the hub Ensure your repository has at least one release : this is what users will be looking for (ideally) Have a \"social preview image\" on your repository : this will be displayed in the hub when available (ideally) A Howto or link to guide that provides a hands-on experience with the bouncer Please find below a template : Hello, I would like to suggest the addition of the `XXXX` to the hub : - Source repository: https://github.com/xxx/xxx/ - Licence : MIT - Current status : stable (has been used in production for a while) - README/doc : https://github.com/xxx/xxx/blob/main/README.md - Existing tests : - functional tests : https://github.com/xxx/xxx/blob/main/.github/workflows/tests.yml - Short/Long description : OK - Howto : in README - At least one release : yes Publishing parsers, scenarios and collections \u00b6 Why ? \u00b6 Sharing your parsers, scenarios and collections on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it. How ? \u00b6 To have your parser/scenario published on the hub, please simply open a new issue on the hub , requesting \"parser/scenario inclusion\". The configurations will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it !","title":"Guide"},{"location":"contributing.html#contributing","text":"You have an idea, a suggestion or you spotted a mistake ? Help us improve the software and the user experience, to make the internet a safer place together !","title":"Contributing"},{"location":"contributing.html#contributing-to-the-documentation","text":"If you spotted some mistakes in the documentation or have improvement suggestions, you can : open a new documentation issue if you are comfortable with github let us know on CrowdSecurity discourse if you want to discuss about it Let us as well know if you have some improvement suggestions ! Preview your documentation changes locally python3 -m venv cs-env source cs-env/bin/activate pip install -r docs/requirements.txt mkdocs serve","title":"Contributing to the documentation"},{"location":"contributing.html#contributing-to-the-code","text":"If you want to report a bug, you can use the github bugtracker If you want to suggest an improvement you can use either the github bugtracker or the CrowdSecurity discourse if you want to discuss","title":"Contributing to the code"},{"location":"contributing.html#contributing-to-the-parsersscenarios","text":"If you want to contribute your parser or scenario to the community and have them appear on the Crowdsec Hub , you should open a merge request on the hub. We are currently working on a proper CI for the Crowdsec Hub , so for now all contribution are subject to peer-review, please bear with us !","title":"Contributing to the parsers/scenarios"},{"location":"contributing.html#contacting-the-team","text":"If you want to contact us using non-public media, you can contact us on support AT crowdsec DOT net with the following gpg-key : -----BEGIN PGP PUBLIC KEY BLOCK----- mQGNBF+VOSUBDADP6bxKDv88CdLBNhQMFNI37LE82vyfIAQmrGszON1m1EtL/LSQ b/vC9mmlkUmJHM+bdxJ0BSl/xlWwrXjHVpaZNoluQDngVUe62cybN4tpFCvtVTMr lo4Y0UhETgOmBFxaQLVd7Xc/jaSZGoHtSzh9hpGHg9pKrcYviG0MR173JYQfilw3 L8yJ+K/oUUpvh2MRRwXiCNUVLtTppb7oxlcdExb0Px2PcaC34e/M30xFwiu7VJFj 0D7IIdKs6gvZuqwkNSUBF8/jtuzzM/YGzJHIdvOj15z+81/o/e6p3xvY/IKmyXC/ 1FMD8f4g5T/5fNDVq6QgJLel/g0bJ+kG75ccXfY45xKFo/YhdQ2Wg9JQX5Yjc5k7 5AI0iuJjatXlym2Ek1niPEqR5H0C/KXFG4mPyCu9wzJu11jtY34e5TNYl9DA31F6 81BbMmVFg4EbhYSN/2DuxpCvt2qQpk33bmdT7tFWcd2hYB/bSq2f8+K6ho50Sqwk PK68LNZzi5ZXqGEAEQEAAbQnQ3Jvd2RTZWMgc3VwcG9ydCA8c3VwcG9ydEBjcm93 ZHNlYy5uZXQ+iQHUBBMBCgA+FiEEpRXNfWM+DON/Satp2MpQXYwzLTEFAl+VOSUC GwMFCQPCZwAFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQ2MpQXYwzLTEhuwwA wWdsuSrTC4ryVOYnfHRcT2b/rfbJXIUYXqAy75qsdUGwvueYdYSBMCMXqRB65J+J juofCF0kTQKuhjtyJezwUfr5C+Sd08JWlZwf9F7CO83/ztLOPIUUp69H3m9heW7C +A/Lpq3epALytC/QSkDHYnKBBZbLhoR/7WXhdLFvh+A475/ggn4GAOnZMg8WULpR Kisu1GbEBPcVr1Xl6VTYVX5ghA/1W2WTY/NxAcLhCiJO/ENeka7xy4EKdCE5pDxM QO/fnpCHsWDIHTxpCx+JAhdkb2BIvzSiF2+o+9y+vwzcPxdGemx7y8MjSGXIp1xp TJparq309nljh+wqI6w/K+NjzNn/qJL0tpGqiHQXtYDbi86KaAXT9IYCGAIP36w8 XUHYGgo0s6zMEP1NEFHWAgGy5elO403vm+NO5vpHv59FTjgoK2UcjeSjqtAYwzvc bWQ6wZHwhoqD0WevFcAMmgdbebyOdPoA7+8eCPnkjER4eKxE23ffFU75HDuQNRYk uQGNBF+VOSUBDADNHEm33IcwhO+uJQxjKtcF0DdAMqbjU5cXxeryo1i7A1WkTH5/ wHfyJAmtLrY4abkQ1LEJ4bMYKdJz2vmvWq0fKCAXC18yLnxU+l0Ld4tWME8hJ/Wh p+aePsW5BdLpHQeqmQ5MCsw1cZllbURcee22hLJ/PIM2bRsZp7goSj4wXBFjhJyq EepVmasI17dBbIBFWBSSIJW4UnSBk+Zqbj6C6PDmsket68qcEebsqduWXPxegAzh IIFD2qhC5t+nn5i+hPwKZN5ZYLQJeAjI4Z7wi3FIBZCzZ214421BbohxPo+GKkFp mUQ7ZrIa+goHXAcj6ZHMeNNP0lsJRl91lK6NVu3p+Ygl0+wbMOAqDRguMfFdbnV8 gcoYpAyk4YFCfgVQLuKGaYcGjcMP8+nZnPsbaTwbUKkjDAUo+JGmrB4XyAQPugZq TiUN+lYgTs0cJALEQkKTh2w10TPyV6/YsYDSSnwJeVDIpNCQVg5EB0eRvhaCs9fd dVni1C5RMcb+Q4MAEQEAAYkBvAQYAQoAJhYhBKUVzX1jPgzjf0mradjKUF2MMy0x BQJflTklAhsMBQkDwmcAAAoJENjKUF2MMy0xkIcL/johqZbyHskQIaTfQUgASbbu bdLXSrIkB8Ort9WULxdqs8hveFy6RjXFJWFitFHk46Bj6FJ1ZykfozL+k9uOGrL9 lBk1e3bhqMVhW1o00DufgawNU2FU9NuH/rCuGpum9DE0cc1fFmQ3pjeiHV55GYxr BGuyyals1ORwK06h+1VFMHrGB12SR7Imgo7FWuexhgLyOK4t1MXg3E4h72qaowpj 5B45qG9jUXgIFKR1D8G8tPeDYLbd37pskNDFozzfAe/H2fqmEjQxMLHrk7J8I3wQ FPvKIvUF8M3NqZjyaFSiisOn32AS3RAsI8RuD4T2XgpE2L6e29u3RpJkvhPbcAN6 w0W8yw3z1/2uHSvYbwoH1cn4akAikYR9aVVHv86AvNlr0BguqWdzEfiGT6mcJ/hH 2sGQJ1nJRgGpAlx/2HpsLJxhJwLVbXSDSk6Bu2T9G/VIda95niVgq6MfE9GSS+MS ucVcwqjIXn/9V6+pFZ11soXNKuTk4Wx+uO2r/i5bVA== =Edl+ -----END PGP PUBLIC KEY BLOCK-----","title":"Contacting the team"},{"location":"contributing.html#publishing-bouncers","text":"We do welcome bouncers from the community, and will gladly publish them on the hub.","title":"Publishing bouncers"},{"location":"contributing.html#why","text":"Sharing your bouncer on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it.","title":"Why ?"},{"location":"contributing.html#how","text":"To have your bouncer published on the hub, please simply open a new issue on the hub , requesting \"bouncer inclusion\". The bouncer will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it ! The information that should be stated in your issue are : The source repository of your bouncer (for example https://github.com/crowdsecurity/cs-firewall-bouncer/ ) The software licence used The current status of the bouncer (stage : dev/unstable/stable) Documentation (can be simply in the README.md) : must contains : installing, uninstalling should contains : configuration documentation Link to existing tests if applicable (functional tests or unit tests) Please take care of the following : Ensure your repository has a About/Short description meaningful enough : it will be displayed in the hub Ensure your repository has a decent README.md file : it will be displayed in the hub Ensure your repository has at least one release : this is what users will be looking for (ideally) Have a \"social preview image\" on your repository : this will be displayed in the hub when available (ideally) A Howto or link to guide that provides a hands-on experience with the bouncer Please find below a template : Hello, I would like to suggest the addition of the `XXXX` to the hub : - Source repository: https://github.com/xxx/xxx/ - Licence : MIT - Current status : stable (has been used in production for a while) - README/doc : https://github.com/xxx/xxx/blob/main/README.md - Existing tests : - functional tests : https://github.com/xxx/xxx/blob/main/.github/workflows/tests.yml - Short/Long description : OK - Howto : in README - At least one release : yes","title":"How ?"},{"location":"contributing.html#publishing-parsers-scenarios-and-collections","text":"","title":"Publishing parsers, scenarios and collections"},{"location":"contributing.html#why_1","text":"Sharing your parsers, scenarios and collections on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it.","title":"Why ?"},{"location":"contributing.html#how_1","text":"To have your parser/scenario published on the hub, please simply open a new issue on the hub , requesting \"parser/scenario inclusion\". The configurations will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it !","title":"How ?"},{"location":"faq.html","text":"FREQUENTLY ASKED QUESTIONS \u00b6 What is crowdsec-agent ? \u00b6 Crowdsec-agent is a security open-source software. See the overview . I've installed crowdsec, it detects attacks but doesn't block anything ?! \u00b6 Yes, Crowdsec-agent is in charge of detecting attacks, and bouncers are applying decisions. If you want to block the detected IPs, you should deploy a bouncer, such as the ones found on the hub ! What language is it written in ? \u00b6 Crowdsec-agent is written in Golang . What licence is crowdsec-agent released under ? \u00b6 Crowdsec-agent is under MIT license . Which information is sent to the APIs ? \u00b6 Our aim is to build a strong community that can share malevolent attackers IPs, for that we need to collect the bans triggered locally by each user. The signal sent by your crowdsec-agent to the central API only contains only meta-data about the attack : Attacker IP Scenario name Time of start/end of attack Your logs are not sent to our central API, only meta-data about blocked attacks will be. When pulling block-lists from the platform, the following information is shared as well : list of upstream installed scenarios list of bouncers & number of machines What is the performance impact ? \u00b6 As crowdsec-agent only works on logs, it shouldn't impact your production. When it comes to bouncers, it should perform one request to the database when a new IP is discovered thus have minimal performance impact. How fast is it ? \u00b6 crowdsec-agent can easily handle several thousands of events per second on a rich pipeline (multiple parsers, geoip enrichment, scenarios and so on). Logs are a good fit for sharding by default, so it is definitely the way to go if you need to handle higher throughput. If you need help for large scale deployment, please get in touch with us on the CrowdSecurity discourse , we love challenges ;) What backend database does Crowdsec-agent supports and how to switch ? \u00b6 crowdsec-agent versions (under v0.3.X) supports SQLite (default) and MySQL databases. See backend configuration for relevant configuration. MySQL here is more suitable for distributed architectures where bouncers across the applicative stack need to access a centralized ban database. crowdsec-agent versions (after v1) supports SQLite (default), MySQL and PostgreSQL databases. See databases configuration for relevant configuration. Thanks to the Local API , distributed architectures are resolved even with sqlite database. SQLite by default as it's suitable for standalone/single-machine setups. How to control granularity of actions ? (whitelists, simulation etc.) \u00b6 crowdsec-agent support both whitelists and simulation : Whitelists allows you to \"discard\" events or overflows Simulation allows you to simply cancel the decision that is going to be taken, but keep track of it profiles allows you to control which decision will be applied to which alert. How to know if my setup is working correctly ? Some of my logs are unparsed, is it normal ? \u00b6 Yes, crowdsec parsers only parse the logs that are relevant for scenarios :) Take a look at cscli metrics and understand what do they mean to know if your setup is correct. How to add whitelists ? \u00b6 You can follow this guide How to set up proxy ? \u00b6 Setting up a proxy works out of the box, the net/http golang library can handle those environment variables: HTTP_PROXY HTTPS_PROXY NO_PROXY For example: export HTTP_PROXY=http://<proxy_url>:<proxy_port> Systemd variable \u00b6 On Systemd devices you have to set the proxy variable in the environment section for the CrowdSec service. To avoid overwriting the service file during an update, a folder is created in /etc/systemd/system/crowdsec.service.d and a file in it named http-proxy.conf . The content for this file should look something like this: [Service] Environment=HTTP_PROXY=http://myawesomeproxy.com:8080 Environment=HTTPS_PROXY=https://myawesomeproxy.com:443 After this change you need to reload the systemd daemon using: systemctl daemon-reload Then you can restart CrowdSec like this: systemctl restart crowdsec Sudo \u00b6 If you use sudo cscli, just add this line in visudo after setting up the previous environment variables: Defaults env_keep += \"HTTP_PROXY HTTPS_PROXY NO_PROXY\" How to report a bug ? \u00b6 To report a bug, please open an issue on the repository . What about false positives ? \u00b6 Several initiatives have been taken to tackle the false positives approach as early as possible : The scenarios published on the hub are tailored to favor low false positive rates You can find generic whitelists that should allow to cover most common cases (SEO whitelists, CDN whitelists etc.) The simulation configuration allows you to keep a tight control over scenario and their false positives I need some help \u00b6 Feel free to ask for some help to the CrowdSecurity discourse or directly in the chat. How to use crowdsec on raspberry pi OS (formerly known as rasbian) \u00b6 Please keep in mind that raspberry pi OS is designed to work on all raspberry pi versions. Even if the port target is known as armhf, it's not exactly the same target as the debian named armhf port. The best way to have a crowdsec version for such an architecture is to do: install golang (all versions from 1.13 will do) export GOARCH=arm export CGO=1 Update the GOARCH variable in the Makefile to arm install the arm gcc cross compilator (On debian the package is gcc-arm-linux-gnueabihf) Compile crowdsec using the usual make command How to have a dashboard without docker \u00b6 cscli dashboard rely on docker to launch the metabase image. If docker is not installed on your machine, here are the step to follow to get crowdsec dashboards without docker: Download Metabase jar file. See metabase documentation . Download the metabase.db folder from Crowdsec here . Unzip the zip file: unzip metabase_sqlite.zip Make crowdsec database reachable from metabase : sudo mkdir /metabase-data/ sudo ln -s /var/lib/crowdsec/data/crowdsec.db /metabase-data/crowdsec.db Launch Metabase: sudo MB_DB_TYPE = h2 MB_DB_FILE = <absolute-path>/metabase.db/metabase.db java -jar metabase.jar Warning The default username is crowdsec@crowdsec.net and the default password is !!Cr0wdS3c_M3t4b4s3?? . Please update the password when you will connect to metabase for the first time You can as well check liberodark's helper script for it . How to configure crowdsec/cscli to use Tor \u00b6 It is possible to configure cscli and crowdsec to use tor to anonymously interact with our API. All (http) requests made to the central API to go through the tor network . With tor installed, setting HTTP_PROXY and HTTPS_PROXY environment variables to your socks5 proxy will do the trick. Running the wizard with tor \u00b6 $ sudo HTTPS_PROXY = socks5://127.0.0.1:9050 HTTP_PROXY = socks5://127.0.0.1:9050 ./wizard.sh --bininstall Warning Do not use the wizard in interactive ( -i ) mode if you're concerned, as it will start the service at the end of the setup, leaking your IP address. Edit crowdsec systemd unit to push/pull via tor \u00b6 [ Service ] Environment = \"HTTPS_PROXY=socks5://127.0.0.1:9050\" Environment = \"HTTP_PROXY=socks5://127.0.0.1:9050\" ... Using cscli via tor \u00b6 $ sudo HTTP_PROXY = socks5://127.0.0.1:9050 HTTPS_PROXY = socks5://127.0.0.1:9050 cscli capi register","title":"Questions"},{"location":"faq.html#frequently-asked-questions","text":"","title":"FREQUENTLY ASKED QUESTIONS"},{"location":"faq.html#what-is-crowdsec-agent","text":"Crowdsec-agent is a security open-source software. See the overview .","title":"What is crowdsec-agent ?"},{"location":"faq.html#ive-installed-crowdsec-it-detects-attacks-but-doesnt-block-anything","text":"Yes, Crowdsec-agent is in charge of detecting attacks, and bouncers are applying decisions. If you want to block the detected IPs, you should deploy a bouncer, such as the ones found on the hub !","title":"I've installed crowdsec, it detects attacks but doesn't block anything ?!"},{"location":"faq.html#what-language-is-it-written-in","text":"Crowdsec-agent is written in Golang .","title":"What language is it written in ?"},{"location":"faq.html#what-licence-is-crowdsec-agent-released-under","text":"Crowdsec-agent is under MIT license .","title":"What licence is crowdsec-agent released under ?"},{"location":"faq.html#which-information-is-sent-to-the-apis","text":"Our aim is to build a strong community that can share malevolent attackers IPs, for that we need to collect the bans triggered locally by each user. The signal sent by your crowdsec-agent to the central API only contains only meta-data about the attack : Attacker IP Scenario name Time of start/end of attack Your logs are not sent to our central API, only meta-data about blocked attacks will be. When pulling block-lists from the platform, the following information is shared as well : list of upstream installed scenarios list of bouncers & number of machines","title":"Which information is sent to the APIs ?"},{"location":"faq.html#what-is-the-performance-impact","text":"As crowdsec-agent only works on logs, it shouldn't impact your production. When it comes to bouncers, it should perform one request to the database when a new IP is discovered thus have minimal performance impact.","title":"What is the performance impact ?"},{"location":"faq.html#how-fast-is-it","text":"crowdsec-agent can easily handle several thousands of events per second on a rich pipeline (multiple parsers, geoip enrichment, scenarios and so on). Logs are a good fit for sharding by default, so it is definitely the way to go if you need to handle higher throughput. If you need help for large scale deployment, please get in touch with us on the CrowdSecurity discourse , we love challenges ;)","title":"How fast is it ?"},{"location":"faq.html#what-backend-database-does-crowdsec-agent-supports-and-how-to-switch","text":"crowdsec-agent versions (under v0.3.X) supports SQLite (default) and MySQL databases. See backend configuration for relevant configuration. MySQL here is more suitable for distributed architectures where bouncers across the applicative stack need to access a centralized ban database. crowdsec-agent versions (after v1) supports SQLite (default), MySQL and PostgreSQL databases. See databases configuration for relevant configuration. Thanks to the Local API , distributed architectures are resolved even with sqlite database. SQLite by default as it's suitable for standalone/single-machine setups.","title":"What backend database does Crowdsec-agent supports and how to switch ?"},{"location":"faq.html#how-to-control-granularity-of-actions-whitelists-simulation-etc","text":"crowdsec-agent support both whitelists and simulation : Whitelists allows you to \"discard\" events or overflows Simulation allows you to simply cancel the decision that is going to be taken, but keep track of it profiles allows you to control which decision will be applied to which alert.","title":"How to control granularity of actions ? (whitelists, simulation etc.)"},{"location":"faq.html#how-to-know-if-my-setup-is-working-correctly-some-of-my-logs-are-unparsed-is-it-normal","text":"Yes, crowdsec parsers only parse the logs that are relevant for scenarios :) Take a look at cscli metrics and understand what do they mean to know if your setup is correct.","title":"How to know if my setup is working correctly ? Some of my logs are unparsed, is it normal ?"},{"location":"faq.html#how-to-add-whitelists","text":"You can follow this guide","title":"How to add whitelists ?"},{"location":"faq.html#how-to-set-up-proxy","text":"Setting up a proxy works out of the box, the net/http golang library can handle those environment variables: HTTP_PROXY HTTPS_PROXY NO_PROXY For example: export HTTP_PROXY=http://<proxy_url>:<proxy_port>","title":"How to set up proxy ?"},{"location":"faq.html#systemd-variable","text":"On Systemd devices you have to set the proxy variable in the environment section for the CrowdSec service. To avoid overwriting the service file during an update, a folder is created in /etc/systemd/system/crowdsec.service.d and a file in it named http-proxy.conf . The content for this file should look something like this: [Service] Environment=HTTP_PROXY=http://myawesomeproxy.com:8080 Environment=HTTPS_PROXY=https://myawesomeproxy.com:443 After this change you need to reload the systemd daemon using: systemctl daemon-reload Then you can restart CrowdSec like this: systemctl restart crowdsec","title":"Systemd variable"},{"location":"faq.html#sudo","text":"If you use sudo cscli, just add this line in visudo after setting up the previous environment variables: Defaults env_keep += \"HTTP_PROXY HTTPS_PROXY NO_PROXY\"","title":"Sudo"},{"location":"faq.html#how-to-report-a-bug","text":"To report a bug, please open an issue on the repository .","title":"How to report a bug ?"},{"location":"faq.html#what-about-false-positives","text":"Several initiatives have been taken to tackle the false positives approach as early as possible : The scenarios published on the hub are tailored to favor low false positive rates You can find generic whitelists that should allow to cover most common cases (SEO whitelists, CDN whitelists etc.) The simulation configuration allows you to keep a tight control over scenario and their false positives","title":"What about false positives ?"},{"location":"faq.html#i-need-some-help","text":"Feel free to ask for some help to the CrowdSecurity discourse or directly in the chat.","title":"I need some help"},{"location":"faq.html#how-to-use-crowdsec-on-raspberry-pi-os-formerly-known-as-rasbian","text":"Please keep in mind that raspberry pi OS is designed to work on all raspberry pi versions. Even if the port target is known as armhf, it's not exactly the same target as the debian named armhf port. The best way to have a crowdsec version for such an architecture is to do: install golang (all versions from 1.13 will do) export GOARCH=arm export CGO=1 Update the GOARCH variable in the Makefile to arm install the arm gcc cross compilator (On debian the package is gcc-arm-linux-gnueabihf) Compile crowdsec using the usual make command","title":"How to use crowdsec on raspberry pi OS (formerly known as rasbian)"},{"location":"faq.html#how-to-have-a-dashboard-without-docker","text":"cscli dashboard rely on docker to launch the metabase image. If docker is not installed on your machine, here are the step to follow to get crowdsec dashboards without docker: Download Metabase jar file. See metabase documentation . Download the metabase.db folder from Crowdsec here . Unzip the zip file: unzip metabase_sqlite.zip Make crowdsec database reachable from metabase : sudo mkdir /metabase-data/ sudo ln -s /var/lib/crowdsec/data/crowdsec.db /metabase-data/crowdsec.db Launch Metabase: sudo MB_DB_TYPE = h2 MB_DB_FILE = <absolute-path>/metabase.db/metabase.db java -jar metabase.jar Warning The default username is crowdsec@crowdsec.net and the default password is !!Cr0wdS3c_M3t4b4s3?? . Please update the password when you will connect to metabase for the first time You can as well check liberodark's helper script for it .","title":"How to have a dashboard without docker"},{"location":"faq.html#how-to-configure-crowdseccscli-to-use-tor","text":"It is possible to configure cscli and crowdsec to use tor to anonymously interact with our API. All (http) requests made to the central API to go through the tor network . With tor installed, setting HTTP_PROXY and HTTPS_PROXY environment variables to your socks5 proxy will do the trick.","title":"How to configure crowdsec/cscli to use Tor"},{"location":"faq.html#running-the-wizard-with-tor","text":"$ sudo HTTPS_PROXY = socks5://127.0.0.1:9050 HTTP_PROXY = socks5://127.0.0.1:9050 ./wizard.sh --bininstall Warning Do not use the wizard in interactive ( -i ) mode if you're concerned, as it will start the service at the end of the setup, leaking your IP address.","title":"Running the wizard with tor"},{"location":"faq.html#edit-crowdsec-systemd-unit-to-pushpull-via-tor","text":"[ Service ] Environment = \"HTTPS_PROXY=socks5://127.0.0.1:9050\" Environment = \"HTTP_PROXY=socks5://127.0.0.1:9050\" ...","title":"Edit crowdsec systemd unit to push/pull via tor"},{"location":"faq.html#using-cscli-via-tor","text":"$ sudo HTTP_PROXY = socks5://127.0.0.1:9050 HTTPS_PROXY = socks5://127.0.0.1:9050 cscli capi register","title":"Using cscli via tor"},{"location":"migration.html","text":"Migration from v0.X to v1.X \u00b6 Warning Migrating to V1.X will impact (any change you made will be lost and must be adapted to the new configuration) : Database model : your existing database will be lost, a new one will be created in the V1. Crowdsec-agent configuration : /etc/crowdsec/config/default.yaml : check new format /etc/crowdsec/config/profiles.yaml : check new format To upgrade crowdsec-agent from v0.X to v1, we'll follow those steps Backup up configuration \u00b6 sudo cscli backup save /tmp/crowdsec_backup sudo cp -R /etc/crowdsec/config/patterns /tmp/crowdsec_backup Uninstall old version & install new \u00b6 Download latest V1 crowdsec-agent version here tar xvzf crowdsec-release.tgz cd crowdsec-v1*/ sudo ./wizard.sh --uninstall sudo rm /etc/cron.d/crowdsec_pull sudo ./wizard.sh --bininstall Warning Don't forget to remove metabase dashboard if you installed it manually (without cscli). Restore configuration \u00b6 Warning Before restoring old backup, if you have local or tainted postoverflows, be aware that they are no longer compatible. You should update the syntax (the community and us are available to help you doing this part). sudo cscli hub update sudo cscli config restore --old-backup /tmp/crowdsec_backup/ sudo cp -R /tmp/crowdsec_backup/patterns /etc/crowdsec/ Register crowdsec to local & central API \u00b6 $ sudo cscli machines add -a INFO [ 0000 ] Machine '...' created successfully INFO [ 0000 ] API credentials dumped to '/etc/crowdsec/local_api_credentials.yaml' Before starting the services, let's check that we're properly registered : $ sudo cscli capi status INFO [ 0000 ] Loaded credentials from /etc/crowdsec/online_api_credentials.yaml INFO [ 0000 ] Trying to authenticate with username ... on https://api.crowdsec.net/ INFO [ 0000 ] You can successfully interact with Central API ( CAPI ) Start & health check \u00b6 Finally, you will be able to start crowdsec-agent service. Before that, just check if local API (LAPI) and API are correctly configured. $ sudo systemctl enable crowdsec $ sudo systemctl start crowdsec $ sudo cscli lapi status INFO [ 0000 ] Loaded credentials from /etc/crowdsec/local_api_credentials.yaml INFO [ 0000 ] Trying to authenticate with username ... on http://127.0.0.1:8080/ INFO [ 0000 ] You can successfully interact with Local API ( LAPI ) $ sudo cscli capi status INFO [ 0000 ] Loaded credentials from /etc/crowdsec/online_api_credentials.yaml INFO [ 0000 ] Trying to authenticate with username ... on https://api.crowdsec.net/ INFO [ 0000 ] You can successfully interact with Central API ( CAPI ) Warning If you're facing issues with cscli lapi status , just re-run cscli machines add -a . If you're facing issues with cscli capi status , just re-run cscli capi register You can check logs (located by default here: /var/log/crowdsec.log & /var/log/crowdsec_api.log ). You can now navigate documentation to learn new cscli commands to interact with crowdsec. Upgrade bouncers \u00b6 If you were using bouncers (formerly called blocker(s) ), you need to replace them by the new compatibles bouncers, available on the hub (selecting agent version to v1 ). Following your bouncer type (netfilter, nginx, wordpress etc...), you need to replace them by the new available bouncers on the hub, please follow the bouncers documentation that will help you to install easily. We're also available to help (on discourse or gitter ) upgrading your bouncers.","title":"Upgrade V0.X to V1.X"},{"location":"migration.html#migration-from-v0x-to-v1x","text":"Warning Migrating to V1.X will impact (any change you made will be lost and must be adapted to the new configuration) : Database model : your existing database will be lost, a new one will be created in the V1. Crowdsec-agent configuration : /etc/crowdsec/config/default.yaml : check new format /etc/crowdsec/config/profiles.yaml : check new format To upgrade crowdsec-agent from v0.X to v1, we'll follow those steps","title":"Migration from v0.X to v1.X"},{"location":"migration.html#backup-up-configuration","text":"sudo cscli backup save /tmp/crowdsec_backup sudo cp -R /etc/crowdsec/config/patterns /tmp/crowdsec_backup","title":"Backup up configuration"},{"location":"migration.html#uninstall-old-version-install-new","text":"Download latest V1 crowdsec-agent version here tar xvzf crowdsec-release.tgz cd crowdsec-v1*/ sudo ./wizard.sh --uninstall sudo rm /etc/cron.d/crowdsec_pull sudo ./wizard.sh --bininstall Warning Don't forget to remove metabase dashboard if you installed it manually (without cscli).","title":"Uninstall old version &amp; install new"},{"location":"migration.html#restore-configuration","text":"Warning Before restoring old backup, if you have local or tainted postoverflows, be aware that they are no longer compatible. You should update the syntax (the community and us are available to help you doing this part). sudo cscli hub update sudo cscli config restore --old-backup /tmp/crowdsec_backup/ sudo cp -R /tmp/crowdsec_backup/patterns /etc/crowdsec/","title":"Restore configuration"},{"location":"migration.html#register-crowdsec-to-local-central-api","text":"$ sudo cscli machines add -a INFO [ 0000 ] Machine '...' created successfully INFO [ 0000 ] API credentials dumped to '/etc/crowdsec/local_api_credentials.yaml' Before starting the services, let's check that we're properly registered : $ sudo cscli capi status INFO [ 0000 ] Loaded credentials from /etc/crowdsec/online_api_credentials.yaml INFO [ 0000 ] Trying to authenticate with username ... on https://api.crowdsec.net/ INFO [ 0000 ] You can successfully interact with Central API ( CAPI )","title":"Register crowdsec to local &amp; central API"},{"location":"migration.html#start-health-check","text":"Finally, you will be able to start crowdsec-agent service. Before that, just check if local API (LAPI) and API are correctly configured. $ sudo systemctl enable crowdsec $ sudo systemctl start crowdsec $ sudo cscli lapi status INFO [ 0000 ] Loaded credentials from /etc/crowdsec/local_api_credentials.yaml INFO [ 0000 ] Trying to authenticate with username ... on http://127.0.0.1:8080/ INFO [ 0000 ] You can successfully interact with Local API ( LAPI ) $ sudo cscli capi status INFO [ 0000 ] Loaded credentials from /etc/crowdsec/online_api_credentials.yaml INFO [ 0000 ] Trying to authenticate with username ... on https://api.crowdsec.net/ INFO [ 0000 ] You can successfully interact with Central API ( CAPI ) Warning If you're facing issues with cscli lapi status , just re-run cscli machines add -a . If you're facing issues with cscli capi status , just re-run cscli capi register You can check logs (located by default here: /var/log/crowdsec.log & /var/log/crowdsec_api.log ). You can now navigate documentation to learn new cscli commands to interact with crowdsec.","title":"Start &amp; health check"},{"location":"migration.html#upgrade-bouncers","text":"If you were using bouncers (formerly called blocker(s) ), you need to replace them by the new compatibles bouncers, available on the hub (selecting agent version to v1 ). Following your bouncer type (netfilter, nginx, wordpress etc...), you need to replace them by the new available bouncers on the hub, please follow the bouncers documentation that will help you to install easily. We're also available to help (on discourse or gitter ) upgrading your bouncers.","title":"Upgrade bouncers"},{"location":"bouncers/index.html","text":"Bouncers \u00b6 Bouncers are standalone software pieces in charge of acting upon a decision taken by crowdsec : block an IP, present a captcha, enforce MFA on a given user, etc. They can either be within the applicative stack, or work out of band : nginx bouncer will check every unknown IP against the local API before letting go through or serving a 403 to the user, while a firewall bouncer will simply \"add\" malevolent IPs to nftables/ipset set of blacklisted IPs. Bouncers rely on crowdsec's Local API to be able to get informations about a given IP or such. You can explore available bouncers on the hub . To be able for your Bouncers to communicate with the local API, you have to generate an API token with cscli and put it in your Bouncers configuration file: $ sudo cscli bouncers add testBouncer Api key for 'testBouncer' : 6dcfe93f18675265e905aef390330a35 Please keep this key since you will not be able to retrive it! Note: this command must be run on the server where the local API is installed (or at least with a cscli that has valid credentials to communicate with the database used by the API).","title":"Bouncers"},{"location":"bouncers/index.html#bouncers","text":"Bouncers are standalone software pieces in charge of acting upon a decision taken by crowdsec : block an IP, present a captcha, enforce MFA on a given user, etc. They can either be within the applicative stack, or work out of band : nginx bouncer will check every unknown IP against the local API before letting go through or serving a 403 to the user, while a firewall bouncer will simply \"add\" malevolent IPs to nftables/ipset set of blacklisted IPs. Bouncers rely on crowdsec's Local API to be able to get informations about a given IP or such. You can explore available bouncers on the hub . To be able for your Bouncers to communicate with the local API, you have to generate an API token with cscli and put it in your Bouncers configuration file: $ sudo cscli bouncers add testBouncer Api key for 'testBouncer' : 6dcfe93f18675265e905aef390330a35 Please keep this key since you will not be able to retrive it! Note: this command must be run on the server where the local API is installed (or at least with a cscli that has valid credentials to communicate with the database used by the API).","title":"Bouncers"},{"location":"cscli/cscli.html","text":"cscli \u00b6 cscli allows you to manage crowdsec Synopsis \u00b6 cscli is the main command to interact with your crowdsec service, scenarios & db. It is meant to allow you to manage bans, parsers/scenarios/etc, api and generally manage you crowdsec setup. Options \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") -o, --output string Output format : human, json, raw. --debug Set logging to debug. --info Set logging to info. --warning Set logging to warning. --error Set logging to error. --trace Set logging to trace. -h, --help help for cscli SEE ALSO \u00b6 cscli alerts - Manage alerts cscli bouncers - Manage bouncers [requires local API] cscli capi - Manage interaction with Central API (CAPI) cscli collections - Manage collections from hub cscli completion - Generate completion script cscli config - Allows to view current config cscli console - Manage interaction with Crowdsec console (https://app.crowdsec.net) cscli dashboard - Manage your metabase dashboard container [requires local API] cscli decisions - Manage decisions cscli hub - Manage Hub cscli lapi - Manage interaction with Local API (LAPI) cscli machines - Manage local API machines [requires local API] cscli metrics - Display crowdsec prometheus metrics. cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub cscli simulation - Manage simulation status of scenarios cscli version - Display version and exit.","title":"Cscli"},{"location":"cscli/cscli.html#cscli","text":"cscli allows you to manage crowdsec","title":"cscli"},{"location":"cscli/cscli.html#synopsis","text":"cscli is the main command to interact with your crowdsec service, scenarios & db. It is meant to allow you to manage bans, parsers/scenarios/etc, api and generally manage you crowdsec setup.","title":"Synopsis"},{"location":"cscli/cscli.html#options","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") -o, --output string Output format : human, json, raw. --debug Set logging to debug. --info Set logging to info. --warning Set logging to warning. --error Set logging to error. --trace Set logging to trace. -h, --help help for cscli","title":"Options"},{"location":"cscli/cscli.html#see-also","text":"cscli alerts - Manage alerts cscli bouncers - Manage bouncers [requires local API] cscli capi - Manage interaction with Central API (CAPI) cscli collections - Manage collections from hub cscli completion - Generate completion script cscli config - Allows to view current config cscli console - Manage interaction with Crowdsec console (https://app.crowdsec.net) cscli dashboard - Manage your metabase dashboard container [requires local API] cscli decisions - Manage decisions cscli hub - Manage Hub cscli lapi - Manage interaction with Local API (LAPI) cscli machines - Manage local API machines [requires local API] cscli metrics - Display crowdsec prometheus metrics. cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub cscli simulation - Manage simulation status of scenarios cscli version - Display version and exit.","title":"SEE ALSO"},{"location":"cscli/cscli_alerts.html","text":"cscli alerts \u00b6 Manage alerts Options \u00b6 -h, --help help for alerts Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli alerts delete - Delete alerts /!\\ This command can be use only on the same machine than the local API. cscli alerts inspect - Show info about an alert cscli alerts list - List alerts","title":"Alerts"},{"location":"cscli/cscli_alerts.html#cscli-alerts","text":"Manage alerts","title":"cscli alerts"},{"location":"cscli/cscli_alerts.html#options","text":"-h, --help help for alerts","title":"Options"},{"location":"cscli/cscli_alerts.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_alerts.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli alerts delete - Delete alerts /!\\ This command can be use only on the same machine than the local API. cscli alerts inspect - Show info about an alert cscli alerts list - List alerts","title":"SEE ALSO"},{"location":"cscli/cscli_alerts_delete.html","text":"cscli alerts delete \u00b6 Delete alerts /!\\ This command can be use only on the same machine than the local API. cscli alerts delete [filters] [--all] [flags] Examples \u00b6 cscli alerts delete --ip 1.2.3.4 cscli alerts delete --range 1.2.3.0/24 cscli alerts delete -s crowdsecurity/ssh-bf\" Options \u00b6 --scope string the scope (ie. ip,range) -v, --value string the value to match for in the specified scope -s, --scenario string the scenario (ie. crowdsecurity/ssh-bf) -i, --ip string Source ip (shorthand for --scope ip --value <IP>) -r, --range string Range source ip (shorthand for --scope range --value <RANGE>) -a, --all delete all alerts --contained query decisions contained by range -h, --help help for delete Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli alerts - Manage alerts","title":"Cscli alerts delete"},{"location":"cscli/cscli_alerts_delete.html#cscli-alerts-delete","text":"Delete alerts /!\\ This command can be use only on the same machine than the local API. cscli alerts delete [filters] [--all] [flags]","title":"cscli alerts delete"},{"location":"cscli/cscli_alerts_delete.html#examples","text":"cscli alerts delete --ip 1.2.3.4 cscli alerts delete --range 1.2.3.0/24 cscli alerts delete -s crowdsecurity/ssh-bf\"","title":"Examples"},{"location":"cscli/cscli_alerts_delete.html#options","text":"--scope string the scope (ie. ip,range) -v, --value string the value to match for in the specified scope -s, --scenario string the scenario (ie. crowdsecurity/ssh-bf) -i, --ip string Source ip (shorthand for --scope ip --value <IP>) -r, --range string Range source ip (shorthand for --scope range --value <RANGE>) -a, --all delete all alerts --contained query decisions contained by range -h, --help help for delete","title":"Options"},{"location":"cscli/cscli_alerts_delete.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_alerts_delete.html#see-also","text":"cscli alerts - Manage alerts","title":"SEE ALSO"},{"location":"cscli/cscli_alerts_inspect.html","text":"cscli alerts inspect \u00b6 Show info about an alert cscli alerts inspect <alert_id> [flags] Examples \u00b6 cscli alerts inspect 123 Options \u00b6 -d, --details show alerts with events -h, --help help for inspect Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli alerts - Manage alerts","title":"Cscli alerts inspect"},{"location":"cscli/cscli_alerts_inspect.html#cscli-alerts-inspect","text":"Show info about an alert cscli alerts inspect <alert_id> [flags]","title":"cscli alerts inspect"},{"location":"cscli/cscli_alerts_inspect.html#examples","text":"cscli alerts inspect 123","title":"Examples"},{"location":"cscli/cscli_alerts_inspect.html#options","text":"-d, --details show alerts with events -h, --help help for inspect","title":"Options"},{"location":"cscli/cscli_alerts_inspect.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_alerts_inspect.html#see-also","text":"cscli alerts - Manage alerts","title":"SEE ALSO"},{"location":"cscli/cscli_alerts_list.html","text":"cscli alerts list \u00b6 List alerts cscli alerts list [filters] [flags] Examples \u00b6 cscli alerts list cscli alerts list --ip 1.2.3.4 cscli alerts list --range 1.2.3.0/24 cscli alerts list -s crowdsecurity/ssh-bf cscli alerts list --type ban Options \u00b6 --until string restrict to alerts older than until (ie. 4h, 30d) --since string restrict to alerts newer than since (ie. 4h, 30d) -i, --ip string restrict to alerts from this source ip (shorthand for --scope ip --value <IP>) -s, --scenario string the scenario (ie. crowdsecurity/ssh-bf) -r, --range string restrict to alerts from this range (shorthand for --scope range --value <RANGE/X>) --type string restrict to alerts with given decision type (ie. ban, captcha) --scope string restrict to alerts of this scope (ie. ip,range) -v, --value string the value to match for in the specified scope --contained query decisions contained by range -m, --machine print machines that sended alerts -l, --limit int limit size of alerts list table (0 to view all alerts) (default 50) -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli alerts - Manage alerts","title":"Cscli alerts list"},{"location":"cscli/cscli_alerts_list.html#cscli-alerts-list","text":"List alerts cscli alerts list [filters] [flags]","title":"cscli alerts list"},{"location":"cscli/cscli_alerts_list.html#examples","text":"cscli alerts list cscli alerts list --ip 1.2.3.4 cscli alerts list --range 1.2.3.0/24 cscli alerts list -s crowdsecurity/ssh-bf cscli alerts list --type ban","title":"Examples"},{"location":"cscli/cscli_alerts_list.html#options","text":"--until string restrict to alerts older than until (ie. 4h, 30d) --since string restrict to alerts newer than since (ie. 4h, 30d) -i, --ip string restrict to alerts from this source ip (shorthand for --scope ip --value <IP>) -s, --scenario string the scenario (ie. crowdsecurity/ssh-bf) -r, --range string restrict to alerts from this range (shorthand for --scope range --value <RANGE/X>) --type string restrict to alerts with given decision type (ie. ban, captcha) --scope string restrict to alerts of this scope (ie. ip,range) -v, --value string the value to match for in the specified scope --contained query decisions contained by range -m, --machine print machines that sended alerts -l, --limit int limit size of alerts list table (0 to view all alerts) (default 50) -h, --help help for list","title":"Options"},{"location":"cscli/cscli_alerts_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_alerts_list.html#see-also","text":"cscli alerts - Manage alerts","title":"SEE ALSO"},{"location":"cscli/cscli_bouncers.html","text":"cscli bouncers \u00b6 Manage bouncers [requires local API] Synopsis \u00b6 To list/add/delete bouncers. Note: This command requires database direct access, so is intended to be run on Local API/master. Options \u00b6 -h, --help help for bouncers Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli bouncers add - add bouncer cscli bouncers delete - delete bouncer cscli bouncers list - List bouncers","title":"Bouncers"},{"location":"cscli/cscli_bouncers.html#cscli-bouncers","text":"Manage bouncers [requires local API]","title":"cscli bouncers"},{"location":"cscli/cscli_bouncers.html#synopsis","text":"To list/add/delete bouncers. Note: This command requires database direct access, so is intended to be run on Local API/master.","title":"Synopsis"},{"location":"cscli/cscli_bouncers.html#options","text":"-h, --help help for bouncers","title":"Options"},{"location":"cscli/cscli_bouncers.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_bouncers.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli bouncers add - add bouncer cscli bouncers delete - delete bouncer cscli bouncers list - List bouncers","title":"SEE ALSO"},{"location":"cscli/cscli_bouncers_add.html","text":"cscli bouncers add \u00b6 add bouncer Synopsis \u00b6 add bouncer cscli bouncers add MyBouncerName [--length 16] [flags] Examples \u00b6 cscli bouncers add MyBouncerName cscli bouncers add MyBouncerName -l 24 Options \u00b6 -h, --help help for add -l, --length int length of the api key (default 16) Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli bouncers - Manage bouncers [requires local API]","title":"Cscli bouncers add"},{"location":"cscli/cscli_bouncers_add.html#cscli-bouncers-add","text":"add bouncer","title":"cscli bouncers add"},{"location":"cscli/cscli_bouncers_add.html#synopsis","text":"add bouncer cscli bouncers add MyBouncerName [--length 16] [flags]","title":"Synopsis"},{"location":"cscli/cscli_bouncers_add.html#examples","text":"cscli bouncers add MyBouncerName cscli bouncers add MyBouncerName -l 24","title":"Examples"},{"location":"cscli/cscli_bouncers_add.html#options","text":"-h, --help help for add -l, --length int length of the api key (default 16)","title":"Options"},{"location":"cscli/cscli_bouncers_add.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_bouncers_add.html#see-also","text":"cscli bouncers - Manage bouncers [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_bouncers_delete.html","text":"cscli bouncers delete \u00b6 delete bouncer cscli bouncers delete MyBouncerName [flags] Options \u00b6 -h, --help help for delete Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli bouncers - Manage bouncers [requires local API]","title":"Cscli bouncers delete"},{"location":"cscli/cscli_bouncers_delete.html#cscli-bouncers-delete","text":"delete bouncer cscli bouncers delete MyBouncerName [flags]","title":"cscli bouncers delete"},{"location":"cscli/cscli_bouncers_delete.html#options","text":"-h, --help help for delete","title":"Options"},{"location":"cscli/cscli_bouncers_delete.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_bouncers_delete.html#see-also","text":"cscli bouncers - Manage bouncers [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_bouncers_list.html","text":"cscli bouncers list \u00b6 List bouncers Synopsis \u00b6 List bouncers cscli bouncers list [flags] Examples \u00b6 cscli bouncers list Options \u00b6 -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli bouncers - Manage bouncers [requires local API]","title":"Cscli bouncers list"},{"location":"cscli/cscli_bouncers_list.html#cscli-bouncers-list","text":"List bouncers","title":"cscli bouncers list"},{"location":"cscli/cscli_bouncers_list.html#synopsis","text":"List bouncers cscli bouncers list [flags]","title":"Synopsis"},{"location":"cscli/cscli_bouncers_list.html#examples","text":"cscli bouncers list","title":"Examples"},{"location":"cscli/cscli_bouncers_list.html#options","text":"-h, --help help for list","title":"Options"},{"location":"cscli/cscli_bouncers_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_bouncers_list.html#see-also","text":"cscli bouncers - Manage bouncers [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_capi.html","text":"cscli capi \u00b6 Manage interaction with Central API (CAPI) Options \u00b6 -h, --help help for capi Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli capi register - Register to Central API (CAPI) cscli capi status - Check status with the Central API (CAPI)","title":"Cscli capi"},{"location":"cscli/cscli_capi.html#cscli-capi","text":"Manage interaction with Central API (CAPI)","title":"cscli capi"},{"location":"cscli/cscli_capi.html#options","text":"-h, --help help for capi","title":"Options"},{"location":"cscli/cscli_capi.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_capi.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli capi register - Register to Central API (CAPI) cscli capi status - Check status with the Central API (CAPI)","title":"SEE ALSO"},{"location":"cscli/cscli_capi_register.html","text":"cscli capi register \u00b6 Register to Central API (CAPI) cscli capi register [flags] Options \u00b6 -f, --file string output file destination -h, --help help for register Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli capi - Manage interaction with Central API (CAPI)","title":"Cscli capi register"},{"location":"cscli/cscli_capi_register.html#cscli-capi-register","text":"Register to Central API (CAPI) cscli capi register [flags]","title":"cscli capi register"},{"location":"cscli/cscli_capi_register.html#options","text":"-f, --file string output file destination -h, --help help for register","title":"Options"},{"location":"cscli/cscli_capi_register.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_capi_register.html#see-also","text":"cscli capi - Manage interaction with Central API (CAPI)","title":"SEE ALSO"},{"location":"cscli/cscli_capi_status.html","text":"cscli capi status \u00b6 Check status with the Central API (CAPI) cscli capi status [flags] Options \u00b6 -h, --help help for status Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli capi - Manage interaction with Central API (CAPI)","title":"Cscli capi status"},{"location":"cscli/cscli_capi_status.html#cscli-capi-status","text":"Check status with the Central API (CAPI) cscli capi status [flags]","title":"cscli capi status"},{"location":"cscli/cscli_capi_status.html#options","text":"-h, --help help for status","title":"Options"},{"location":"cscli/cscli_capi_status.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_capi_status.html#see-also","text":"cscli capi - Manage interaction with Central API (CAPI)","title":"SEE ALSO"},{"location":"cscli/cscli_collections.html","text":"cscli collections \u00b6 Manage collections from hub Synopsis \u00b6 Install/Remove/Upgrade/Inspect collections from the CrowdSec Hub. Options \u00b6 -h, --help help for collections Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli collections inspect - Inspect given collection cscli collections install - Install given collection(s) cscli collections list - List all collections or given one cscli collections remove - Remove given collection(s) cscli collections upgrade - Upgrade given collection(s)","title":"Collections"},{"location":"cscli/cscli_collections.html#cscli-collections","text":"Manage collections from hub","title":"cscli collections"},{"location":"cscli/cscli_collections.html#synopsis","text":"Install/Remove/Upgrade/Inspect collections from the CrowdSec Hub.","title":"Synopsis"},{"location":"cscli/cscli_collections.html#options","text":"-h, --help help for collections","title":"Options"},{"location":"cscli/cscli_collections.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_collections.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli collections inspect - Inspect given collection cscli collections install - Install given collection(s) cscli collections list - List all collections or given one cscli collections remove - Remove given collection(s) cscli collections upgrade - Upgrade given collection(s)","title":"SEE ALSO"},{"location":"cscli/cscli_collections_inspect.html","text":"cscli collections inspect \u00b6 Inspect given collection Synopsis \u00b6 Inspect given collection cscli collections inspect collection [flags] Examples \u00b6 cscli collections inspect crowdsec/xxx crowdsec/xyz Options \u00b6 -h, --help help for inspect -u, --url string Prometheus url Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli collections - Manage collections from hub","title":"Cscli collections inspect"},{"location":"cscli/cscli_collections_inspect.html#cscli-collections-inspect","text":"Inspect given collection","title":"cscli collections inspect"},{"location":"cscli/cscli_collections_inspect.html#synopsis","text":"Inspect given collection cscli collections inspect collection [flags]","title":"Synopsis"},{"location":"cscli/cscli_collections_inspect.html#examples","text":"cscli collections inspect crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_collections_inspect.html#options","text":"-h, --help help for inspect -u, --url string Prometheus url","title":"Options"},{"location":"cscli/cscli_collections_inspect.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_collections_inspect.html#see-also","text":"cscli collections - Manage collections from hub","title":"SEE ALSO"},{"location":"cscli/cscli_collections_install.html","text":"cscli collections install \u00b6 Install given collection(s) Synopsis \u00b6 Fetch and install given collection(s) from hub cscli collections install collection [flags] Examples \u00b6 cscli collections install crowdsec/xxx crowdsec/xyz Options \u00b6 -d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli collections - Manage collections from hub","title":"Cscli collections install"},{"location":"cscli/cscli_collections_install.html#cscli-collections-install","text":"Install given collection(s)","title":"cscli collections install"},{"location":"cscli/cscli_collections_install.html#synopsis","text":"Fetch and install given collection(s) from hub cscli collections install collection [flags]","title":"Synopsis"},{"location":"cscli/cscli_collections_install.html#examples","text":"cscli collections install crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_collections_install.html#options","text":"-d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install","title":"Options"},{"location":"cscli/cscli_collections_install.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_collections_install.html#see-also","text":"cscli collections - Manage collections from hub","title":"SEE ALSO"},{"location":"cscli/cscli_collections_list.html","text":"cscli collections list \u00b6 List all collections or given one Synopsis \u00b6 List all collections or given one cscli collections list collection [-a] [flags] Examples \u00b6 cscli collections list Options \u00b6 -a, --all List as well disabled items -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli collections - Manage collections from hub","title":"Cscli collections list"},{"location":"cscli/cscli_collections_list.html#cscli-collections-list","text":"List all collections or given one","title":"cscli collections list"},{"location":"cscli/cscli_collections_list.html#synopsis","text":"List all collections or given one cscli collections list collection [-a] [flags]","title":"Synopsis"},{"location":"cscli/cscli_collections_list.html#examples","text":"cscli collections list","title":"Examples"},{"location":"cscli/cscli_collections_list.html#options","text":"-a, --all List as well disabled items -h, --help help for list","title":"Options"},{"location":"cscli/cscli_collections_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_collections_list.html#see-also","text":"cscli collections - Manage collections from hub","title":"SEE ALSO"},{"location":"cscli/cscli_collections_remove.html","text":"cscli collections remove \u00b6 Remove given collection(s) Synopsis \u00b6 Remove given collection(s) from hub cscli collections remove collection [flags] Examples \u00b6 cscli collections remove crowdsec/xxx crowdsec/xyz Options \u00b6 --all Delete all the collections --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli collections - Manage collections from hub","title":"Cscli collections remove"},{"location":"cscli/cscli_collections_remove.html#cscli-collections-remove","text":"Remove given collection(s)","title":"cscli collections remove"},{"location":"cscli/cscli_collections_remove.html#synopsis","text":"Remove given collection(s) from hub cscli collections remove collection [flags]","title":"Synopsis"},{"location":"cscli/cscli_collections_remove.html#examples","text":"cscli collections remove crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_collections_remove.html#options","text":"--all Delete all the collections --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too","title":"Options"},{"location":"cscli/cscli_collections_remove.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_collections_remove.html#see-also","text":"cscli collections - Manage collections from hub","title":"SEE ALSO"},{"location":"cscli/cscli_collections_upgrade.html","text":"cscli collections upgrade \u00b6 Upgrade given collection(s) Synopsis \u00b6 Fetch and upgrade given collection(s) from hub cscli collections upgrade collection [flags] Examples \u00b6 cscli collections upgrade crowdsec/xxx crowdsec/xyz Options \u00b6 -a, --all Upgrade all the collections --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli collections - Manage collections from hub","title":"Cscli collections upgrade"},{"location":"cscli/cscli_collections_upgrade.html#cscli-collections-upgrade","text":"Upgrade given collection(s)","title":"cscli collections upgrade"},{"location":"cscli/cscli_collections_upgrade.html#synopsis","text":"Fetch and upgrade given collection(s) from hub cscli collections upgrade collection [flags]","title":"Synopsis"},{"location":"cscli/cscli_collections_upgrade.html#examples","text":"cscli collections upgrade crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_collections_upgrade.html#options","text":"-a, --all Upgrade all the collections --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade","title":"Options"},{"location":"cscli/cscli_collections_upgrade.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_collections_upgrade.html#see-also","text":"cscli collections - Manage collections from hub","title":"SEE ALSO"},{"location":"cscli/cscli_completion.html","text":"cscli completion \u00b6 Generate completion script Synopsis \u00b6 To load completions: Bash: \u00b6 $ source <(cscli completion bash) # To load completions for each session, execute once: # Linux: $ cscli completion bash | sudo tee /etc/bash_completion.d/cscli $ source ~/.bashrc # macOS: $ cscli completion bash | sudo tee /usr/local/etc/bash_completion.d/cscli # Troubleshoot: If you have this error (bash: _get_comp_words_by_ref: command not found), it seems that you need \"bash-completion\" dependency : Install bash-completion package $ source /etc/profile $ source <(cscli completion bash) Zsh: \u00b6 # If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: $ echo \"autoload -U compinit; compinit\" >> ~/.zshrc # To load completions for each session, execute once: $ cscli completion zsh > \"${fpath[1]}/_cscli\" # You will need to start a new shell for this setup to take effect. cscli completion [bash|zsh] Options \u00b6 -h, --help help for completion Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec","title":"Completion"},{"location":"cscli/cscli_completion.html#cscli-completion","text":"Generate completion script","title":"cscli completion"},{"location":"cscli/cscli_completion.html#synopsis","text":"To load completions:","title":"Synopsis"},{"location":"cscli/cscli_completion.html#bash","text":"$ source <(cscli completion bash) # To load completions for each session, execute once: # Linux: $ cscli completion bash | sudo tee /etc/bash_completion.d/cscli $ source ~/.bashrc # macOS: $ cscli completion bash | sudo tee /usr/local/etc/bash_completion.d/cscli # Troubleshoot: If you have this error (bash: _get_comp_words_by_ref: command not found), it seems that you need \"bash-completion\" dependency : Install bash-completion package $ source /etc/profile $ source <(cscli completion bash)","title":"Bash:"},{"location":"cscli/cscli_completion.html#zsh","text":"# If shell completion is not already enabled in your environment, # you will need to enable it. You can execute the following once: $ echo \"autoload -U compinit; compinit\" >> ~/.zshrc # To load completions for each session, execute once: $ cscli completion zsh > \"${fpath[1]}/_cscli\" # You will need to start a new shell for this setup to take effect. cscli completion [bash|zsh]","title":"Zsh:"},{"location":"cscli/cscli_completion.html#options","text":"-h, --help help for completion","title":"Options"},{"location":"cscli/cscli_completion.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_completion.html#see-also","text":"cscli - cscli allows you to manage crowdsec","title":"SEE ALSO"},{"location":"cscli/cscli_config.html","text":"cscli config \u00b6 Allows to view current config Options \u00b6 -h, --help help for config Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli config backup - Backup current config cscli config restore - Restore config in backup cscli config show - Displays current config","title":"Config"},{"location":"cscli/cscli_config.html#cscli-config","text":"Allows to view current config","title":"cscli config"},{"location":"cscli/cscli_config.html#options","text":"-h, --help help for config","title":"Options"},{"location":"cscli/cscli_config.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_config.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli config backup - Backup current config cscli config restore - Restore config in backup cscli config show - Displays current config","title":"SEE ALSO"},{"location":"cscli/cscli_config_backup.html","text":"cscli config backup \u00b6 Backup current config Synopsis \u00b6 Backup the current crowdsec configuration including : Main config (config.yaml) Simulation config (simulation.yaml) Profiles config (profiles.yaml) List of scenarios, parsers, postoverflows and collections that are up-to-date Tainted/local/out-of-date scenarios, parsers, postoverflows and collections Backup of API credentials (local API and online API) cscli config backup <directory> [flags] Examples \u00b6 cscli config backup ./my-backup Options \u00b6 -h, --help help for backup Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli config - Allows to view current config","title":"Cscli config backup"},{"location":"cscli/cscli_config_backup.html#cscli-config-backup","text":"Backup current config","title":"cscli config backup"},{"location":"cscli/cscli_config_backup.html#synopsis","text":"Backup the current crowdsec configuration including : Main config (config.yaml) Simulation config (simulation.yaml) Profiles config (profiles.yaml) List of scenarios, parsers, postoverflows and collections that are up-to-date Tainted/local/out-of-date scenarios, parsers, postoverflows and collections Backup of API credentials (local API and online API) cscli config backup <directory> [flags]","title":"Synopsis"},{"location":"cscli/cscli_config_backup.html#examples","text":"cscli config backup ./my-backup","title":"Examples"},{"location":"cscli/cscli_config_backup.html#options","text":"-h, --help help for backup","title":"Options"},{"location":"cscli/cscli_config_backup.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_config_backup.html#see-also","text":"cscli config - Allows to view current config","title":"SEE ALSO"},{"location":"cscli/cscli_config_restore.html","text":"cscli config restore \u00b6 Restore config in backup Synopsis \u00b6 Restore the crowdsec configuration from specified backup including: Main config (config.yaml) Simulation config (simulation.yaml) Profiles config (profiles.yaml) List of scenarios, parsers, postoverflows and collections that are up-to-date Tainted/local/out-of-date scenarios, parsers, postoverflows and collections Backup of API credentials (local API and online API) cscli config restore <directory> [flags] Options \u00b6 -h, --help help for restore --old-backup To use when you are upgrading crowdsec v0.X to v1.X and you need to restore backup from v0.X Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli config - Allows to view current config","title":"Cscli config restore"},{"location":"cscli/cscli_config_restore.html#cscli-config-restore","text":"Restore config in backup","title":"cscli config restore"},{"location":"cscli/cscli_config_restore.html#synopsis","text":"Restore the crowdsec configuration from specified backup including: Main config (config.yaml) Simulation config (simulation.yaml) Profiles config (profiles.yaml) List of scenarios, parsers, postoverflows and collections that are up-to-date Tainted/local/out-of-date scenarios, parsers, postoverflows and collections Backup of API credentials (local API and online API) cscli config restore <directory> [flags]","title":"Synopsis"},{"location":"cscli/cscli_config_restore.html#options","text":"-h, --help help for restore --old-backup To use when you are upgrading crowdsec v0.X to v1.X and you need to restore backup from v0.X","title":"Options"},{"location":"cscli/cscli_config_restore.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_config_restore.html#see-also","text":"cscli config - Allows to view current config","title":"SEE ALSO"},{"location":"cscli/cscli_config_show.html","text":"cscli config show \u00b6 Displays current config Synopsis \u00b6 Displays the current cli configuration. cscli config show [flags] Options \u00b6 -h, --help help for show Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli config - Allows to view current config","title":"Cscli config show"},{"location":"cscli/cscli_config_show.html#cscli-config-show","text":"Displays current config","title":"cscli config show"},{"location":"cscli/cscli_config_show.html#synopsis","text":"Displays the current cli configuration. cscli config show [flags]","title":"Synopsis"},{"location":"cscli/cscli_config_show.html#options","text":"-h, --help help for show","title":"Options"},{"location":"cscli/cscli_config_show.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_config_show.html#see-also","text":"cscli config - Allows to view current config","title":"SEE ALSO"},{"location":"cscli/cscli_console.html","text":"cscli console \u00b6 Manage interaction with Crowdsec console (https://app.crowdsec.net) Options \u00b6 -h, --help help for console Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli console enroll - Enroll this instance to https://app.crowdsec.net [requires local API]","title":"Cscli console"},{"location":"cscli/cscli_console.html#cscli-console","text":"Manage interaction with Crowdsec console (https://app.crowdsec.net)","title":"cscli console"},{"location":"cscli/cscli_console.html#options","text":"-h, --help help for console","title":"Options"},{"location":"cscli/cscli_console.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_console.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli console enroll - Enroll this instance to https://app.crowdsec.net [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_console_enroll.html","text":"cscli console enroll \u00b6 Enroll this instance to https://app.crowdsec.net [requires local API] Synopsis \u00b6 Enroll this instance to https://app.crowdsec.net You can get your enrollment key by creating an account on https://app.crowdsec.net. After running this command your will need to validate the enrollment in the webapp. cscli console enroll [enroll-key] [flags] Examples \u00b6 cscli console enroll YOUR-ENROLL-KEY Options \u00b6 -h, --help help for enroll Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli console - Manage interaction with Crowdsec console (https://app.crowdsec.net)","title":"Cscli console enroll"},{"location":"cscli/cscli_console_enroll.html#cscli-console-enroll","text":"Enroll this instance to https://app.crowdsec.net [requires local API]","title":"cscli console enroll"},{"location":"cscli/cscli_console_enroll.html#synopsis","text":"Enroll this instance to https://app.crowdsec.net You can get your enrollment key by creating an account on https://app.crowdsec.net. After running this command your will need to validate the enrollment in the webapp. cscli console enroll [enroll-key] [flags]","title":"Synopsis"},{"location":"cscli/cscli_console_enroll.html#examples","text":"cscli console enroll YOUR-ENROLL-KEY","title":"Examples"},{"location":"cscli/cscli_console_enroll.html#options","text":"-h, --help help for enroll","title":"Options"},{"location":"cscli/cscli_console_enroll.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_console_enroll.html#see-also","text":"cscli console - Manage interaction with Crowdsec console (https://app.crowdsec.net)","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard.html","text":"cscli dashboard \u00b6 Manage your metabase dashboard container [requires local API] Synopsis \u00b6 Install/Start/Stop/Remove a metabase container exposing dashboard and metrics. Note: This command requires database direct access, so is intended to be run on Local API/master. Examples \u00b6 cscli dashboard setup cscli dashboard start cscli dashboard stop cscli dashboard remove Options \u00b6 -h, --help help for dashboard Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli dashboard remove - removes the metabase container. cscli dashboard setup - Setup a metabase container. cscli dashboard start - Start the metabase container. cscli dashboard stop - Stops the metabase container.","title":"Dashboard"},{"location":"cscli/cscli_dashboard.html#cscli-dashboard","text":"Manage your metabase dashboard container [requires local API]","title":"cscli dashboard"},{"location":"cscli/cscli_dashboard.html#synopsis","text":"Install/Start/Stop/Remove a metabase container exposing dashboard and metrics. Note: This command requires database direct access, so is intended to be run on Local API/master.","title":"Synopsis"},{"location":"cscli/cscli_dashboard.html#examples","text":"cscli dashboard setup cscli dashboard start cscli dashboard stop cscli dashboard remove","title":"Examples"},{"location":"cscli/cscli_dashboard.html#options","text":"-h, --help help for dashboard","title":"Options"},{"location":"cscli/cscli_dashboard.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli dashboard remove - removes the metabase container. cscli dashboard setup - Setup a metabase container. cscli dashboard start - Start the metabase container. cscli dashboard stop - Stops the metabase container.","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_remove.html","text":"cscli dashboard remove \u00b6 removes the metabase container. Synopsis \u00b6 removes the metabase container using docker. cscli dashboard remove [flags] Examples \u00b6 cscli dashboard remove cscli dashboard remove --force Options \u00b6 -f, --force Remove also the metabase image -h, --help help for remove -y, --yes force yes Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"Cscli dashboard remove"},{"location":"cscli/cscli_dashboard_remove.html#cscli-dashboard-remove","text":"removes the metabase container.","title":"cscli dashboard remove"},{"location":"cscli/cscli_dashboard_remove.html#synopsis","text":"removes the metabase container using docker. cscli dashboard remove [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_remove.html#examples","text":"cscli dashboard remove cscli dashboard remove --force","title":"Examples"},{"location":"cscli/cscli_dashboard_remove.html#options","text":"-f, --force Remove also the metabase image -h, --help help for remove -y, --yes force yes","title":"Options"},{"location":"cscli/cscli_dashboard_remove.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_remove.html#see-also","text":"cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_setup.html","text":"cscli dashboard setup \u00b6 Setup a metabase container. Synopsis \u00b6 Perform a metabase docker setup, download standard dashboards, create a fresh user and start the container cscli dashboard setup [flags] Examples \u00b6 cscli dashboard setup cscli dashboard setup --listen 0.0.0.0 cscli dashboard setup -l 0.0.0.0 -p 443 --password <password> Options \u00b6 -d, --dir string Shared directory with metabase container. -f, --force Force setup : override existing files. -h, --help help for setup -l, --listen string Listen address of container (default \"127.0.0.1\") --password string metabase password -p, --port string Listen port of container (default \"3000\") -y, --yes force yes Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"Cscli dashboard setup"},{"location":"cscli/cscli_dashboard_setup.html#cscli-dashboard-setup","text":"Setup a metabase container.","title":"cscli dashboard setup"},{"location":"cscli/cscli_dashboard_setup.html#synopsis","text":"Perform a metabase docker setup, download standard dashboards, create a fresh user and start the container cscli dashboard setup [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_setup.html#examples","text":"cscli dashboard setup cscli dashboard setup --listen 0.0.0.0 cscli dashboard setup -l 0.0.0.0 -p 443 --password <password>","title":"Examples"},{"location":"cscli/cscli_dashboard_setup.html#options","text":"-d, --dir string Shared directory with metabase container. -f, --force Force setup : override existing files. -h, --help help for setup -l, --listen string Listen address of container (default \"127.0.0.1\") --password string metabase password -p, --port string Listen port of container (default \"3000\") -y, --yes force yes","title":"Options"},{"location":"cscli/cscli_dashboard_setup.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_setup.html#see-also","text":"cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_start.html","text":"cscli dashboard start \u00b6 Start the metabase container. Synopsis \u00b6 Stats the metabase container using docker. cscli dashboard start [flags] Options \u00b6 -h, --help help for start Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"Cscli dashboard start"},{"location":"cscli/cscli_dashboard_start.html#cscli-dashboard-start","text":"Start the metabase container.","title":"cscli dashboard start"},{"location":"cscli/cscli_dashboard_start.html#synopsis","text":"Stats the metabase container using docker. cscli dashboard start [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_start.html#options","text":"-h, --help help for start","title":"Options"},{"location":"cscli/cscli_dashboard_start.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_start.html#see-also","text":"cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_stop.html","text":"cscli dashboard stop \u00b6 Stops the metabase container. Synopsis \u00b6 Stops the metabase container using docker. cscli dashboard stop [flags] Options \u00b6 -h, --help help for stop Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"Cscli dashboard stop"},{"location":"cscli/cscli_dashboard_stop.html#cscli-dashboard-stop","text":"Stops the metabase container.","title":"cscli dashboard stop"},{"location":"cscli/cscli_dashboard_stop.html#synopsis","text":"Stops the metabase container using docker. cscli dashboard stop [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_stop.html#options","text":"-h, --help help for stop","title":"Options"},{"location":"cscli/cscli_dashboard_stop.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_stop.html#see-also","text":"cscli dashboard - Manage your metabase dashboard container [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_decisions.html","text":"cscli decisions \u00b6 Manage decisions Synopsis \u00b6 Add/List/Delete decisions from LAPI Examples \u00b6 cscli decisions [action] [filter] Options \u00b6 -h, --help help for decisions Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli decisions add - Add decision to LAPI cscli decisions delete - Delete decisions cscli decisions list - List decisions from LAPI","title":"Decisions"},{"location":"cscli/cscli_decisions.html#cscli-decisions","text":"Manage decisions","title":"cscli decisions"},{"location":"cscli/cscli_decisions.html#synopsis","text":"Add/List/Delete decisions from LAPI","title":"Synopsis"},{"location":"cscli/cscli_decisions.html#examples","text":"cscli decisions [action] [filter]","title":"Examples"},{"location":"cscli/cscli_decisions.html#options","text":"-h, --help help for decisions","title":"Options"},{"location":"cscli/cscli_decisions.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_decisions.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli decisions add - Add decision to LAPI cscli decisions delete - Delete decisions cscli decisions list - List decisions from LAPI","title":"SEE ALSO"},{"location":"cscli/cscli_decisions_add.html","text":"cscli decisions add \u00b6 Add decision to LAPI cscli decisions add [options] [flags] Examples \u00b6 cscli decisions add --ip 1.2.3.4 cscli decisions add --range 1.2.3.0/24 cscli decisions add --ip 1.2.3.4 --duration 24h --type captcha cscli decisions add --scope username --value foobar Options \u00b6 -i, --ip string Source ip (shorthand for --scope ip --value <IP>) -r, --range string Range source ip (shorthand for --scope range --value <RANGE>) -d, --duration string Decision duration (ie. 1h,4h,30m) (default \"4h\") -v, --value string The value (ie. --scope username --value foobar) --scope string Decision scope (ie. ip,range,username) (default \"Ip\") -R, --reason string Decision reason (ie. scenario-name) -t, --type string Decision type (ie. ban,captcha,throttle) (default \"ban\") -h, --help help for add Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli decisions - Manage decisions","title":"Cscli decisions add"},{"location":"cscli/cscli_decisions_add.html#cscli-decisions-add","text":"Add decision to LAPI cscli decisions add [options] [flags]","title":"cscli decisions add"},{"location":"cscli/cscli_decisions_add.html#examples","text":"cscli decisions add --ip 1.2.3.4 cscli decisions add --range 1.2.3.0/24 cscli decisions add --ip 1.2.3.4 --duration 24h --type captcha cscli decisions add --scope username --value foobar","title":"Examples"},{"location":"cscli/cscli_decisions_add.html#options","text":"-i, --ip string Source ip (shorthand for --scope ip --value <IP>) -r, --range string Range source ip (shorthand for --scope range --value <RANGE>) -d, --duration string Decision duration (ie. 1h,4h,30m) (default \"4h\") -v, --value string The value (ie. --scope username --value foobar) --scope string Decision scope (ie. ip,range,username) (default \"Ip\") -R, --reason string Decision reason (ie. scenario-name) -t, --type string Decision type (ie. ban,captcha,throttle) (default \"ban\") -h, --help help for add","title":"Options"},{"location":"cscli/cscli_decisions_add.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_decisions_add.html#see-also","text":"cscli decisions - Manage decisions","title":"SEE ALSO"},{"location":"cscli/cscli_decisions_delete.html","text":"cscli decisions delete \u00b6 Delete decisions cscli decisions delete [options] [flags] Examples \u00b6 cscli decisions delete -r 1.2.3.0/24 cscli decisions delete -i 1.2.3.4 cscli decisions delete -s crowdsecurity/ssh-bf cscli decisions delete --id 42 cscli decisions delete --type captcha Options \u00b6 -i, --ip string Source ip (shorthand for --scope ip --value <IP>) -r, --range string Range source ip (shorthand for --scope range --value <RANGE>) --id string decision id -t, --type string the decision type (ie. ban,captcha) -v, --value string the value to match for in the specified scope --all delete all decisions --contained query decisions contained by range -h, --help help for delete Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli decisions - Manage decisions","title":"Cscli decisions delete"},{"location":"cscli/cscli_decisions_delete.html#cscli-decisions-delete","text":"Delete decisions cscli decisions delete [options] [flags]","title":"cscli decisions delete"},{"location":"cscli/cscli_decisions_delete.html#examples","text":"cscli decisions delete -r 1.2.3.0/24 cscli decisions delete -i 1.2.3.4 cscli decisions delete -s crowdsecurity/ssh-bf cscli decisions delete --id 42 cscli decisions delete --type captcha","title":"Examples"},{"location":"cscli/cscli_decisions_delete.html#options","text":"-i, --ip string Source ip (shorthand for --scope ip --value <IP>) -r, --range string Range source ip (shorthand for --scope range --value <RANGE>) --id string decision id -t, --type string the decision type (ie. ban,captcha) -v, --value string the value to match for in the specified scope --all delete all decisions --contained query decisions contained by range -h, --help help for delete","title":"Options"},{"location":"cscli/cscli_decisions_delete.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_decisions_delete.html#see-also","text":"cscli decisions - Manage decisions","title":"SEE ALSO"},{"location":"cscli/cscli_decisions_list.html","text":"cscli decisions list \u00b6 List decisions from LAPI cscli decisions list [options] [flags] Examples \u00b6 cscli decisions list -i 1.2.3.4 cscli decisions list -r 1.2.3.0/24 cscli decisions list -s crowdsecurity/ssh-bf cscli decisions list -t ban Options \u00b6 -a, --all Include decisions from Central API --since string restrict to alerts newer than since (ie. 4h, 30d) --until string restrict to alerts older than until (ie. 4h, 30d) -t, --type string restrict to this decision type (ie. ban,captcha) --scope string restrict to this scope (ie. ip,range,session) -v, --value string restrict to this value (ie. 1.2.3.4,userName) -s, --scenario string restrict to this scenario (ie. crowdsecurity/ssh-bf) -i, --ip string restrict to alerts from this source ip (shorthand for --scope ip --value <IP>) -r, --range string restrict to alerts from this source range (shorthand for --scope range --value <RANGE>) --no-simu exclude decisions in simulation mode --contained query decisions contained by range -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli decisions - Manage decisions","title":"Cscli decisions list"},{"location":"cscli/cscli_decisions_list.html#cscli-decisions-list","text":"List decisions from LAPI cscli decisions list [options] [flags]","title":"cscli decisions list"},{"location":"cscli/cscli_decisions_list.html#examples","text":"cscli decisions list -i 1.2.3.4 cscli decisions list -r 1.2.3.0/24 cscli decisions list -s crowdsecurity/ssh-bf cscli decisions list -t ban","title":"Examples"},{"location":"cscli/cscli_decisions_list.html#options","text":"-a, --all Include decisions from Central API --since string restrict to alerts newer than since (ie. 4h, 30d) --until string restrict to alerts older than until (ie. 4h, 30d) -t, --type string restrict to this decision type (ie. ban,captcha) --scope string restrict to this scope (ie. ip,range,session) -v, --value string restrict to this value (ie. 1.2.3.4,userName) -s, --scenario string restrict to this scenario (ie. crowdsecurity/ssh-bf) -i, --ip string restrict to alerts from this source ip (shorthand for --scope ip --value <IP>) -r, --range string restrict to alerts from this source range (shorthand for --scope range --value <RANGE>) --no-simu exclude decisions in simulation mode --contained query decisions contained by range -h, --help help for list","title":"Options"},{"location":"cscli/cscli_decisions_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_decisions_list.html#see-also","text":"cscli decisions - Manage decisions","title":"SEE ALSO"},{"location":"cscli/cscli_hub.html","text":"cscli hub \u00b6 Manage Hub Synopsis \u00b6 Hub management List/update parsers/scenarios/postoverflows/collections from Crowdsec Hub . Hub is manage by cscli, to get latest hub files from Crowdsec Hub , you need to update. Examples \u00b6 cscli hub list # List all installed configurations cscli hub update # Download list of available configurations from the hub Options \u00b6 -h, --help help for hub Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli hub list - List installed configs cscli hub update - Fetch available configs from hub cscli hub upgrade - Upgrade all configs installed from hub","title":"Hub"},{"location":"cscli/cscli_hub.html#cscli-hub","text":"Manage Hub","title":"cscli hub"},{"location":"cscli/cscli_hub.html#synopsis","text":"Hub management List/update parsers/scenarios/postoverflows/collections from Crowdsec Hub . Hub is manage by cscli, to get latest hub files from Crowdsec Hub , you need to update.","title":"Synopsis"},{"location":"cscli/cscli_hub.html#examples","text":"cscli hub list # List all installed configurations cscli hub update # Download list of available configurations from the hub","title":"Examples"},{"location":"cscli/cscli_hub.html#options","text":"-h, --help help for hub","title":"Options"},{"location":"cscli/cscli_hub.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_hub.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli hub list - List installed configs cscli hub update - Fetch available configs from hub cscli hub upgrade - Upgrade all configs installed from hub","title":"SEE ALSO"},{"location":"cscli/cscli_hub_list.html","text":"cscli hub list \u00b6 List installed configs cscli hub list [-a] [flags] Options \u00b6 -a, --all List as well disabled items -h, --help help for list Options inherited from parent commands \u00b6 -b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli hub - Manage Hub","title":"Cscli hub list"},{"location":"cscli/cscli_hub_list.html#cscli-hub-list","text":"List installed configs cscli hub list [-a] [flags]","title":"cscli hub list"},{"location":"cscli/cscli_hub_list.html#options","text":"-a, --all List as well disabled items -h, --help help for list","title":"Options"},{"location":"cscli/cscli_hub_list.html#options-inherited-from-parent-commands","text":"-b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_hub_list.html#see-also","text":"cscli hub - Manage Hub","title":"SEE ALSO"},{"location":"cscli/cscli_hub_update.html","text":"cscli hub update \u00b6 Fetch available configs from hub Synopsis \u00b6 Fetches the .index.json file from hub, containing the list of available configs. cscli hub update [flags] Options \u00b6 -h, --help help for update Options inherited from parent commands \u00b6 -b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli hub - Manage Hub","title":"Cscli hub update"},{"location":"cscli/cscli_hub_update.html#cscli-hub-update","text":"Fetch available configs from hub","title":"cscli hub update"},{"location":"cscli/cscli_hub_update.html#synopsis","text":"Fetches the .index.json file from hub, containing the list of available configs. cscli hub update [flags]","title":"Synopsis"},{"location":"cscli/cscli_hub_update.html#options","text":"-h, --help help for update","title":"Options"},{"location":"cscli/cscli_hub_update.html#options-inherited-from-parent-commands","text":"-b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_hub_update.html#see-also","text":"cscli hub - Manage Hub","title":"SEE ALSO"},{"location":"cscli/cscli_hub_upgrade.html","text":"cscli hub upgrade \u00b6 Upgrade all configs installed from hub Synopsis \u00b6 Upgrade all configs installed from Crowdsec Hub. Run 'sudo cscli hub update' if you want the latest versions available. cscli hub upgrade [flags] Options \u00b6 --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade Options inherited from parent commands \u00b6 -b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli hub - Manage Hub","title":"Cscli hub upgrade"},{"location":"cscli/cscli_hub_upgrade.html#cscli-hub-upgrade","text":"Upgrade all configs installed from hub","title":"cscli hub upgrade"},{"location":"cscli/cscli_hub_upgrade.html#synopsis","text":"Upgrade all configs installed from Crowdsec Hub. Run 'sudo cscli hub update' if you want the latest versions available. cscli hub upgrade [flags]","title":"Synopsis"},{"location":"cscli/cscli_hub_upgrade.html#options","text":"--force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade","title":"Options"},{"location":"cscli/cscli_hub_upgrade.html#options-inherited-from-parent-commands","text":"-b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_hub_upgrade.html#see-also","text":"cscli hub - Manage Hub","title":"SEE ALSO"},{"location":"cscli/cscli_lapi.html","text":"cscli lapi \u00b6 Manage interaction with Local API (LAPI) Options \u00b6 -h, --help help for lapi Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli lapi register - Register a machine to Local API (LAPI) cscli lapi status - Check authentication to Local API (LAPI)","title":"Cscli lapi"},{"location":"cscli/cscli_lapi.html#cscli-lapi","text":"Manage interaction with Local API (LAPI)","title":"cscli lapi"},{"location":"cscli/cscli_lapi.html#options","text":"-h, --help help for lapi","title":"Options"},{"location":"cscli/cscli_lapi.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_lapi.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli lapi register - Register a machine to Local API (LAPI) cscli lapi status - Check authentication to Local API (LAPI)","title":"SEE ALSO"},{"location":"cscli/cscli_lapi_register.html","text":"cscli lapi register \u00b6 Register a machine to Local API (LAPI) Synopsis \u00b6 Register you machine to the Local API (LAPI). Keep in mind the machine needs to be validated by an administrator on LAPI side to be effective. cscli lapi register [flags] Options \u00b6 -f, --file string output file destination -h, --help help for register --machine string Name of the machine to register with -u, --url string URL of the API (ie. http://127.0.0.1) Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli lapi - Manage interaction with Local API (LAPI)","title":"Cscli lapi register"},{"location":"cscli/cscli_lapi_register.html#cscli-lapi-register","text":"Register a machine to Local API (LAPI)","title":"cscli lapi register"},{"location":"cscli/cscli_lapi_register.html#synopsis","text":"Register you machine to the Local API (LAPI). Keep in mind the machine needs to be validated by an administrator on LAPI side to be effective. cscli lapi register [flags]","title":"Synopsis"},{"location":"cscli/cscli_lapi_register.html#options","text":"-f, --file string output file destination -h, --help help for register --machine string Name of the machine to register with -u, --url string URL of the API (ie. http://127.0.0.1)","title":"Options"},{"location":"cscli/cscli_lapi_register.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_lapi_register.html#see-also","text":"cscli lapi - Manage interaction with Local API (LAPI)","title":"SEE ALSO"},{"location":"cscli/cscli_lapi_status.html","text":"cscli lapi status \u00b6 Check authentication to Local API (LAPI) cscli lapi status [flags] Options \u00b6 -h, --help help for status Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli lapi - Manage interaction with Local API (LAPI)","title":"Cscli lapi status"},{"location":"cscli/cscli_lapi_status.html#cscli-lapi-status","text":"Check authentication to Local API (LAPI) cscli lapi status [flags]","title":"cscli lapi status"},{"location":"cscli/cscli_lapi_status.html#options","text":"-h, --help help for status","title":"Options"},{"location":"cscli/cscli_lapi_status.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_lapi_status.html#see-also","text":"cscli lapi - Manage interaction with Local API (LAPI)","title":"SEE ALSO"},{"location":"cscli/cscli_machines.html","text":"cscli machines \u00b6 Manage local API machines [requires local API] Synopsis \u00b6 To list/add/delete/validate machines. Note: This command requires database direct access, so is intended to be run on the local API machine. Examples \u00b6 cscli machines [action] Options \u00b6 -h, --help help for machines Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli machines add - add machine to the database. cscli machines delete - delete machines cscli machines list - List machines cscli machines validate - validate a machine to access the local API","title":"Machines"},{"location":"cscli/cscli_machines.html#cscli-machines","text":"Manage local API machines [requires local API]","title":"cscli machines"},{"location":"cscli/cscli_machines.html#synopsis","text":"To list/add/delete/validate machines. Note: This command requires database direct access, so is intended to be run on the local API machine.","title":"Synopsis"},{"location":"cscli/cscli_machines.html#examples","text":"cscli machines [action]","title":"Examples"},{"location":"cscli/cscli_machines.html#options","text":"-h, --help help for machines","title":"Options"},{"location":"cscli/cscli_machines.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_machines.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli machines add - add machine to the database. cscli machines delete - delete machines cscli machines list - List machines cscli machines validate - validate a machine to access the local API","title":"SEE ALSO"},{"location":"cscli/cscli_machines_add.html","text":"cscli machines add \u00b6 add machine to the database. Synopsis \u00b6 Register a new machine in the database. cscli should be on the same machine as LAPI. cscli machines add [flags] Examples \u00b6 cscli machines add --auto cscli machines add MyTestMachine --auto cscli machines add MyTestMachine --password MyPassword Options \u00b6 -a, --auto automatically generate password (and username if not provided) -f, --file string output file destination (defaults to /etc/crowdsec/local_api_credentials.yaml) --force will force add the machine if it already exist -h, --help help for add -i, --interactive interfactive mode to enter the password -p, --password string machine password to login to the API -u, --url string URL of the local API Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli machines - Manage local API machines [requires local API]","title":"Cscli machines add"},{"location":"cscli/cscli_machines_add.html#cscli-machines-add","text":"add machine to the database.","title":"cscli machines add"},{"location":"cscli/cscli_machines_add.html#synopsis","text":"Register a new machine in the database. cscli should be on the same machine as LAPI. cscli machines add [flags]","title":"Synopsis"},{"location":"cscli/cscli_machines_add.html#examples","text":"cscli machines add --auto cscli machines add MyTestMachine --auto cscli machines add MyTestMachine --password MyPassword","title":"Examples"},{"location":"cscli/cscli_machines_add.html#options","text":"-a, --auto automatically generate password (and username if not provided) -f, --file string output file destination (defaults to /etc/crowdsec/local_api_credentials.yaml) --force will force add the machine if it already exist -h, --help help for add -i, --interactive interfactive mode to enter the password -p, --password string machine password to login to the API -u, --url string URL of the local API","title":"Options"},{"location":"cscli/cscli_machines_add.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_machines_add.html#see-also","text":"cscli machines - Manage local API machines [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_machines_delete.html","text":"cscli machines delete \u00b6 delete machines cscli machines delete --machine MyTestMachine [flags] Examples \u00b6 cscli machines delete <machine_name> Options \u00b6 -h, --help help for delete -m, --machine string machine to delete Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli machines - Manage local API machines [requires local API]","title":"Cscli machines delete"},{"location":"cscli/cscli_machines_delete.html#cscli-machines-delete","text":"delete machines cscli machines delete --machine MyTestMachine [flags]","title":"cscli machines delete"},{"location":"cscli/cscli_machines_delete.html#examples","text":"cscli machines delete <machine_name>","title":"Examples"},{"location":"cscli/cscli_machines_delete.html#options","text":"-h, --help help for delete -m, --machine string machine to delete","title":"Options"},{"location":"cscli/cscli_machines_delete.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_machines_delete.html#see-also","text":"cscli machines - Manage local API machines [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_machines_list.html","text":"cscli machines list \u00b6 List machines Synopsis \u00b6 List cscli machines list [flags] Examples \u00b6 cscli machines list Options \u00b6 -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli machines - Manage local API machines [requires local API]","title":"Cscli machines list"},{"location":"cscli/cscli_machines_list.html#cscli-machines-list","text":"List machines","title":"cscli machines list"},{"location":"cscli/cscli_machines_list.html#synopsis","text":"List cscli machines list [flags]","title":"Synopsis"},{"location":"cscli/cscli_machines_list.html#examples","text":"cscli machines list","title":"Examples"},{"location":"cscli/cscli_machines_list.html#options","text":"-h, --help help for list","title":"Options"},{"location":"cscli/cscli_machines_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_machines_list.html#see-also","text":"cscli machines - Manage local API machines [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_machines_register.html","text":"cscli machines register \u00b6 register a machine to a remote API Synopsis \u00b6 register a machine to a remote API. /!\\ The machine will not be validated. You have to connect on the remote API server and run 'cscli machine validate -m ' cscli machines register -u http://127.0.0.1:8080/ [flags] Examples \u00b6 cscli machine register Options \u00b6 -f, --file string output file destination -h, --help help for register -u, --url string URL of the API Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli machines - Manage local API machines","title":"Cscli machines register"},{"location":"cscli/cscli_machines_register.html#cscli-machines-register","text":"register a machine to a remote API","title":"cscli machines register"},{"location":"cscli/cscli_machines_register.html#synopsis","text":"register a machine to a remote API. /!\\ The machine will not be validated. You have to connect on the remote API server and run 'cscli machine validate -m ' cscli machines register -u http://127.0.0.1:8080/ [flags]","title":"Synopsis"},{"location":"cscli/cscli_machines_register.html#examples","text":"cscli machine register","title":"Examples"},{"location":"cscli/cscli_machines_register.html#options","text":"-f, --file string output file destination -h, --help help for register -u, --url string URL of the API","title":"Options"},{"location":"cscli/cscli_machines_register.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_machines_register.html#see-also","text":"cscli machines - Manage local API machines","title":"SEE ALSO"},{"location":"cscli/cscli_machines_validate.html","text":"cscli machines validate \u00b6 validate a machine to access the local API Synopsis \u00b6 validate a machine to access the local API. cscli machines validate [flags] Examples \u00b6 cscli machines validate <machine_name> Options \u00b6 -h, --help help for validate Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli machines - Manage local API machines [requires local API]","title":"Cscli machines validate"},{"location":"cscli/cscli_machines_validate.html#cscli-machines-validate","text":"validate a machine to access the local API","title":"cscli machines validate"},{"location":"cscli/cscli_machines_validate.html#synopsis","text":"validate a machine to access the local API. cscli machines validate [flags]","title":"Synopsis"},{"location":"cscli/cscli_machines_validate.html#examples","text":"cscli machines validate <machine_name>","title":"Examples"},{"location":"cscli/cscli_machines_validate.html#options","text":"-h, --help help for validate","title":"Options"},{"location":"cscli/cscli_machines_validate.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_machines_validate.html#see-also","text":"cscli machines - Manage local API machines [requires local API]","title":"SEE ALSO"},{"location":"cscli/cscli_metrics.html","text":"cscli metrics \u00b6 Display crowdsec prometheus metrics. Synopsis \u00b6 Fetch metrics from the prometheus server and display them in a human-friendly way cscli metrics [flags] Options \u00b6 -h, --help help for metrics -u, --url string Prometheus url (http://<ip>:<port>/metrics) Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec","title":"Metrics"},{"location":"cscli/cscli_metrics.html#cscli-metrics","text":"Display crowdsec prometheus metrics.","title":"cscli metrics"},{"location":"cscli/cscli_metrics.html#synopsis","text":"Fetch metrics from the prometheus server and display them in a human-friendly way cscli metrics [flags]","title":"Synopsis"},{"location":"cscli/cscli_metrics.html#options","text":"-h, --help help for metrics -u, --url string Prometheus url (http://<ip>:<port>/metrics)","title":"Options"},{"location":"cscli/cscli_metrics.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_metrics.html#see-also","text":"cscli - cscli allows you to manage crowdsec","title":"SEE ALSO"},{"location":"cscli/cscli_parsers.html","text":"cscli parsers \u00b6 Install/Remove/Upgrade/Inspect parser(s) from hub Examples \u00b6 cscli parsers install crowdsecurity/sshd-logs cscli parsers inspect crowdsecurity/sshd-logs cscli parsers upgrade crowdsecurity/sshd-logs cscli parsers list cscli parsers remove crowdsecurity/sshd-logs Options \u00b6 -h, --help help for parsers Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli parsers inspect - Inspect given parser cscli parsers install - Install given parser(s) cscli parsers list - List all parsers or given one cscli parsers remove - Remove given parser(s) cscli parsers upgrade - Upgrade given parser(s)","title":"Parsers"},{"location":"cscli/cscli_parsers.html#cscli-parsers","text":"Install/Remove/Upgrade/Inspect parser(s) from hub","title":"cscli parsers"},{"location":"cscli/cscli_parsers.html#examples","text":"cscli parsers install crowdsecurity/sshd-logs cscli parsers inspect crowdsecurity/sshd-logs cscli parsers upgrade crowdsecurity/sshd-logs cscli parsers list cscli parsers remove crowdsecurity/sshd-logs","title":"Examples"},{"location":"cscli/cscli_parsers.html#options","text":"-h, --help help for parsers","title":"Options"},{"location":"cscli/cscli_parsers.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_parsers.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli parsers inspect - Inspect given parser cscli parsers install - Install given parser(s) cscli parsers list - List all parsers or given one cscli parsers remove - Remove given parser(s) cscli parsers upgrade - Upgrade given parser(s)","title":"SEE ALSO"},{"location":"cscli/cscli_parsers_inspect.html","text":"cscli parsers inspect \u00b6 Inspect given parser Synopsis \u00b6 Inspect given parser cscli parsers inspect [name] [flags] Examples \u00b6 cscli parsers inspect crowdsec/xxx Options \u00b6 -h, --help help for inspect -u, --url string Prometheus url Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"Cscli parsers inspect"},{"location":"cscli/cscli_parsers_inspect.html#cscli-parsers-inspect","text":"Inspect given parser","title":"cscli parsers inspect"},{"location":"cscli/cscli_parsers_inspect.html#synopsis","text":"Inspect given parser cscli parsers inspect [name] [flags]","title":"Synopsis"},{"location":"cscli/cscli_parsers_inspect.html#examples","text":"cscli parsers inspect crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_parsers_inspect.html#options","text":"-h, --help help for inspect -u, --url string Prometheus url","title":"Options"},{"location":"cscli/cscli_parsers_inspect.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_parsers_inspect.html#see-also","text":"cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_parsers_install.html","text":"cscli parsers install \u00b6 Install given parser(s) Synopsis \u00b6 Fetch and install given parser(s) from hub cscli parsers install [config] [flags] Examples \u00b6 cscli parsers install crowdsec/xxx crowdsec/xyz Options \u00b6 -d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"Cscli parsers install"},{"location":"cscli/cscli_parsers_install.html#cscli-parsers-install","text":"Install given parser(s)","title":"cscli parsers install"},{"location":"cscli/cscli_parsers_install.html#synopsis","text":"Fetch and install given parser(s) from hub cscli parsers install [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_parsers_install.html#examples","text":"cscli parsers install crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_parsers_install.html#options","text":"-d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install","title":"Options"},{"location":"cscli/cscli_parsers_install.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_parsers_install.html#see-also","text":"cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_parsers_list.html","text":"cscli parsers list \u00b6 List all parsers or given one Synopsis \u00b6 List all parsers or given one cscli parsers list [name] [flags] Examples \u00b6 cscli parsers list cscli parser list crowdsecurity/xxx Options \u00b6 -a, --all List as well disabled items -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"Cscli parsers list"},{"location":"cscli/cscli_parsers_list.html#cscli-parsers-list","text":"List all parsers or given one","title":"cscli parsers list"},{"location":"cscli/cscli_parsers_list.html#synopsis","text":"List all parsers or given one cscli parsers list [name] [flags]","title":"Synopsis"},{"location":"cscli/cscli_parsers_list.html#examples","text":"cscli parsers list cscli parser list crowdsecurity/xxx","title":"Examples"},{"location":"cscli/cscli_parsers_list.html#options","text":"-a, --all List as well disabled items -h, --help help for list","title":"Options"},{"location":"cscli/cscli_parsers_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_parsers_list.html#see-also","text":"cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_parsers_remove.html","text":"cscli parsers remove \u00b6 Remove given parser(s) Synopsis \u00b6 Remove given parse(s) from hub cscli parsers remove [config] [flags] Examples \u00b6 cscli parsers remove crowdsec/xxx crowdsec/xyz Options \u00b6 --all Delete all the parsers --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"Cscli parsers remove"},{"location":"cscli/cscli_parsers_remove.html#cscli-parsers-remove","text":"Remove given parser(s)","title":"cscli parsers remove"},{"location":"cscli/cscli_parsers_remove.html#synopsis","text":"Remove given parse(s) from hub cscli parsers remove [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_parsers_remove.html#examples","text":"cscli parsers remove crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_parsers_remove.html#options","text":"--all Delete all the parsers --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too","title":"Options"},{"location":"cscli/cscli_parsers_remove.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_parsers_remove.html#see-also","text":"cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_parsers_upgrade.html","text":"cscli parsers upgrade \u00b6 Upgrade given parser(s) Synopsis \u00b6 Fetch and upgrade given parser(s) from hub cscli parsers upgrade [config] [flags] Examples \u00b6 cscli parsers upgrade crowdsec/xxx crowdsec/xyz Options \u00b6 --all Upgrade all the parsers --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"Cscli parsers upgrade"},{"location":"cscli/cscli_parsers_upgrade.html#cscli-parsers-upgrade","text":"Upgrade given parser(s)","title":"cscli parsers upgrade"},{"location":"cscli/cscli_parsers_upgrade.html#synopsis","text":"Fetch and upgrade given parser(s) from hub cscli parsers upgrade [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_parsers_upgrade.html#examples","text":"cscli parsers upgrade crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_parsers_upgrade.html#options","text":"--all Upgrade all the parsers --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade","title":"Options"},{"location":"cscli/cscli_parsers_upgrade.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_parsers_upgrade.html#see-also","text":"cscli parsers - Install/Remove/Upgrade/Inspect parser(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows.html","text":"cscli postoverflows \u00b6 Install/Remove/Upgrade/Inspect postoverflow(s) from hub Examples \u00b6 cscli postoverflows install crowdsecurity/cdn-whitelist cscli postoverflows inspect crowdsecurity/cdn-whitelist cscli postoverflows upgrade crowdsecurity/cdn-whitelist cscli postoverflows list cscli postoverflows remove crowdsecurity/cdn-whitelist Options \u00b6 -h, --help help for postoverflows Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli postoverflows inspect - Inspect given postoverflow cscli postoverflows install - Install given postoverflow(s) cscli postoverflows list - List all postoverflows or given one cscli postoverflows remove - Remove given postoverflow(s) cscli postoverflows upgrade - Upgrade given postoverflow(s)","title":"Postoverflows"},{"location":"cscli/cscli_postoverflows.html#cscli-postoverflows","text":"Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"cscli postoverflows"},{"location":"cscli/cscli_postoverflows.html#examples","text":"cscli postoverflows install crowdsecurity/cdn-whitelist cscli postoverflows inspect crowdsecurity/cdn-whitelist cscli postoverflows upgrade crowdsecurity/cdn-whitelist cscli postoverflows list cscli postoverflows remove crowdsecurity/cdn-whitelist","title":"Examples"},{"location":"cscli/cscli_postoverflows.html#options","text":"-h, --help help for postoverflows","title":"Options"},{"location":"cscli/cscli_postoverflows.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli postoverflows inspect - Inspect given postoverflow cscli postoverflows install - Install given postoverflow(s) cscli postoverflows list - List all postoverflows or given one cscli postoverflows remove - Remove given postoverflow(s) cscli postoverflows upgrade - Upgrade given postoverflow(s)","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows_inspect.html","text":"cscli postoverflows inspect \u00b6 Inspect given postoverflow Synopsis \u00b6 Inspect given postoverflow cscli postoverflows inspect [config] [flags] Examples \u00b6 cscli postoverflows inspect crowdsec/xxx crowdsec/xyz Options \u00b6 -h, --help help for inspect Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"Cscli postoverflows inspect"},{"location":"cscli/cscli_postoverflows_inspect.html#cscli-postoverflows-inspect","text":"Inspect given postoverflow","title":"cscli postoverflows inspect"},{"location":"cscli/cscli_postoverflows_inspect.html#synopsis","text":"Inspect given postoverflow cscli postoverflows inspect [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_postoverflows_inspect.html#examples","text":"cscli postoverflows inspect crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_postoverflows_inspect.html#options","text":"-h, --help help for inspect","title":"Options"},{"location":"cscli/cscli_postoverflows_inspect.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows_inspect.html#see-also","text":"cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows_install.html","text":"cscli postoverflows install \u00b6 Install given postoverflow(s) Synopsis \u00b6 Fetch and install given postoverflow(s) from hub cscli postoverflows install [config] [flags] Examples \u00b6 cscli postoverflows install crowdsec/xxx crowdsec/xyz Options \u00b6 -d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"Cscli postoverflows install"},{"location":"cscli/cscli_postoverflows_install.html#cscli-postoverflows-install","text":"Install given postoverflow(s)","title":"cscli postoverflows install"},{"location":"cscli/cscli_postoverflows_install.html#synopsis","text":"Fetch and install given postoverflow(s) from hub cscli postoverflows install [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_postoverflows_install.html#examples","text":"cscli postoverflows install crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_postoverflows_install.html#options","text":"-d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install","title":"Options"},{"location":"cscli/cscli_postoverflows_install.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows_install.html#see-also","text":"cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows_list.html","text":"cscli postoverflows list \u00b6 List all postoverflows or given one Synopsis \u00b6 List all postoverflows or given one cscli postoverflows list [config] [flags] Examples \u00b6 cscli postoverflows list cscli postoverflows list crowdsecurity/xxx Options \u00b6 -a, --all List as well disabled items -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"Cscli postoverflows list"},{"location":"cscli/cscli_postoverflows_list.html#cscli-postoverflows-list","text":"List all postoverflows or given one","title":"cscli postoverflows list"},{"location":"cscli/cscli_postoverflows_list.html#synopsis","text":"List all postoverflows or given one cscli postoverflows list [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_postoverflows_list.html#examples","text":"cscli postoverflows list cscli postoverflows list crowdsecurity/xxx","title":"Examples"},{"location":"cscli/cscli_postoverflows_list.html#options","text":"-a, --all List as well disabled items -h, --help help for list","title":"Options"},{"location":"cscli/cscli_postoverflows_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows_list.html#see-also","text":"cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows_postoverflows.html","text":"cscli postoverflows postoverflows \u00b6 Install given postoverflow(s) Synopsis \u00b6 Fetch and install given postoverflow(s) from hub cscli postoverflows postoverflows [config] [flags] Examples \u00b6 cscli postoverflows install crowdsec/xxx crowdsec/xyz Options \u00b6 -d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for postoverflows Options inherited from parent commands \u00b6 -b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"Cscli postoverflows postoverflows"},{"location":"cscli/cscli_postoverflows_postoverflows.html#cscli-postoverflows-postoverflows","text":"Install given postoverflow(s)","title":"cscli postoverflows postoverflows"},{"location":"cscli/cscli_postoverflows_postoverflows.html#synopsis","text":"Fetch and install given postoverflow(s) from hub cscli postoverflows postoverflows [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_postoverflows_postoverflows.html#examples","text":"cscli postoverflows install crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_postoverflows_postoverflows.html#options","text":"-d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for postoverflows","title":"Options"},{"location":"cscli/cscli_postoverflows_postoverflows.html#options-inherited-from-parent-commands","text":"-b, --branch string Use given branch from hub -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows_postoverflows.html#see-also","text":"cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows_remove.html","text":"cscli postoverflows remove \u00b6 Remove given postoverflow(s) Synopsis \u00b6 remove given postoverflow(s) cscli postoverflows remove [config] [flags] Examples \u00b6 cscli postoverflows remove crowdsec/xxx crowdsec/xyz Options \u00b6 --all Delete all the postoverflows --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"Cscli postoverflows remove"},{"location":"cscli/cscli_postoverflows_remove.html#cscli-postoverflows-remove","text":"Remove given postoverflow(s)","title":"cscli postoverflows remove"},{"location":"cscli/cscli_postoverflows_remove.html#synopsis","text":"remove given postoverflow(s) cscli postoverflows remove [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_postoverflows_remove.html#examples","text":"cscli postoverflows remove crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_postoverflows_remove.html#options","text":"--all Delete all the postoverflows --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too","title":"Options"},{"location":"cscli/cscli_postoverflows_remove.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows_remove.html#see-also","text":"cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_postoverflows_upgrade.html","text":"cscli postoverflows upgrade \u00b6 Upgrade given postoverflow(s) Synopsis \u00b6 Fetch and Upgrade given postoverflow(s) from hub cscli postoverflows upgrade [config] [flags] Examples \u00b6 cscli postoverflows upgrade crowdsec/xxx crowdsec/xyz Options \u00b6 -a, --all Upgrade all the postoverflows --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"Cscli postoverflows upgrade"},{"location":"cscli/cscli_postoverflows_upgrade.html#cscli-postoverflows-upgrade","text":"Upgrade given postoverflow(s)","title":"cscli postoverflows upgrade"},{"location":"cscli/cscli_postoverflows_upgrade.html#synopsis","text":"Fetch and Upgrade given postoverflow(s) from hub cscli postoverflows upgrade [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_postoverflows_upgrade.html#examples","text":"cscli postoverflows upgrade crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_postoverflows_upgrade.html#options","text":"-a, --all Upgrade all the postoverflows --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade","title":"Options"},{"location":"cscli/cscli_postoverflows_upgrade.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_postoverflows_upgrade.html#see-also","text":"cscli postoverflows - Install/Remove/Upgrade/Inspect postoverflow(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_scenarios.html","text":"cscli scenarios \u00b6 Install/Remove/Upgrade/Inspect scenario(s) from hub Examples \u00b6 cscli scenarios list [-a] cscli scenarios install crowdsecurity/ssh-bf cscli scenarios inspect crowdsecurity/ssh-bf cscli scenarios upgrade crowdsecurity/ssh-bf cscli scenarios remove crowdsecurity/ssh-bf Options \u00b6 -h, --help help for scenarios Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli scenarios inspect - Inspect given scenario cscli scenarios install - Install given scenario(s) cscli scenarios list - List all scenario(s) or given one cscli scenarios remove - Remove given scenario(s) cscli scenarios upgrade - Upgrade given scenario(s)","title":"Scenarios"},{"location":"cscli/cscli_scenarios.html#cscli-scenarios","text":"Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"cscli scenarios"},{"location":"cscli/cscli_scenarios.html#examples","text":"cscli scenarios list [-a] cscli scenarios install crowdsecurity/ssh-bf cscli scenarios inspect crowdsecurity/ssh-bf cscli scenarios upgrade crowdsecurity/ssh-bf cscli scenarios remove crowdsecurity/ssh-bf","title":"Examples"},{"location":"cscli/cscli_scenarios.html#options","text":"-h, --help help for scenarios","title":"Options"},{"location":"cscli/cscli_scenarios.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_scenarios.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli scenarios inspect - Inspect given scenario cscli scenarios install - Install given scenario(s) cscli scenarios list - List all scenario(s) or given one cscli scenarios remove - Remove given scenario(s) cscli scenarios upgrade - Upgrade given scenario(s)","title":"SEE ALSO"},{"location":"cscli/cscli_scenarios_inspect.html","text":"cscli scenarios inspect \u00b6 Inspect given scenario Synopsis \u00b6 Inspect given scenario cscli scenarios inspect [config] [flags] Examples \u00b6 cscli scenarios inspect crowdsec/xxx Options \u00b6 -h, --help help for inspect -u, --url string Prometheus url Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"Cscli scenarios inspect"},{"location":"cscli/cscli_scenarios_inspect.html#cscli-scenarios-inspect","text":"Inspect given scenario","title":"cscli scenarios inspect"},{"location":"cscli/cscli_scenarios_inspect.html#synopsis","text":"Inspect given scenario cscli scenarios inspect [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_scenarios_inspect.html#examples","text":"cscli scenarios inspect crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_scenarios_inspect.html#options","text":"-h, --help help for inspect -u, --url string Prometheus url","title":"Options"},{"location":"cscli/cscli_scenarios_inspect.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_scenarios_inspect.html#see-also","text":"cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_scenarios_install.html","text":"cscli scenarios install \u00b6 Install given scenario(s) Synopsis \u00b6 Fetch and install given scenario(s) from hub cscli scenarios install [config] [flags] Examples \u00b6 cscli scenarios install crowdsec/xxx crowdsec/xyz Options \u00b6 -d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"Cscli scenarios install"},{"location":"cscli/cscli_scenarios_install.html#cscli-scenarios-install","text":"Install given scenario(s)","title":"cscli scenarios install"},{"location":"cscli/cscli_scenarios_install.html#synopsis","text":"Fetch and install given scenario(s) from hub cscli scenarios install [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_scenarios_install.html#examples","text":"cscli scenarios install crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_scenarios_install.html#options","text":"-d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install","title":"Options"},{"location":"cscli/cscli_scenarios_install.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_scenarios_install.html#see-also","text":"cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_scenarios_list.html","text":"cscli scenarios list \u00b6 List all scenario(s) or given one Synopsis \u00b6 List all scenario(s) or given one cscli scenarios list [config] [flags] Examples \u00b6 cscli scenarios list cscli scenarios list crowdsecurity/xxx Options \u00b6 -a, --all List as well disabled items -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"Cscli scenarios list"},{"location":"cscli/cscli_scenarios_list.html#cscli-scenarios-list","text":"List all scenario(s) or given one","title":"cscli scenarios list"},{"location":"cscli/cscli_scenarios_list.html#synopsis","text":"List all scenario(s) or given one cscli scenarios list [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_scenarios_list.html#examples","text":"cscli scenarios list cscli scenarios list crowdsecurity/xxx","title":"Examples"},{"location":"cscli/cscli_scenarios_list.html#options","text":"-a, --all List as well disabled items -h, --help help for list","title":"Options"},{"location":"cscli/cscli_scenarios_list.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_scenarios_list.html#see-also","text":"cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_scenarios_remove.html","text":"cscli scenarios remove \u00b6 Remove given scenario(s) Synopsis \u00b6 remove given scenario(s) cscli scenarios remove [config] [flags] Examples \u00b6 cscli scenarios remove crowdsec/xxx crowdsec/xyz Options \u00b6 --all Delete all the scenarios --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"Cscli scenarios remove"},{"location":"cscli/cscli_scenarios_remove.html#cscli-scenarios-remove","text":"Remove given scenario(s)","title":"cscli scenarios remove"},{"location":"cscli/cscli_scenarios_remove.html#synopsis","text":"remove given scenario(s) cscli scenarios remove [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_scenarios_remove.html#examples","text":"cscli scenarios remove crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_scenarios_remove.html#options","text":"--all Delete all the scenarios --force Force remove : Remove tainted and outdated files -h, --help help for remove --purge Delete source file too","title":"Options"},{"location":"cscli/cscli_scenarios_remove.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_scenarios_remove.html#see-also","text":"cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_scenarios_upgrade.html","text":"cscli scenarios upgrade \u00b6 Upgrade given scenario(s) Synopsis \u00b6 Fetch and Upgrade given scenario(s) from hub cscli scenarios upgrade [config] [flags] Examples \u00b6 cscli scenarios upgrade crowdsec/xxx crowdsec/xyz Options \u00b6 -a, --all Upgrade all the scenarios --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"Cscli scenarios upgrade"},{"location":"cscli/cscli_scenarios_upgrade.html#cscli-scenarios-upgrade","text":"Upgrade given scenario(s)","title":"cscli scenarios upgrade"},{"location":"cscli/cscli_scenarios_upgrade.html#synopsis","text":"Fetch and Upgrade given scenario(s) from hub cscli scenarios upgrade [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_scenarios_upgrade.html#examples","text":"cscli scenarios upgrade crowdsec/xxx crowdsec/xyz","title":"Examples"},{"location":"cscli/cscli_scenarios_upgrade.html#options","text":"-a, --all Upgrade all the scenarios --force Force upgrade : Overwrite tainted and outdated files -h, --help help for upgrade","title":"Options"},{"location":"cscli/cscli_scenarios_upgrade.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_scenarios_upgrade.html#see-also","text":"cscli scenarios - Install/Remove/Upgrade/Inspect scenario(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_simulation.html","text":"cscli simulation \u00b6 Manage simulation status of scenarios Examples \u00b6 cscli simulation status cscli simulation enable crowdsecurity/ssh-bf cscli simulation disable crowdsecurity/ssh-bf Options \u00b6 -h, --help help for simulation Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli simulation disable - Disable the simulation mode. Disable only specified scenarios cscli simulation enable - Enable the simulation, globally or on specified scenarios cscli simulation status - Show simulation mode status","title":"Simulation"},{"location":"cscli/cscli_simulation.html#cscli-simulation","text":"Manage simulation status of scenarios","title":"cscli simulation"},{"location":"cscli/cscli_simulation.html#examples","text":"cscli simulation status cscli simulation enable crowdsecurity/ssh-bf cscli simulation disable crowdsecurity/ssh-bf","title":"Examples"},{"location":"cscli/cscli_simulation.html#options","text":"-h, --help help for simulation","title":"Options"},{"location":"cscli/cscli_simulation.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation.html#see-also","text":"cscli - cscli allows you to manage crowdsec cscli simulation disable - Disable the simulation mode. Disable only specified scenarios cscli simulation enable - Enable the simulation, globally or on specified scenarios cscli simulation status - Show simulation mode status","title":"SEE ALSO"},{"location":"cscli/cscli_simulation_disable.html","text":"cscli simulation disable \u00b6 Disable the simulation mode. Disable only specified scenarios cscli simulation disable [scenario] [flags] Examples \u00b6 cscli simulation disable Options \u00b6 -g, --global Disable global simulation (reverse mode) -h, --help help for disable Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli simulation - Manage simulation status of scenarios","title":"Cscli simulation disable"},{"location":"cscli/cscli_simulation_disable.html#cscli-simulation-disable","text":"Disable the simulation mode. Disable only specified scenarios cscli simulation disable [scenario] [flags]","title":"cscli simulation disable"},{"location":"cscli/cscli_simulation_disable.html#examples","text":"cscli simulation disable","title":"Examples"},{"location":"cscli/cscli_simulation_disable.html#options","text":"-g, --global Disable global simulation (reverse mode) -h, --help help for disable","title":"Options"},{"location":"cscli/cscli_simulation_disable.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation_disable.html#see-also","text":"cscli simulation - Manage simulation status of scenarios","title":"SEE ALSO"},{"location":"cscli/cscli_simulation_enable.html","text":"cscli simulation enable \u00b6 Enable the simulation, globally or on specified scenarios cscli simulation enable [scenario] [-global] [flags] Examples \u00b6 cscli simulation enable Options \u00b6 -g, --global Enable global simulation (reverse mode) -h, --help help for enable Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli simulation - Manage simulation status of scenarios","title":"Cscli simulation enable"},{"location":"cscli/cscli_simulation_enable.html#cscli-simulation-enable","text":"Enable the simulation, globally or on specified scenarios cscli simulation enable [scenario] [-global] [flags]","title":"cscli simulation enable"},{"location":"cscli/cscli_simulation_enable.html#examples","text":"cscli simulation enable","title":"Examples"},{"location":"cscli/cscli_simulation_enable.html#options","text":"-g, --global Enable global simulation (reverse mode) -h, --help help for enable","title":"Options"},{"location":"cscli/cscli_simulation_enable.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation_enable.html#see-also","text":"cscli simulation - Manage simulation status of scenarios","title":"SEE ALSO"},{"location":"cscli/cscli_simulation_status.html","text":"cscli simulation status \u00b6 Show simulation mode status cscli simulation status [flags] Examples \u00b6 cscli simulation status Options \u00b6 -h, --help help for status Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli simulation - Manage simulation status of scenarios","title":"Cscli simulation status"},{"location":"cscli/cscli_simulation_status.html#cscli-simulation-status","text":"Show simulation mode status cscli simulation status [flags]","title":"cscli simulation status"},{"location":"cscli/cscli_simulation_status.html#examples","text":"cscli simulation status","title":"Examples"},{"location":"cscli/cscli_simulation_status.html#options","text":"-h, --help help for status","title":"Options"},{"location":"cscli/cscli_simulation_status.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation_status.html#see-also","text":"cscli simulation - Manage simulation status of scenarios","title":"SEE ALSO"},{"location":"cscli/cscli_version.html","text":"cscli version \u00b6 Display version and exit. cscli version [flags] Options \u00b6 -h, --help help for version Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec","title":"Cscli version"},{"location":"cscli/cscli_version.html#cscli-version","text":"Display version and exit. cscli version [flags]","title":"cscli version"},{"location":"cscli/cscli_version.html#options","text":"-h, --help help for version","title":"Options"},{"location":"cscli/cscli_version.html#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. --trace Set logging to trace. --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_version.html#see-also","text":"cscli - cscli allows you to manage crowdsec","title":"SEE ALSO"},{"location":"getting_started/concepts.html","text":"Global overview \u00b6 Crowdsec-agent runtime revolves around a few simple concepts : It read logs (defined via acquisition config) Those logs are parsed via parsers and eventually enriched Those normalized logs are then matched against the scenarios that the user deployed When a scenario is \"triggered\", Crowdsec-agent generates an Alert and eventually one or more associated Decision : The alert is here mostly for tracability, and will stay even after the decision expires The decision on the other hand, is short lived, and tells what action should be taken against the offending ip/range/user... Those information (the signal, the associated decisions) are then sent to crowdsec's local API and stored in the database As you might have guessed by now, Crowdsec-agent itself does the detection part and stores those decisions. Then, bouncers can \"consume\" those decisions (via the very same local API ) and apply some actual remediation. Crowd sourced aspect \u00b6 [ References ] Whenever the local API receives an alert with associated decisions, the meta information about the alert are shared with our central api : The source ip that triggered the alert The scenario that was triggered The timestamp of the attack These are the only information that are sent to our API. Those are then processed on our side to be able to redistribute relevant blocklists to all the participants. You can check the central API documentation in the references link to have an exhaustive view of what might be shared between your instance and our services. Bouncers \u00b6 [ References ] Bouncers are standalone software pieces in charge of acting upon IPs that triggered alerts. To do so, bouncers are going to query the local API to know if there is an existing decisions against a given IP, range, username etc. You can find a list of existing bouncers on the hub Configuration items \u00b6 Acquisition \u00b6 [ References ] Acquistion configuration defines which streams of information crowdsec-agent is going to process. At the time of writing, it's mostly files or journald, but it should be more or less any kind of stream, such as a kafka topic or a cloudtrail. Acquisition configuration always contains a stream (ie. a file to tail) and a tag (ie. \"these are in syslog format\" \"these are non-syslog nginx logs\"). File acquisition configuration is defined as : filenames : - /var/log/auth.log labels : type : syslog The labels part is here to tag the incoming logs with a type. labels.type are used by the parsers to know which logs to process. Stages \u00b6 [ References ] Stages concept is central to data parsing in crowdsec-agent, as it allows to have various \"steps\" of parsing. All parsers belong to a given stage. While users can add or modify the stages order, the following stages exist : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Thus a sshd log might follow this pipeline : s00-raw : be parsed by crowdsecurity/syslog-logs (will move event to the next stage) s01-raw : be parsed by crowdsecurity/sshd-logs (will move event to the next stage) s02-enrich : will be parsed by crowdsecurity/geoip-enrich and crowdsecurity/dateparse-enrich Parsers \u00b6 [ References ] For logs to be able to be exploited and analyzed, they need to be parsed and normalized, and this is where parsers are used. A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing. A parser usually has a specific scope. For example, if you are using nginx , you will probably want to use the crowdsecurity/nginx-logs which allows your crowdsec-agent setup to parse nginx's access and error logs. Parsers are organized into stages to allow pipelines and branching in parsing. See the Crowdsec Hub to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing You can as well write your own ! Enrichers \u00b6 [ References ] Enrichment is the action of adding extra context to an event based on the information we already have, so that better decision can later be taken. In most cases, you should be able to find the relevant enrichers on our Crowdsec Hub . A common/simple type of enrichment would be geoip-enrich of an event (adding information such as : origin country, origin AS and origin IP range to an event). Once again, you should be able to find the ones you're looking for on the Crowdsec Hub ! Scenarios \u00b6 [ References ] Scenarios is the expression of a heuristic that allows you to qualify a specific event (usually an attack).It is a YAML file that describes a set of events characterizing a scenario. Scenarios in crowdsec-agent gravitate around the leaky bucket principle. A scenario description includes at least : Event eligibility rules. (For example if we're writing a ssh bruteforce detection we only focus on logs of type ssh_failed_auth ) Bucket configuration such as the leak speed or its capacity (in our same ssh bruteforce example, we might allow 1 failed auth per 10s and no more than 5 in a short amount of time: leakspeed: 10s capacity: 5 ) Aggregation rules : per source ip or per other criterias (in our ssh bruteforce example, we will group per source ip) The description allows for many other rules to be specified (blackhole, distinct filters etc.), to allow rather complex scenarios. See the Crowdsec Hub to explore scenarios and their capabilities, or see below some examples : ssh bruteforce detection distinct http-404 scan iptables port scan You can as well write your own ! Collections \u00b6 [ References ] To make user's life easier, \"collections\" are available, which are just a bundle of parsers and scenarios. In this way, if you want to cover basic use-cases of let's say \"nginx\", you can just install the crowdsecurity/nginx collection that is composed of crowdsecurity/nginx-logs parser, as well as generic http scenarios such as crowdsecurity/base-http-scenarios . As usual, those can be found on the Crowdsec Hub ! PostOverflows \u00b6 [ References ] A postoverflow is a parser that will be applied on overflows (scenario results) before the decision is written to local DB or pushed to API. Parsers in postoverflows are meant to be used for \"expensive\" enrichment/parsing process that you do not want to perform on all incoming events, but rather on decision that are about to be taken. An example could be slack/mattermost enrichment plugin that requires human confirmation before applying the decision or reverse-dns lookup operations. Runtime items \u00b6 Events \u00b6 [ References ] An Event is the runtime representation of an item being processed by crowdsec : It be a Log line being parsed, or an Overflow being reprocessed. The Event object is modified by parses, scenarios, and directly via user statics expressions (for example). Alerts \u00b6 [ References ] An Alert is the runtime representation of a bucket overflow being processed by crowdsec : It is embedded in an Event. The Alert object is modified by post-overflows and profiles . Decisions \u00b6 [ References ] A Decision is the representation of the consequence of a bucket overflow : a decision against an IP, a range, an AS, a Country, a User, a Session etc. Decisions are generated by Local API (LAPI) when an Alert is received, according to the existing profiles","title":"Concepts"},{"location":"getting_started/concepts.html#global-overview","text":"Crowdsec-agent runtime revolves around a few simple concepts : It read logs (defined via acquisition config) Those logs are parsed via parsers and eventually enriched Those normalized logs are then matched against the scenarios that the user deployed When a scenario is \"triggered\", Crowdsec-agent generates an Alert and eventually one or more associated Decision : The alert is here mostly for tracability, and will stay even after the decision expires The decision on the other hand, is short lived, and tells what action should be taken against the offending ip/range/user... Those information (the signal, the associated decisions) are then sent to crowdsec's local API and stored in the database As you might have guessed by now, Crowdsec-agent itself does the detection part and stores those decisions. Then, bouncers can \"consume\" those decisions (via the very same local API ) and apply some actual remediation.","title":"Global overview"},{"location":"getting_started/concepts.html#crowd-sourced-aspect","text":"[ References ] Whenever the local API receives an alert with associated decisions, the meta information about the alert are shared with our central api : The source ip that triggered the alert The scenario that was triggered The timestamp of the attack These are the only information that are sent to our API. Those are then processed on our side to be able to redistribute relevant blocklists to all the participants. You can check the central API documentation in the references link to have an exhaustive view of what might be shared between your instance and our services.","title":"Crowd sourced aspect"},{"location":"getting_started/concepts.html#bouncers","text":"[ References ] Bouncers are standalone software pieces in charge of acting upon IPs that triggered alerts. To do so, bouncers are going to query the local API to know if there is an existing decisions against a given IP, range, username etc. You can find a list of existing bouncers on the hub","title":"Bouncers"},{"location":"getting_started/concepts.html#configuration-items","text":"","title":"Configuration items"},{"location":"getting_started/concepts.html#acquisition","text":"[ References ] Acquistion configuration defines which streams of information crowdsec-agent is going to process. At the time of writing, it's mostly files or journald, but it should be more or less any kind of stream, such as a kafka topic or a cloudtrail. Acquisition configuration always contains a stream (ie. a file to tail) and a tag (ie. \"these are in syslog format\" \"these are non-syslog nginx logs\"). File acquisition configuration is defined as : filenames : - /var/log/auth.log labels : type : syslog The labels part is here to tag the incoming logs with a type. labels.type are used by the parsers to know which logs to process.","title":"Acquisition"},{"location":"getting_started/concepts.html#stages","text":"[ References ] Stages concept is central to data parsing in crowdsec-agent, as it allows to have various \"steps\" of parsing. All parsers belong to a given stage. While users can add or modify the stages order, the following stages exist : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Thus a sshd log might follow this pipeline : s00-raw : be parsed by crowdsecurity/syslog-logs (will move event to the next stage) s01-raw : be parsed by crowdsecurity/sshd-logs (will move event to the next stage) s02-enrich : will be parsed by crowdsecurity/geoip-enrich and crowdsecurity/dateparse-enrich","title":"Stages"},{"location":"getting_started/concepts.html#parsers","text":"[ References ] For logs to be able to be exploited and analyzed, they need to be parsed and normalized, and this is where parsers are used. A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing. A parser usually has a specific scope. For example, if you are using nginx , you will probably want to use the crowdsecurity/nginx-logs which allows your crowdsec-agent setup to parse nginx's access and error logs. Parsers are organized into stages to allow pipelines and branching in parsing. See the Crowdsec Hub to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing You can as well write your own !","title":"Parsers"},{"location":"getting_started/concepts.html#enrichers","text":"[ References ] Enrichment is the action of adding extra context to an event based on the information we already have, so that better decision can later be taken. In most cases, you should be able to find the relevant enrichers on our Crowdsec Hub . A common/simple type of enrichment would be geoip-enrich of an event (adding information such as : origin country, origin AS and origin IP range to an event). Once again, you should be able to find the ones you're looking for on the Crowdsec Hub !","title":"Enrichers"},{"location":"getting_started/concepts.html#scenarios","text":"[ References ] Scenarios is the expression of a heuristic that allows you to qualify a specific event (usually an attack).It is a YAML file that describes a set of events characterizing a scenario. Scenarios in crowdsec-agent gravitate around the leaky bucket principle. A scenario description includes at least : Event eligibility rules. (For example if we're writing a ssh bruteforce detection we only focus on logs of type ssh_failed_auth ) Bucket configuration such as the leak speed or its capacity (in our same ssh bruteforce example, we might allow 1 failed auth per 10s and no more than 5 in a short amount of time: leakspeed: 10s capacity: 5 ) Aggregation rules : per source ip or per other criterias (in our ssh bruteforce example, we will group per source ip) The description allows for many other rules to be specified (blackhole, distinct filters etc.), to allow rather complex scenarios. See the Crowdsec Hub to explore scenarios and their capabilities, or see below some examples : ssh bruteforce detection distinct http-404 scan iptables port scan You can as well write your own !","title":"Scenarios"},{"location":"getting_started/concepts.html#collections","text":"[ References ] To make user's life easier, \"collections\" are available, which are just a bundle of parsers and scenarios. In this way, if you want to cover basic use-cases of let's say \"nginx\", you can just install the crowdsecurity/nginx collection that is composed of crowdsecurity/nginx-logs parser, as well as generic http scenarios such as crowdsecurity/base-http-scenarios . As usual, those can be found on the Crowdsec Hub !","title":"Collections"},{"location":"getting_started/concepts.html#postoverflows","text":"[ References ] A postoverflow is a parser that will be applied on overflows (scenario results) before the decision is written to local DB or pushed to API. Parsers in postoverflows are meant to be used for \"expensive\" enrichment/parsing process that you do not want to perform on all incoming events, but rather on decision that are about to be taken. An example could be slack/mattermost enrichment plugin that requires human confirmation before applying the decision or reverse-dns lookup operations.","title":"PostOverflows"},{"location":"getting_started/concepts.html#runtime-items","text":"","title":"Runtime items"},{"location":"getting_started/concepts.html#events","text":"[ References ] An Event is the runtime representation of an item being processed by crowdsec : It be a Log line being parsed, or an Overflow being reprocessed. The Event object is modified by parses, scenarios, and directly via user statics expressions (for example).","title":"Events"},{"location":"getting_started/concepts.html#alerts","text":"[ References ] An Alert is the runtime representation of a bucket overflow being processed by crowdsec : It is embedded in an Event. The Alert object is modified by post-overflows and profiles .","title":"Alerts"},{"location":"getting_started/concepts.html#decisions","text":"[ References ] A Decision is the representation of the consequence of a bucket overflow : a decision against an IP, a range, an AS, a Country, a User, a Session etc. Decisions are generated by Local API (LAPI) when an Alert is received, according to the existing profiles","title":"Decisions"},{"location":"getting_started/crowdsec-tour.html","text":"List installed configurations \u00b6 sudo cscli hub list On the machine where you deployed crowdsec-agent, type sudo cscli hub list to see install configurations. This list represents the parsers, scenarios and/or collections that you deployed. They represent what your crowdsec-agent setup can read (logs) and detect (scenarios). sudo cscli hub list -a will list all available configurations in the hub. Check cscli configuration management for more ! output example $ sudo cscli hub list INFO [ 0000 ] Loaded 13 collecs, 17 parsers, 21 scenarios, 3 post-overflow parsers INFO [ 0000 ] unmanaged items : 23 local, 0 tainted INFO [ 0000 ] PARSERS: -------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------- crowdsecurity/mysql-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/mysql-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/dateparse-enrich.yaml crowdsecurity/whitelists \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/whitelists.yaml crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 /etc/crowdsec/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml -------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] SCENARIOS: ------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------- crowdsecurity/mysql-bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/mysql-bf.yaml crowdsecurity/ssh-bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/ssh-bf.yaml ------------------------------------------------------------------------------------- INFO [ 0000 ] COLLECTIONS: --------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH --------------------------------------------------------------------------------- crowdsecurity/mysql \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/mysql.yaml crowdsecurity/sshd \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/sshd.yaml crowdsecurity/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/collections/linux.yaml --------------------------------------------------------------------------------- INFO [ 0000 ] POSTOVERFLOWS: -------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------- -------------------------------------- Installing configurations \u00b6 sudo cscli <configuration_type> install <item> configuration_type can be: parsers scenarios postoverflows collections They can be found and browsed on the Crowdsec Hub Upgrading configurations \u00b6 sudo cscli <configuration_type> upgrade <item> configuration_type can be: parsers scenarios postoverflows collections They can be found and browsed on the Crowdsec Hub List active decisions \u00b6 sudo cscli decisions list If you just deployed crowdsec-agent, the list might be empty, but don't worry, it simply means you haven't yet been attacked, congrats! Check cscli decisions management for more ! output example $ sudo cscli decisions list +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | 802 | cscli | Ip:1.2.3.5 | manual 'ban' from | ban | | | 1 | 3h50m58.10039043s | 802 | | | | | 'b76cc7b1bbdc489e93909d2043031de8' | | | | | | | | 801 | crowdsec | Ip:1.2.3.4 | crowdsecurity/ssh-bf | ban | | | 6 | 3h59m45.100387557s | 801 | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ There are different decisions SOURCE : crowdsec : decisions triggered locally by the crowdsec agent CAPI : decisions fetched from the Crowdsec Central API csli : decisions added via sudo cscli decisions add List alerts \u00b6 sudo cscli alerts list While decisions won't be shown anymore once they expire (or are manually deleted), the alerts will stay visible, allowing you to keep track of past decisions. You will here see the alerts, even if the associated decisions expired. output example $ sudo cscli alerts list --since 1h +----+-------------+----------------------------+---------+----+-----------+---------------------------+ | ID | SCOPE:VALUE | REASON | COUNTRY | AS | DECISIONS | CREATED AT | +----+-------------+----------------------------+---------+----+-----------+---------------------------+ | 5 | Ip:1.2.3.6 | crowdsecurity/ssh-bf ( 0 .1 ) | US | | ban:1 | 2020 -10-29T11:33:36+01:00 | +----+-------------+----------------------------+---------+----+-----------+---------------------------+ Monitor on-going activity (prometheus) \u00b6 sudo cscli metrics The metrics displayed are extracted from crowdsec-agent prometheus. The indicators are grouped by scope : Buckets : Know which buckets are created and/or overflew (scenario efficiency) Acquisition : Know which file produce logs and if thy are parsed (or end up in bucket) Parser : Know how frequently the individual parsers are triggered and their success rate Local Api Metrics : Know how often each endpoint of crowdsec's local API has been used output example $ sudo cscli metrics INFO [ 0000 ] Buckets Metrics: +--------------------------------------+---------------+-----------+--------------+--------+---------+ | BUCKET | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +--------------------------------------+---------------+-----------+--------------+--------+---------+ | crowdsecurity/http-bad-user-agent | - | - | 7 | 7 | 7 | | crowdsecurity/http-crawl-non_statics | - | - | 82 | 107 | 82 | | crowdsecurity/http-probing | - | - | 2 | 2 | 2 | | crowdsecurity/http-sensitive-files | - | - | 1 | 1 | 1 | | crowdsecurity/ssh-bf | 16 | 5562 | 7788 | 41542 | 2210 | | crowdsecurity/ssh-bf_user-enum | 8 | - | 6679 | 12571 | 6671 | +--------------------------------------+---------------+-----------+--------------+--------+---------+ INFO [ 0000 ] Acquisition Metrics: +---------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +---------------------------+------------+--------------+----------------+------------------------+ | /var/log/auth.log | 92978 | 41542 | 51436 | 54113 | | /var/log/messages | 2 | - | 2 | - | | /var/log/nginx/access.log | 124 | 99 | 25 | 88 | | /var/log/nginx/error.log | 287 | 63 | 224 | 29 | | /var/log/syslog | 27271 | - | 27271 | - | +---------------------------+------------+--------------+----------------+------------------------+ INFO [ 0000 ] Parser Metrics: +--------------------------------+--------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +--------------------------------+--------+--------+----------+ | child-crowdsecurity/http-logs | 486 | 232 | 254 | | child-crowdsecurity/nginx-logs | 723 | 162 | 561 | | child-crowdsecurity/sshd-logs | 381792 | 41542 | 340250 | | crowdsecurity/dateparse-enrich | 41704 | 41704 | - | | crowdsecurity/geoip-enrich | 41641 | 41641 | - | | crowdsecurity/http-logs | 162 | 59 | 103 | | crowdsecurity/nginx-logs | 411 | 162 | 249 | | crowdsecurity/non-syslog | 411 | 411 | - | | crowdsecurity/sshd-logs | 92126 | 41542 | 50584 | | crowdsecurity/syslog-logs | 120251 | 120249 | 2 | | crowdsecurity/whitelists | 41704 | 41704 | - | +--------------------------------+--------+--------+----------+ INFO [ 0000 ] Local Api Metrics: +----------------------+--------+------+ | ROUTE | METHOD | HITS | +----------------------+--------+------+ | /v1/alerts | GET | 3 | | /v1/alerts | POST | 4673 | | /v1/decisions/stream | GET | 6498 | | /v1/watchers/login | POST | 23 | +----------------------+--------+------+ INFO [ 0000 ] Local Api Machines Metrics: +----------------------------------+------------+--------+------+ | MACHINE | ROUTE | METHOD | HITS | +----------------------------------+------------+--------+------+ | 7f0607a3469243139699bf2f30321fc4 | /v1/alerts | POST | 4673 | | 7f0607a3469243139699bf2f30321fc4 | /v1/alerts | GET | 3 | +----------------------------------+------------+--------+------+ INFO [ 0000 ] Local Api Bouncers Metrics: +------------------------------+----------------------+--------+------+ | BOUNCER | ROUTE | METHOD | HITS | +------------------------------+----------------------+--------+------+ | cs-firewall-bouncer-n3W19Qua | /v1/decisions/stream | GET | 6498 | +------------------------------+----------------------+--------+------+ Reading metrics \u00b6 Those metrics are a great way to know if your configuration is correct : The Acquisition Metrics is a great way to know if your parsers are setup correctly : If you have 0 LINES PARSED for a source : You are probably missing a parser, or you have a custom log format that prevents the parser from understanding your logs. However, it's perfectly OK to have a lot of LINES UNPARSED : Crowdsec is not a SIEM, and only parses the logs that are relevant to its scenarios. For example, ssh parser , only cares about failed authentication events (at the time of writting). LINES POURED TO BUCKET tell you that your scenarios are matching your log sources : it means that some events from this log source made all their way to an actual scenario The Parser Metrics will let you troubleshoot eventual parser misconfigurations : HITS is how many events where fed to this specific parser PARSED and UNPARSED indicate how many events successfully come out of the parser For example, if you have a custom log format in nginx that is not supported by the default parser, you will end up seeing a lot of UNPARSED for this specific parser, and 0 for PARSED . For more advanced metrics understanding, take a look at the dedicated prometheus documentation . Deploy dashboard \u00b6 sudo cscli dashboard setup --listen 0 .0.0.0 A docker metabase container can be deployed with cscli dashboard . It requires docker, installation instructions are available here . Logs \u00b6 sudo tail -f /var/log/crowdsec.log /var/log/crowdsec.log is the main log, it shows ongoing decisions and acquisition/parsing/scenario errors. /var/log/crowdsec_api.log is the access log of the local api (LAPI) Scalability \u00b6 Crowdsec uses go-routines for parsing and enriching logs, pouring events to buckets and manage outputs. By default, one routine of each exists (should be enough to handle ~1K EP/s), and can be changed in crowdsec_service of the main configuration file via the parser_routines , buckets_routines and output_routines directives. Please keep in mind that thanks to the http API , the workload of log parsing can be splitted amongst several agents pushing to a single Local API .","title":"Crowdsec Tour"},{"location":"getting_started/crowdsec-tour.html#list-installed-configurations","text":"sudo cscli hub list On the machine where you deployed crowdsec-agent, type sudo cscli hub list to see install configurations. This list represents the parsers, scenarios and/or collections that you deployed. They represent what your crowdsec-agent setup can read (logs) and detect (scenarios). sudo cscli hub list -a will list all available configurations in the hub. Check cscli configuration management for more ! output example $ sudo cscli hub list INFO [ 0000 ] Loaded 13 collecs, 17 parsers, 21 scenarios, 3 post-overflow parsers INFO [ 0000 ] unmanaged items : 23 local, 0 tainted INFO [ 0000 ] PARSERS: -------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------- crowdsecurity/mysql-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/mysql-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/dateparse-enrich.yaml crowdsecurity/whitelists \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/whitelists.yaml crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 /etc/crowdsec/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml -------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] SCENARIOS: ------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------- crowdsecurity/mysql-bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/mysql-bf.yaml crowdsecurity/ssh-bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/ssh-bf.yaml ------------------------------------------------------------------------------------- INFO [ 0000 ] COLLECTIONS: --------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH --------------------------------------------------------------------------------- crowdsecurity/mysql \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/mysql.yaml crowdsecurity/sshd \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/sshd.yaml crowdsecurity/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/collections/linux.yaml --------------------------------------------------------------------------------- INFO [ 0000 ] POSTOVERFLOWS: -------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------- --------------------------------------","title":"List installed configurations"},{"location":"getting_started/crowdsec-tour.html#installing-configurations","text":"sudo cscli <configuration_type> install <item> configuration_type can be: parsers scenarios postoverflows collections They can be found and browsed on the Crowdsec Hub","title":"Installing configurations"},{"location":"getting_started/crowdsec-tour.html#upgrading-configurations","text":"sudo cscli <configuration_type> upgrade <item> configuration_type can be: parsers scenarios postoverflows collections They can be found and browsed on the Crowdsec Hub","title":"Upgrading configurations"},{"location":"getting_started/crowdsec-tour.html#list-active-decisions","text":"sudo cscli decisions list If you just deployed crowdsec-agent, the list might be empty, but don't worry, it simply means you haven't yet been attacked, congrats! Check cscli decisions management for more ! output example $ sudo cscli decisions list +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | 802 | cscli | Ip:1.2.3.5 | manual 'ban' from | ban | | | 1 | 3h50m58.10039043s | 802 | | | | | 'b76cc7b1bbdc489e93909d2043031de8' | | | | | | | | 801 | crowdsec | Ip:1.2.3.4 | crowdsecurity/ssh-bf | ban | | | 6 | 3h59m45.100387557s | 801 | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ There are different decisions SOURCE : crowdsec : decisions triggered locally by the crowdsec agent CAPI : decisions fetched from the Crowdsec Central API csli : decisions added via sudo cscli decisions add","title":"List active decisions"},{"location":"getting_started/crowdsec-tour.html#list-alerts","text":"sudo cscli alerts list While decisions won't be shown anymore once they expire (or are manually deleted), the alerts will stay visible, allowing you to keep track of past decisions. You will here see the alerts, even if the associated decisions expired. output example $ sudo cscli alerts list --since 1h +----+-------------+----------------------------+---------+----+-----------+---------------------------+ | ID | SCOPE:VALUE | REASON | COUNTRY | AS | DECISIONS | CREATED AT | +----+-------------+----------------------------+---------+----+-----------+---------------------------+ | 5 | Ip:1.2.3.6 | crowdsecurity/ssh-bf ( 0 .1 ) | US | | ban:1 | 2020 -10-29T11:33:36+01:00 | +----+-------------+----------------------------+---------+----+-----------+---------------------------+","title":"List alerts"},{"location":"getting_started/crowdsec-tour.html#monitor-on-going-activity-prometheus","text":"sudo cscli metrics The metrics displayed are extracted from crowdsec-agent prometheus. The indicators are grouped by scope : Buckets : Know which buckets are created and/or overflew (scenario efficiency) Acquisition : Know which file produce logs and if thy are parsed (or end up in bucket) Parser : Know how frequently the individual parsers are triggered and their success rate Local Api Metrics : Know how often each endpoint of crowdsec's local API has been used output example $ sudo cscli metrics INFO [ 0000 ] Buckets Metrics: +--------------------------------------+---------------+-----------+--------------+--------+---------+ | BUCKET | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +--------------------------------------+---------------+-----------+--------------+--------+---------+ | crowdsecurity/http-bad-user-agent | - | - | 7 | 7 | 7 | | crowdsecurity/http-crawl-non_statics | - | - | 82 | 107 | 82 | | crowdsecurity/http-probing | - | - | 2 | 2 | 2 | | crowdsecurity/http-sensitive-files | - | - | 1 | 1 | 1 | | crowdsecurity/ssh-bf | 16 | 5562 | 7788 | 41542 | 2210 | | crowdsecurity/ssh-bf_user-enum | 8 | - | 6679 | 12571 | 6671 | +--------------------------------------+---------------+-----------+--------------+--------+---------+ INFO [ 0000 ] Acquisition Metrics: +---------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +---------------------------+------------+--------------+----------------+------------------------+ | /var/log/auth.log | 92978 | 41542 | 51436 | 54113 | | /var/log/messages | 2 | - | 2 | - | | /var/log/nginx/access.log | 124 | 99 | 25 | 88 | | /var/log/nginx/error.log | 287 | 63 | 224 | 29 | | /var/log/syslog | 27271 | - | 27271 | - | +---------------------------+------------+--------------+----------------+------------------------+ INFO [ 0000 ] Parser Metrics: +--------------------------------+--------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +--------------------------------+--------+--------+----------+ | child-crowdsecurity/http-logs | 486 | 232 | 254 | | child-crowdsecurity/nginx-logs | 723 | 162 | 561 | | child-crowdsecurity/sshd-logs | 381792 | 41542 | 340250 | | crowdsecurity/dateparse-enrich | 41704 | 41704 | - | | crowdsecurity/geoip-enrich | 41641 | 41641 | - | | crowdsecurity/http-logs | 162 | 59 | 103 | | crowdsecurity/nginx-logs | 411 | 162 | 249 | | crowdsecurity/non-syslog | 411 | 411 | - | | crowdsecurity/sshd-logs | 92126 | 41542 | 50584 | | crowdsecurity/syslog-logs | 120251 | 120249 | 2 | | crowdsecurity/whitelists | 41704 | 41704 | - | +--------------------------------+--------+--------+----------+ INFO [ 0000 ] Local Api Metrics: +----------------------+--------+------+ | ROUTE | METHOD | HITS | +----------------------+--------+------+ | /v1/alerts | GET | 3 | | /v1/alerts | POST | 4673 | | /v1/decisions/stream | GET | 6498 | | /v1/watchers/login | POST | 23 | +----------------------+--------+------+ INFO [ 0000 ] Local Api Machines Metrics: +----------------------------------+------------+--------+------+ | MACHINE | ROUTE | METHOD | HITS | +----------------------------------+------------+--------+------+ | 7f0607a3469243139699bf2f30321fc4 | /v1/alerts | POST | 4673 | | 7f0607a3469243139699bf2f30321fc4 | /v1/alerts | GET | 3 | +----------------------------------+------------+--------+------+ INFO [ 0000 ] Local Api Bouncers Metrics: +------------------------------+----------------------+--------+------+ | BOUNCER | ROUTE | METHOD | HITS | +------------------------------+----------------------+--------+------+ | cs-firewall-bouncer-n3W19Qua | /v1/decisions/stream | GET | 6498 | +------------------------------+----------------------+--------+------+","title":"Monitor on-going activity (prometheus)"},{"location":"getting_started/crowdsec-tour.html#reading-metrics","text":"Those metrics are a great way to know if your configuration is correct : The Acquisition Metrics is a great way to know if your parsers are setup correctly : If you have 0 LINES PARSED for a source : You are probably missing a parser, or you have a custom log format that prevents the parser from understanding your logs. However, it's perfectly OK to have a lot of LINES UNPARSED : Crowdsec is not a SIEM, and only parses the logs that are relevant to its scenarios. For example, ssh parser , only cares about failed authentication events (at the time of writting). LINES POURED TO BUCKET tell you that your scenarios are matching your log sources : it means that some events from this log source made all their way to an actual scenario The Parser Metrics will let you troubleshoot eventual parser misconfigurations : HITS is how many events where fed to this specific parser PARSED and UNPARSED indicate how many events successfully come out of the parser For example, if you have a custom log format in nginx that is not supported by the default parser, you will end up seeing a lot of UNPARSED for this specific parser, and 0 for PARSED . For more advanced metrics understanding, take a look at the dedicated prometheus documentation .","title":"Reading metrics"},{"location":"getting_started/crowdsec-tour.html#deploy-dashboard","text":"sudo cscli dashboard setup --listen 0 .0.0.0 A docker metabase container can be deployed with cscli dashboard . It requires docker, installation instructions are available here .","title":"Deploy dashboard"},{"location":"getting_started/crowdsec-tour.html#logs","text":"sudo tail -f /var/log/crowdsec.log /var/log/crowdsec.log is the main log, it shows ongoing decisions and acquisition/parsing/scenario errors. /var/log/crowdsec_api.log is the access log of the local api (LAPI)","title":"Logs"},{"location":"getting_started/crowdsec-tour.html#scalability","text":"Crowdsec uses go-routines for parsing and enriching logs, pouring events to buckets and manage outputs. By default, one routine of each exists (should be enough to handle ~1K EP/s), and can be changed in crowdsec_service of the main configuration file via the parser_routines , buckets_routines and output_routines directives. Please keep in mind that thanks to the http API , the workload of log parsing can be splitted amongst several agents pushing to a single Local API .","title":"Scalability"},{"location":"getting_started/installation.html","text":"Installation methods \u00b6 On debian / ubuntu : \u00b6 Set up crowdsec's repositories and install from them, for ease of installation and upgrade Some users use debian's official crowdsec packages Some users download the DEB package directly and install it manually On RHEL / CentOS : \u00b6 Set up crowdsec's repositories and install from them, for ease of installation and upgrade On FreeBSD : \u00b6 crowdsec and the firewall bouncer are available Generic *nix & containers : \u00b6 Some users download the tarball directly and install it manually Some users use the docker hub image And the most adventurous might want to build & install from source And some might even want to build their own docker image Or use it with docker-compose Required resources \u00b6 Crowdsec agent itself is rather light, and in a small to medium setup should use less than 100Mb of memory. During intensive logs processing, CPU is going to be the most used resource, and memory usage shouldn't really grow. However, running metabase (the dashboard deployed by cscli dashboard setup ) requires 1-2Gb of RAM . Install on debian using crowdsec repository \u00b6 On debian and ubuntu, packages are hosted on packagecloud.io . Crowdsec distributes their own pragmatic debian packages that closely follow the development stream (packages are automatically published on release), and are suitable for those that want to keep up with the latest changes of crowdsec. setup the repository \u00b6 Instructions for adding repositories to your machine can be found in packagecloud's installation docs : curl -s https://packagecloud.io/install/repositories/crowdsec/crowdsec/script.deb.sh | sudo bash If you're not fond of curl ... | sudo bash , follow instruction bellow : Retrieve the signing key curl -L https://packagecloud.io/crowdsec/crowdsec/gpgkey | sudo apt-key add - 2.Install the apt-transport-https package in order to be able to fetch packages over HTTPS: sudo apt-get install -y apt-transport-https Add the appropriate repository to your source.list debian: echo \"deb https://packagecloud.io/crowdsec/crowdsec/debian/ $( lsb_release -cs ) main\" | sudo tee /etc/apt/sources.list.d/crowdsec.list > /dev/null ubuntu: echo \"deb https://packagecloud.io/crowdsec/crowdsec/ubuntu/ $( lsb_release -cs ) main\" | sudo tee /etc/apt/sources.list.d/crowdsec.list > /dev/null install crowdsec \u00b6 The following debian suites / architectures are available : Suite Architecture bionic amd64, arm64 bullseye amd64, arm64 buster amd64, arm64 focal amd64, arm64 stretch amd64, arm64 xenial amd64, arm64 sudo apt-get update sudo apt-get install crowdsec Manually install the debian package \u00b6 Fetch your package from the public repository , and install it manually : sudo dpkg -i ./crowdsec_1.0.7-4_amd64.deb Install using debian official packages \u00b6 Crowdsec is available for bullseye & sid and can be installed simply : sudo apt-get install crowdsec Install on redhat/centos using crowdsec repository \u00b6 On redhat and centos, packages are hosted on packagecloud.io . Crowdsec distributes their own pragmatic debian packages that closely follow the development stream (packages are automatically published on release), and are suitable for those that want to keep up with the latest changes of crowdsec. setup the repository \u00b6 Instructions for adding repositories to your machine can be found in packagecloud's installation docs : curl -s https://packagecloud.io/install/repositories/crowdsec/crowdsec/script.rpm.sh | sudo bash If you're not fond of curl ... | sudo bash , you can look at the manual method to directly add the appropriate .repo to your configuration. install crowdsec \u00b6 The following rhel/centos suites / architectures are available : Suite Architecture el/7 amd64 el/8 amd64, arm64 fedora/33 amd64, arm64 fedora/34 amd64, arm64 amazon linux/2 amd64, arm64 centos/8 and fedora/33 and fedora/34 : dnf install crowdsec older versions : yum install crowdsec Install on FreeBSD \u00b6 Crowdsec is available on FreeBSD: sudo pkg install crowdsec The crowdsec firewall bouncer is available as well: sudo pkg install crowdsec-firewall-bouncer Install from the release tarball \u00b6 Fetch crowdsec-agent's latest version here . tar xvzf crowdsec-release.tgz cd crowdsec-v1.X.X A wizard is provided to help you deploy crowdsec-agent and cscli. Using the interactive wizard \u00b6 sudo ./wizard.sh -i The wizard is going to guide you through the following steps : detect services that are present on your machine detect selected services logs suggest collections (parsers and scenarios) to deploy deploy & configure crowdsec-agent in order to watch selected logs for selected scenarios The process should take less than a minute, please report if there are any issues . You are then ready to take a tour of your freshly deployed crowdsec-agent ! Info Keep in mind the crowdsec-agent is only in charge of the \"detection\", and won't block anything on its own. You need to deploy a bouncers to \"apply\" decisions. Binary installation \u00b6 you of little faith sudo ./wizard.sh --bininstall This will only deploy the binaries, and some extra installation steps need to be completed for the software to be functional : sudo cscli hub update : update the hub index sudo cscli machines add -a : register crowdsec to the local API sudo cscli capi register : register to the central API sudo cscli collections install crowdsecurity/linux : install essential configs (syslog parser, geoip enrichment, date parsers) configure your sources in your acquisition : /etc/crowdsec/acquis.yaml You can now start & enable the crowdsec service : sudo systemctl start crowdsec sudo systemctl enable crowdsec Using the unattended wizard \u00b6 If your setup is standard and you've walked through the default installation without issues, you can win some time in case you need to perform a new install : sudo ./wizard.sh --unattended This mode will emulate the interactive mode of the wizard where you answer yes to everything and stick with the default options. Install from source \u00b6 Requirements Go v1.13+ git clone https://github.com/crowdsecurity/crowdsec jq Go in crowdsec-agent folder and build the binaries : cd crowdsec make release This will create you a directory ( crowdsec-vXXX/ ) and an archive ( crowdsec-release.tgz ) that are release built from your local code source. Now, you can install either with interactive wizard or the unattended mode . Build docker image \u00b6 Crowdsec provides a docker image and can simply built like this : git clone https://github.com/crowdsecurity/crowdsec.git && cd crowdsec docker build -t crowdsec .","title":"Install Crowdsec"},{"location":"getting_started/installation.html#installation-methods","text":"","title":"Installation methods"},{"location":"getting_started/installation.html#on-debian-ubuntu","text":"Set up crowdsec's repositories and install from them, for ease of installation and upgrade Some users use debian's official crowdsec packages Some users download the DEB package directly and install it manually","title":"On debian / ubuntu :"},{"location":"getting_started/installation.html#on-rhel-centos","text":"Set up crowdsec's repositories and install from them, for ease of installation and upgrade","title":"On RHEL / CentOS :"},{"location":"getting_started/installation.html#on-freebsd","text":"crowdsec and the firewall bouncer are available","title":"On FreeBSD :"},{"location":"getting_started/installation.html#generic-nix-containers","text":"Some users download the tarball directly and install it manually Some users use the docker hub image And the most adventurous might want to build & install from source And some might even want to build their own docker image Or use it with docker-compose","title":"Generic *nix &amp; containers :"},{"location":"getting_started/installation.html#required-resources","text":"Crowdsec agent itself is rather light, and in a small to medium setup should use less than 100Mb of memory. During intensive logs processing, CPU is going to be the most used resource, and memory usage shouldn't really grow. However, running metabase (the dashboard deployed by cscli dashboard setup ) requires 1-2Gb of RAM .","title":"Required resources"},{"location":"getting_started/installation.html#install-on-debian-using-crowdsec-repository","text":"On debian and ubuntu, packages are hosted on packagecloud.io . Crowdsec distributes their own pragmatic debian packages that closely follow the development stream (packages are automatically published on release), and are suitable for those that want to keep up with the latest changes of crowdsec.","title":"Install on debian using crowdsec repository"},{"location":"getting_started/installation.html#setup-the-repository","text":"Instructions for adding repositories to your machine can be found in packagecloud's installation docs : curl -s https://packagecloud.io/install/repositories/crowdsec/crowdsec/script.deb.sh | sudo bash If you're not fond of curl ... | sudo bash , follow instruction bellow : Retrieve the signing key curl -L https://packagecloud.io/crowdsec/crowdsec/gpgkey | sudo apt-key add - 2.Install the apt-transport-https package in order to be able to fetch packages over HTTPS: sudo apt-get install -y apt-transport-https Add the appropriate repository to your source.list debian: echo \"deb https://packagecloud.io/crowdsec/crowdsec/debian/ $( lsb_release -cs ) main\" | sudo tee /etc/apt/sources.list.d/crowdsec.list > /dev/null ubuntu: echo \"deb https://packagecloud.io/crowdsec/crowdsec/ubuntu/ $( lsb_release -cs ) main\" | sudo tee /etc/apt/sources.list.d/crowdsec.list > /dev/null","title":"setup the repository"},{"location":"getting_started/installation.html#install-crowdsec","text":"The following debian suites / architectures are available : Suite Architecture bionic amd64, arm64 bullseye amd64, arm64 buster amd64, arm64 focal amd64, arm64 stretch amd64, arm64 xenial amd64, arm64 sudo apt-get update sudo apt-get install crowdsec","title":"install crowdsec"},{"location":"getting_started/installation.html#manually-install-the-debian-package","text":"Fetch your package from the public repository , and install it manually : sudo dpkg -i ./crowdsec_1.0.7-4_amd64.deb","title":"Manually install the debian package"},{"location":"getting_started/installation.html#install-using-debian-official-packages","text":"Crowdsec is available for bullseye & sid and can be installed simply : sudo apt-get install crowdsec","title":"Install using debian official packages"},{"location":"getting_started/installation.html#install-on-redhatcentos-using-crowdsec-repository","text":"On redhat and centos, packages are hosted on packagecloud.io . Crowdsec distributes their own pragmatic debian packages that closely follow the development stream (packages are automatically published on release), and are suitable for those that want to keep up with the latest changes of crowdsec.","title":"Install on redhat/centos using crowdsec repository"},{"location":"getting_started/installation.html#setup-the-repository_1","text":"Instructions for adding repositories to your machine can be found in packagecloud's installation docs : curl -s https://packagecloud.io/install/repositories/crowdsec/crowdsec/script.rpm.sh | sudo bash If you're not fond of curl ... | sudo bash , you can look at the manual method to directly add the appropriate .repo to your configuration.","title":"setup the repository"},{"location":"getting_started/installation.html#install-crowdsec_1","text":"The following rhel/centos suites / architectures are available : Suite Architecture el/7 amd64 el/8 amd64, arm64 fedora/33 amd64, arm64 fedora/34 amd64, arm64 amazon linux/2 amd64, arm64 centos/8 and fedora/33 and fedora/34 : dnf install crowdsec older versions : yum install crowdsec","title":"install crowdsec"},{"location":"getting_started/installation.html#install-on-freebsd","text":"Crowdsec is available on FreeBSD: sudo pkg install crowdsec The crowdsec firewall bouncer is available as well: sudo pkg install crowdsec-firewall-bouncer","title":"Install on FreeBSD"},{"location":"getting_started/installation.html#install-from-the-release-tarball","text":"Fetch crowdsec-agent's latest version here . tar xvzf crowdsec-release.tgz cd crowdsec-v1.X.X A wizard is provided to help you deploy crowdsec-agent and cscli.","title":"Install from the release tarball"},{"location":"getting_started/installation.html#using-the-interactive-wizard","text":"sudo ./wizard.sh -i The wizard is going to guide you through the following steps : detect services that are present on your machine detect selected services logs suggest collections (parsers and scenarios) to deploy deploy & configure crowdsec-agent in order to watch selected logs for selected scenarios The process should take less than a minute, please report if there are any issues . You are then ready to take a tour of your freshly deployed crowdsec-agent ! Info Keep in mind the crowdsec-agent is only in charge of the \"detection\", and won't block anything on its own. You need to deploy a bouncers to \"apply\" decisions.","title":"Using the interactive wizard"},{"location":"getting_started/installation.html#binary-installation","text":"you of little faith sudo ./wizard.sh --bininstall This will only deploy the binaries, and some extra installation steps need to be completed for the software to be functional : sudo cscli hub update : update the hub index sudo cscli machines add -a : register crowdsec to the local API sudo cscli capi register : register to the central API sudo cscli collections install crowdsecurity/linux : install essential configs (syslog parser, geoip enrichment, date parsers) configure your sources in your acquisition : /etc/crowdsec/acquis.yaml You can now start & enable the crowdsec service : sudo systemctl start crowdsec sudo systemctl enable crowdsec","title":"Binary installation"},{"location":"getting_started/installation.html#using-the-unattended-wizard","text":"If your setup is standard and you've walked through the default installation without issues, you can win some time in case you need to perform a new install : sudo ./wizard.sh --unattended This mode will emulate the interactive mode of the wizard where you answer yes to everything and stick with the default options.","title":"Using the unattended wizard"},{"location":"getting_started/installation.html#install-from-source","text":"Requirements Go v1.13+ git clone https://github.com/crowdsecurity/crowdsec jq Go in crowdsec-agent folder and build the binaries : cd crowdsec make release This will create you a directory ( crowdsec-vXXX/ ) and an archive ( crowdsec-release.tgz ) that are release built from your local code source. Now, you can install either with interactive wizard or the unattended mode .","title":"Install from source"},{"location":"getting_started/installation.html#build-docker-image","text":"Crowdsec provides a docker image and can simply built like this : git clone https://github.com/crowdsecurity/crowdsec.git && cd crowdsec docker build -t crowdsec .","title":"Build docker image"},{"location":"getting_started/upgrades.html","text":"Upgrade notes \u00b6 Crowdsec does it best not to break existing setups, and the following rules generally applies : patches ( X.X.Y to X.X.Z ) can be applied blindly and are for bugfixes and backward compatible changes minor ( X.Y.X to X.Z.X ) can be applied blindly but might introduce some features that are not backward compatible major ( Y.X.X to Z.X.X ) must be applied with caution as they might break existing installation Warning We strongly advise you against running crowdsec and LAPI in different versions. When upgrading existing setup, we suggest you to upgrade both crowdsec, cscli and LAPI. Upgrades from debian packages (official or pragmatic) \u00b6 apt-get update apt-get install crowdsec Upgrades from release tarball \u00b6 Patch upgrade \u00b6 wizard.sh --binupgrade When doing a minor/patch upgrade (ie. 1.0.0 to 1.0.1 ), the --binupgrade feature should be the more appropriate : It will simply upgrade the existing binaries, letting all configurations untouched. Minor upgrade \u00b6 wizard.sh --upgrade When doing a minor upgrade (ie. 1.0.4 to 1.1.0 ), the --upgrade feature should be used : It will attempt to migrate and upgrade any existing configurations, include tainted/custom ones. The ambition is to be able to upgrade scenarios, parsers etc to the latest version when relevant, while keeping custom/tainted ones untouched. It's using cscli config backup , creating a directory (usually /tmp/tmp.<random> ) in which it's going to dump all relevant configurations before performing an upgrade : configuration files : acquis.yaml *_credentials.yaml profiles.yaml simulation.yaml config.yaml one directory for parsers , scenarios , postoverflows and collections , where it's going to store both reference to upstream configurations, and your custom/tainted ones It is then going to cleanup crowdsec configuration, /etc/crowdsec/ content (except bouncers configuration), before deploying the new binaries. Once this is done, configuration will be restored from our temp directory using cscli config restore . Major upgrade \u00b6 For major upgrades (ie. 0.3.X to 1.0.X ), wizard won't do the trick, and you'll have to rely on documentation to do so : Migrating from 0.3.X to 1.0.X : documentation Manual operations \u00b6 cscli config is your friend here, with backup and restore subcommands allowing you to backup and restore all of the configuration files. Upgrading collections/parsers/scenarios \u00b6 cscli hub allows you to view, update and upgrade configurations : cscli hub update downloads the latest list of available scenarios/parsers/etc cscli hub list lists all the installed configurations, their versions and status cscli hub upgrade upgrades existing configurations to the latest available version in said list","title":"Upgrade Crowdsec"},{"location":"getting_started/upgrades.html#upgrade-notes","text":"Crowdsec does it best not to break existing setups, and the following rules generally applies : patches ( X.X.Y to X.X.Z ) can be applied blindly and are for bugfixes and backward compatible changes minor ( X.Y.X to X.Z.X ) can be applied blindly but might introduce some features that are not backward compatible major ( Y.X.X to Z.X.X ) must be applied with caution as they might break existing installation Warning We strongly advise you against running crowdsec and LAPI in different versions. When upgrading existing setup, we suggest you to upgrade both crowdsec, cscli and LAPI.","title":"Upgrade notes"},{"location":"getting_started/upgrades.html#upgrades-from-debian-packages-official-or-pragmatic","text":"apt-get update apt-get install crowdsec","title":"Upgrades from debian packages (official or pragmatic)"},{"location":"getting_started/upgrades.html#upgrades-from-release-tarball","text":"","title":"Upgrades from release tarball"},{"location":"getting_started/upgrades.html#patch-upgrade","text":"wizard.sh --binupgrade When doing a minor/patch upgrade (ie. 1.0.0 to 1.0.1 ), the --binupgrade feature should be the more appropriate : It will simply upgrade the existing binaries, letting all configurations untouched.","title":"Patch upgrade"},{"location":"getting_started/upgrades.html#minor-upgrade","text":"wizard.sh --upgrade When doing a minor upgrade (ie. 1.0.4 to 1.1.0 ), the --upgrade feature should be used : It will attempt to migrate and upgrade any existing configurations, include tainted/custom ones. The ambition is to be able to upgrade scenarios, parsers etc to the latest version when relevant, while keeping custom/tainted ones untouched. It's using cscli config backup , creating a directory (usually /tmp/tmp.<random> ) in which it's going to dump all relevant configurations before performing an upgrade : configuration files : acquis.yaml *_credentials.yaml profiles.yaml simulation.yaml config.yaml one directory for parsers , scenarios , postoverflows and collections , where it's going to store both reference to upstream configurations, and your custom/tainted ones It is then going to cleanup crowdsec configuration, /etc/crowdsec/ content (except bouncers configuration), before deploying the new binaries. Once this is done, configuration will be restored from our temp directory using cscli config restore .","title":"Minor upgrade"},{"location":"getting_started/upgrades.html#major-upgrade","text":"For major upgrades (ie. 0.3.X to 1.0.X ), wizard won't do the trick, and you'll have to rely on documentation to do so : Migrating from 0.3.X to 1.0.X : documentation","title":"Major upgrade"},{"location":"getting_started/upgrades.html#manual-operations","text":"cscli config is your friend here, with backup and restore subcommands allowing you to backup and restore all of the configuration files.","title":"Manual operations"},{"location":"getting_started/upgrades.html#upgrading-collectionsparsersscenarios","text":"cscli hub allows you to view, update and upgrade configurations : cscli hub update downloads the latest list of available scenarios/parsers/etc cscli hub list lists all the installed configurations, their versions and status cscli hub upgrade upgrades existing configurations to the latest available version in said list","title":"Upgrading collections/parsers/scenarios"},{"location":"localAPI/index.html","text":"Local API \u00b6 The Local API (LAPI) is a core component of crowdsec-agent and has a few essential missions : Allow crowdsec machines to push alerts & decisions to a database Allow bouncers to consume said alerts & decisions from database Allow cscli to view add or delete decisions You can find the swagger documentation here . Authentication \u00b6 There are two kinds of authentication to the local API : Bouncers : they authenticate with a simple API key and can only read decisions Machines : they authenticate with a login&password and can not only read decisions, but create new ones too Bouncers \u00b6 To register a bouncer to your API, you need to run the following command on the server where the API is installed: $ sudo cscli bouncers add testBouncer and keep the generated API token to use it in your Bouncers configuration file. Machines \u00b6 To allow a machine to communicate with the local API, the machine needs to be validated by an administrator of the local API. There are two ways to register a crowdsec to a local API. You can create a machine directly on the API server that will be automatically validated by running the following command on the server where the API is installed: $ sudo cscli machines add testMachine If your crowdsec runs on the same server as the local API, then your credentials file will be generated automatically, otherwise you will have to copy/paste them in your remote crowdsec credentials file ( /etc/crowdsec/local_api_credentials.yaml ) You can use cscli to register to the API server: sudo cscli lapi register -u <api_url> And validate it with cscli on the server where the API is installed: sudo cscli machines validate <machineName> Tips You can use cscli machines list to list all the machines registered to the API and view the ones that are not validated yet. Configuration \u00b6 Client \u00b6 By default, crowdsec and cscli use 127.0.0.1:8080 as the default local API. However you might want to use a remote API and configure a different endpoint for your api client. Register to a remote API server \u00b6 On the remote crowdsec server, run: $ sudo cscli lapi register -u http://<remote_api>:<port> On the local API server, validate the machine by running the command: $ sudo cscli machines list # to get the name of the new registered machine $ sudo cscli machines validate <machineName> Server \u00b6 Configure listen URL \u00b6 If you would like your local API to be used by a remote crowdsec you will need to modify the URL it listens on. Modify the listen_uri option in the main configuration file. Then see how to configure your crowdsec to use a remote API . Enable SSL \u00b6 The most common use case of the local API is to listen on 127.0.0.1. In that case there's no need for configuring any ssl layer. In some cases, the local API will listen for other crowdsec installations that will report their triggered scenarios. In that case the endpoint may be configured with ssl. You can see how to configure SSL on your local API here . See the Local API public documentation .","title":"Introduction"},{"location":"localAPI/index.html#local-api","text":"The Local API (LAPI) is a core component of crowdsec-agent and has a few essential missions : Allow crowdsec machines to push alerts & decisions to a database Allow bouncers to consume said alerts & decisions from database Allow cscli to view add or delete decisions You can find the swagger documentation here .","title":"Local API"},{"location":"localAPI/index.html#authentication","text":"There are two kinds of authentication to the local API : Bouncers : they authenticate with a simple API key and can only read decisions Machines : they authenticate with a login&password and can not only read decisions, but create new ones too","title":"Authentication"},{"location":"localAPI/index.html#bouncers","text":"To register a bouncer to your API, you need to run the following command on the server where the API is installed: $ sudo cscli bouncers add testBouncer and keep the generated API token to use it in your Bouncers configuration file.","title":"Bouncers"},{"location":"localAPI/index.html#machines","text":"To allow a machine to communicate with the local API, the machine needs to be validated by an administrator of the local API. There are two ways to register a crowdsec to a local API. You can create a machine directly on the API server that will be automatically validated by running the following command on the server where the API is installed: $ sudo cscli machines add testMachine If your crowdsec runs on the same server as the local API, then your credentials file will be generated automatically, otherwise you will have to copy/paste them in your remote crowdsec credentials file ( /etc/crowdsec/local_api_credentials.yaml ) You can use cscli to register to the API server: sudo cscli lapi register -u <api_url> And validate it with cscli on the server where the API is installed: sudo cscli machines validate <machineName> Tips You can use cscli machines list to list all the machines registered to the API and view the ones that are not validated yet.","title":"Machines"},{"location":"localAPI/index.html#configuration","text":"","title":"Configuration"},{"location":"localAPI/index.html#client","text":"By default, crowdsec and cscli use 127.0.0.1:8080 as the default local API. However you might want to use a remote API and configure a different endpoint for your api client.","title":"Client"},{"location":"localAPI/index.html#register-to-a-remote-api-server","text":"On the remote crowdsec server, run: $ sudo cscli lapi register -u http://<remote_api>:<port> On the local API server, validate the machine by running the command: $ sudo cscli machines list # to get the name of the new registered machine $ sudo cscli machines validate <machineName>","title":"Register to a remote API server"},{"location":"localAPI/index.html#server","text":"","title":"Server"},{"location":"localAPI/index.html#configure-listen-url","text":"If you would like your local API to be used by a remote crowdsec you will need to modify the URL it listens on. Modify the listen_uri option in the main configuration file. Then see how to configure your crowdsec to use a remote API .","title":"Configure listen URL"},{"location":"localAPI/index.html#enable-ssl","text":"The most common use case of the local API is to listen on 127.0.0.1. In that case there's no need for configuring any ssl layer. In some cases, the local API will listen for other crowdsec installations that will report their triggered scenarios. In that case the endpoint may be configured with ssl. You can see how to configure SSL on your local API here . See the Local API public documentation .","title":"Enable SSL"},{"location":"localAPI/howto.html","text":"Info This page explains how to interact with the local API exposed by crowdsec. It's meant to be useful for system administrators, or users that want to create their own bouncers. Introduction \u00b6 This documentation only covers the API usage from the bouncer POV : Authentication via API token (rather than JWT as crowdsec/cscli) Reading decisions This guide will assume that you already have crowdsec running locally. Authentication \u00b6 Existing tokens can be viewed with cscli bouncers list : # cscli bouncers list ------------------------------------------------------------------------------------------- NAME IP ADDRESS VALID LAST API PULL TYPE VERSION ------------------------------------------------------------------------------------------- cs-firewall-bouncer-hPrueCas \u2714\ufe0f 2021-02-25T19:54:46+01:00 ------------------------------------------------------------------------------------------- Let's create a new token with cscli bouncers add MyTestClient : # cscli bouncers add MyTestClient Api key for 'MyTestClient': 837be58e22a28738066de1be8f53636b Please keep this key since you will not be able to retrive it! This is the token that we will use to authenticate with the API : \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" -I localhost:8080/v1/decisions HTTP/1.1 200 OK Content-Type: text/plain ; charset = utf-8 Date: Fri, 26 Feb 2021 12 :35:37 GMT Note: if the token is missing or incorrect, you will get a 403 answer. API Usage \u00b6 As stated in the swagger documentation , bouncer's method are restricted to the /decisions path. They allow to query the local decisions in two modes : stream mode : Intended for bouncers that will - on a regular basis - query the local api for new and expired/decisions query mode : Intended for bouncers that want to query the local api about a specific ip/range/username etc. Query Mode \u00b6 To have some data to query for, let's add two decisions to our local API \u25b6 sudo cscli decisions add -i 1 .2.3.4 INFO [ 0000 ] Decision successfully added \u25b6 sudo cscli decisions add -r 2 .2.3.0/24 INFO [ 0000 ] Decision successfully added \u25b6 sudo cscli decisions list +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | 2337 | cscli | Range:2.2.3.0/24 | manual 'ban' from | ban | | | 1 | 3h59m18.079301785s | 1164 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2336 | cscli | Ip:1.2.3.4 | manual 'ban' from | ban | | | 1 | 3h59m11.079297437s | 1163 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ Query mode : IP \u00b6 We can now try to query the API : Query a single banned IP \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? ip = 1 .2.3.4 [{ \"duration\" : \"3h51m57.363171728s\" , \"id\" :2336, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"1.2.3.4\" }] Query a single IP \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? ip = 1 .2.3.5 null Query an IP contained in an existing ban \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? ip \\= 2 .2.3.42 [{ \"duration\" : \"3h38m32.349736035s\" , \"id\" :2337, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Range\" , \"type\" : \"ban\" , \"value\" : \"2.2.3.0/24\" }] note: notice that the decision returned is the range that we banned earlier and that contains query ip Query mode : Range \u00b6 Query a range in which one of the ban is contained \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? range = 1 .2.3.0/24 \\& contains \\= false [{ \"duration\" : \"3h48m7.676653651s\" , \"id\" :2336, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"1.2.3.4\" }] note: notice the contains flag that is set to false \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? range = 1 .2.3.0/24 \\& contains \\= true null Query a range which is contained by an existing ban \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? range \\= 2 .2.3.1/25 [{ \"duration\" : \"3h30m24.773063133s\" , \"id\" :2337, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Range\" , \"type\" : \"ban\" , \"value\" : \"2.2.3.0/24\" }] Query mode : non IP centric decisions \u00b6 While most people will use crowdsec to ban IPs or ranges, decisions can target other scopes and other decisions : \u25b6 sudo cscli decisions add --scope username --value myuser --type enforce_mfa INFO [ 0000 ] Decision successfully added \u25b6 sudo cscli decisions list +------+--------+------------------+----------------------------------------------------+-------------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +------+--------+------------------+----------------------------------------------------+-------------+---------+----+--------+--------------------+----------+ | 2338 | cscli | username:myuser | manual 'enforce_mfa' from | enforce_mfa | | | 1 | 3h59m55.384975175s | 1165 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2337 | cscli | Range:2.2.3.0/24 | manual 'ban' from | ban | | | 1 | 3h27m1.384972861s | 1164 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2336 | cscli | Ip:1.2.3.4 | manual 'ban' from | ban | | | 1 | 3h26m54.384971268s | 1163 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | +------+--------+------------------+----------------------------------------------------+-------------+---------+----+--------+--------------------+----------+ Query a decision on a given user \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? scope \\= username \\& value \\= myuser [{ \"duration\" : \"3h57m59.021170481s\" , \"id\" :2338, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'enforce_mfa' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"username\" , \"type\" : \"enforce_mfa\" , \"value\" : \"myuser\" }] Query a decision on a given user \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? scope \\= username \\& value \\= myuser [{ \"duration\" : \"3h57m59.021170481s\" , \"id\" :2338, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'enforce_mfa' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"username\" , \"type\" : \"enforce_mfa\" , \"value\" : \"myuser\" }] Query all decisions of a given type \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? type \\= enforce_mfa [{ \"duration\" : \"3h57m21.050290118s\" , \"id\" :2338, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'enforce_mfa' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"username\" , \"type\" : \"enforce_mfa\" , \"value\" : \"myuser\" }] Stream mode \u00b6 The \"streaming mode\" of the API (which is actually more like polling) allows for bouncers that are going to fetch on a regular basis an update of the existing decisions. The endpoint is /decisions/stream with a single startup (boolean) argument. The argument allows to indicate if the bouncer wants the full state of decisions, or only an update since it last pulled. Given the our state looks like : \u25b6 sudo cscli decisions list +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | 2337 | cscli | Range:2.2.3.0/24 | manual 'ban' from | ban | | | 1 | 2h55m26.05271136s | 1164 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2336 | cscli | Ip:1.2.3.4 | manual 'ban' from | ban | | | 1 | 2h55m19.052706441s | 1163 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ The first call to /decisions/stream will look like : \u25b6 curl -s -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions/stream \\? startup \\= true | jq . { \"deleted\" : [ { \"duration\" : \"-18897h25m52.809576151s\" , \"id\" : 1 , \"origin\" : \"crowdsec\" , \"scenario\" : \"crowdsecurity/http-probing\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"123.206.50.249\" } , ... ] , \"new\" : [ { \"duration\" : \"22h20m11.909761348s\" , \"id\" : 2266 , \"origin\" : \"CAPI\" , \"scenario\" : \"crowdsecurity/http-sensitive-files\" , \"scope\" : \"ip\" , \"type\" : \"ban\" , \"value\" : \"91.241.19.122/32\" } , ... ] } note: the initial state will contained passed deleted events (to account for crashes/services restart for example), and the current decisions, both local and those fed from the central API Info You might notice that even you are requesting for the initial state, you receive a lot of \"deleted\" decisions. This is intended to allow you to easily restart the local API without having a desynchronized state with the bouncers. \u25b6 curl -s -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions/stream \\? startup \\= false | jq . { \"deleted\" : null, \"new\" : null } note: Calling the decisions/stream just after will lead to empty results, as no decisions have been added or deleted Let's now add a new decision : \u25b6 sudo cscli decisions add -i 3 .3.3.4 INFO [ 0000 ] Decision successfully added And call our endpoint again : \u25b6 curl -s -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions/stream \\? startup \\= false | jq . { \"deleted\" : null, \"new\" : [ { \"duration\" : \"3h59m57.641708614s\" , \"id\" : 2410 , \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"3.3.3.4\" } ] }","title":"API Guide"},{"location":"localAPI/howto.html#introduction","text":"This documentation only covers the API usage from the bouncer POV : Authentication via API token (rather than JWT as crowdsec/cscli) Reading decisions This guide will assume that you already have crowdsec running locally.","title":"Introduction"},{"location":"localAPI/howto.html#authentication","text":"Existing tokens can be viewed with cscli bouncers list : # cscli bouncers list ------------------------------------------------------------------------------------------- NAME IP ADDRESS VALID LAST API PULL TYPE VERSION ------------------------------------------------------------------------------------------- cs-firewall-bouncer-hPrueCas \u2714\ufe0f 2021-02-25T19:54:46+01:00 ------------------------------------------------------------------------------------------- Let's create a new token with cscli bouncers add MyTestClient : # cscli bouncers add MyTestClient Api key for 'MyTestClient': 837be58e22a28738066de1be8f53636b Please keep this key since you will not be able to retrive it! This is the token that we will use to authenticate with the API : \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" -I localhost:8080/v1/decisions HTTP/1.1 200 OK Content-Type: text/plain ; charset = utf-8 Date: Fri, 26 Feb 2021 12 :35:37 GMT Note: if the token is missing or incorrect, you will get a 403 answer.","title":"Authentication"},{"location":"localAPI/howto.html#api-usage","text":"As stated in the swagger documentation , bouncer's method are restricted to the /decisions path. They allow to query the local decisions in two modes : stream mode : Intended for bouncers that will - on a regular basis - query the local api for new and expired/decisions query mode : Intended for bouncers that want to query the local api about a specific ip/range/username etc.","title":"API Usage"},{"location":"localAPI/howto.html#query-mode","text":"To have some data to query for, let's add two decisions to our local API \u25b6 sudo cscli decisions add -i 1 .2.3.4 INFO [ 0000 ] Decision successfully added \u25b6 sudo cscli decisions add -r 2 .2.3.0/24 INFO [ 0000 ] Decision successfully added \u25b6 sudo cscli decisions list +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | 2337 | cscli | Range:2.2.3.0/24 | manual 'ban' from | ban | | | 1 | 3h59m18.079301785s | 1164 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2336 | cscli | Ip:1.2.3.4 | manual 'ban' from | ban | | | 1 | 3h59m11.079297437s | 1163 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+","title":"Query Mode"},{"location":"localAPI/howto.html#query-mode-ip","text":"We can now try to query the API : Query a single banned IP \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? ip = 1 .2.3.4 [{ \"duration\" : \"3h51m57.363171728s\" , \"id\" :2336, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"1.2.3.4\" }] Query a single IP \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? ip = 1 .2.3.5 null Query an IP contained in an existing ban \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? ip \\= 2 .2.3.42 [{ \"duration\" : \"3h38m32.349736035s\" , \"id\" :2337, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Range\" , \"type\" : \"ban\" , \"value\" : \"2.2.3.0/24\" }] note: notice that the decision returned is the range that we banned earlier and that contains query ip","title":"Query mode : IP"},{"location":"localAPI/howto.html#query-mode-range","text":"Query a range in which one of the ban is contained \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? range = 1 .2.3.0/24 \\& contains \\= false [{ \"duration\" : \"3h48m7.676653651s\" , \"id\" :2336, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"1.2.3.4\" }] note: notice the contains flag that is set to false \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? range = 1 .2.3.0/24 \\& contains \\= true null Query a range which is contained by an existing ban \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? range \\= 2 .2.3.1/25 [{ \"duration\" : \"3h30m24.773063133s\" , \"id\" :2337, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Range\" , \"type\" : \"ban\" , \"value\" : \"2.2.3.0/24\" }]","title":"Query mode : Range"},{"location":"localAPI/howto.html#query-mode-non-ip-centric-decisions","text":"While most people will use crowdsec to ban IPs or ranges, decisions can target other scopes and other decisions : \u25b6 sudo cscli decisions add --scope username --value myuser --type enforce_mfa INFO [ 0000 ] Decision successfully added \u25b6 sudo cscli decisions list +------+--------+------------------+----------------------------------------------------+-------------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +------+--------+------------------+----------------------------------------------------+-------------+---------+----+--------+--------------------+----------+ | 2338 | cscli | username:myuser | manual 'enforce_mfa' from | enforce_mfa | | | 1 | 3h59m55.384975175s | 1165 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2337 | cscli | Range:2.2.3.0/24 | manual 'ban' from | ban | | | 1 | 3h27m1.384972861s | 1164 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2336 | cscli | Ip:1.2.3.4 | manual 'ban' from | ban | | | 1 | 3h26m54.384971268s | 1163 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | +------+--------+------------------+----------------------------------------------------+-------------+---------+----+--------+--------------------+----------+ Query a decision on a given user \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? scope \\= username \\& value \\= myuser [{ \"duration\" : \"3h57m59.021170481s\" , \"id\" :2338, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'enforce_mfa' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"username\" , \"type\" : \"enforce_mfa\" , \"value\" : \"myuser\" }] Query a decision on a given user \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? scope \\= username \\& value \\= myuser [{ \"duration\" : \"3h57m59.021170481s\" , \"id\" :2338, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'enforce_mfa' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"username\" , \"type\" : \"enforce_mfa\" , \"value\" : \"myuser\" }] Query all decisions of a given type \u25b6 curl -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions \\? type \\= enforce_mfa [{ \"duration\" : \"3h57m21.050290118s\" , \"id\" :2338, \"origin\" : \"cscli\" , \"scenario\" : \"manual 'enforce_mfa' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"username\" , \"type\" : \"enforce_mfa\" , \"value\" : \"myuser\" }]","title":"Query mode : non IP centric decisions"},{"location":"localAPI/howto.html#stream-mode","text":"The \"streaming mode\" of the API (which is actually more like polling) allows for bouncers that are going to fetch on a regular basis an update of the existing decisions. The endpoint is /decisions/stream with a single startup (boolean) argument. The argument allows to indicate if the bouncer wants the full state of decisions, or only an update since it last pulled. Given the our state looks like : \u25b6 sudo cscli decisions list +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ | 2337 | cscli | Range:2.2.3.0/24 | manual 'ban' from | ban | | | 1 | 2h55m26.05271136s | 1164 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | | 2336 | cscli | Ip:1.2.3.4 | manual 'ban' from | ban | | | 1 | 2h55m19.052706441s | 1163 | | | | | '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA' | | | | | | | +------+--------+------------------+----------------------------------------------------+--------+---------+----+--------+--------------------+----------+ The first call to /decisions/stream will look like : \u25b6 curl -s -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions/stream \\? startup \\= true | jq . { \"deleted\" : [ { \"duration\" : \"-18897h25m52.809576151s\" , \"id\" : 1 , \"origin\" : \"crowdsec\" , \"scenario\" : \"crowdsecurity/http-probing\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"123.206.50.249\" } , ... ] , \"new\" : [ { \"duration\" : \"22h20m11.909761348s\" , \"id\" : 2266 , \"origin\" : \"CAPI\" , \"scenario\" : \"crowdsecurity/http-sensitive-files\" , \"scope\" : \"ip\" , \"type\" : \"ban\" , \"value\" : \"91.241.19.122/32\" } , ... ] } note: the initial state will contained passed deleted events (to account for crashes/services restart for example), and the current decisions, both local and those fed from the central API Info You might notice that even you are requesting for the initial state, you receive a lot of \"deleted\" decisions. This is intended to allow you to easily restart the local API without having a desynchronized state with the bouncers. \u25b6 curl -s -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions/stream \\? startup \\= false | jq . { \"deleted\" : null, \"new\" : null } note: Calling the decisions/stream just after will lead to empty results, as no decisions have been added or deleted Let's now add a new decision : \u25b6 sudo cscli decisions add -i 3 .3.3.4 INFO [ 0000 ] Decision successfully added And call our endpoint again : \u25b6 curl -s -H \"X-Api-Key: 837be58e22a28738066de1be8f53636b\" http://localhost:8080/v1/decisions/stream \\? startup \\= false | jq . { \"deleted\" : null, \"new\" : [ { \"duration\" : \"3h59m57.641708614s\" , \"id\" : 2410 , \"origin\" : \"cscli\" , \"scenario\" : \"manual 'ban' from '939972095cf1459c8b22cc608eff85daEb4yoi2wiTD7Y3fA'\" , \"scope\" : \"Ip\" , \"type\" : \"ban\" , \"value\" : \"3.3.3.4\" } ] }","title":"Stream mode"},{"location":"observability/command_line.html","text":"sudo cscli metrics This command provides an overview of crowdsec-agent statistics provided by prometheus client . By default it assumes that the crowdsec-agent is installed on the same machine. The metrics are split in 3 main sections : Acquisition metrics : How many lines were read from which sources, how many were successfully or unsuccessfully parsed, and how many of those lines ultimately ended up being poured to a bucket. Parser metrics : How many lines were fed (eligible) to each parser, and how many of those were successfully or unsuccessfully parsed. Bucket metrics : How many time each scenario lead to a bucket instantiation, and for each of those : how many times it overflowed how many times it expired (underflows) how many subsequent events were poured to said bucket Hint These metrics should help you identify potential configuration errors. For example, if you have a source that has mostly unparsed logs, you might be missing some parsers. As well, if you have scenarios that are never instantiated, it might be a hint that they are not relevant to your configuration. Furthermore, you might see parsers called child-<parser_name> while calling cscli metrics . This correspond to all nodes belonging to a parser. Their metrics (HITS, PARSED, UNPARSED) are gather by default. If you want to identify metrics for a specific parser node, you just have to set a name for this node in your parser configuration. Warning When viewing those metrics, keep in mind that crowdsec will only parse log lines that are relevant to scenarios. For example, sshd-logs parser only parses fail authentication logs, and will let successful login lines (and other logs) unparsed. cscli metrics example $ sudo cscli metrics INFO [ 0000 ] Buckets Metrics: +--------------------------------------+---------------+-----------+--------------+--------+---------+ | BUCKET | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +--------------------------------------+---------------+-----------+--------------+--------+---------+ | crowdsecurity/http-bad-user-agent | - | - | 10 | 10 | 10 | | crowdsecurity/http-crawl-non_statics | - | - | 91 | 119 | 91 | | crowdsecurity/http-probing | - | - | 2 | 2 | 2 | | crowdsecurity/http-sensitive-files | - | - | 1 | 1 | 1 | | crowdsecurity/ssh-bf | 13 | 6314 | 8768 | 46772 | 2441 | | crowdsecurity/ssh-bf_user-enum | 6 | - | 7646 | 14406 | 7640 | +--------------------------------------+---------------+-----------+--------------+--------+---------+ INFO [ 0000 ] Acquisition Metrics: +---------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +---------------------------+------------+--------------+----------------+------------------------+ | /var/log/auth.log | 105476 | 46772 | 58704 | 61178 | | /var/log/messages | 2 | - | 2 | - | | /var/log/nginx/access.log | 138 | 111 | 27 | 100 | | /var/log/nginx/error.log | 312 | 68 | 244 | 32 | | /var/log/syslog | 31919 | - | 31919 | - | +---------------------------+------------+--------------+----------------+------------------------+ INFO [ 0000 ] Parser Metrics: +--------------------------------+--------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +--------------------------------+--------+--------+----------+ | child-crowdsecurity/http-logs | 537 | 257 | 280 | | child-crowdsecurity/nginx-logs | 789 | 179 | 610 | | child-crowdsecurity/sshd-logs | 436048 | 46772 | 389276 | | crowdsecurity/dateparse-enrich | 46951 | 46951 | - | | crowdsecurity/geoip-enrich | 46883 | 46883 | - | | crowdsecurity/http-logs | 179 | 66 | 113 | | crowdsecurity/nginx-logs | 450 | 179 | 271 | | crowdsecurity/non-syslog | 450 | 450 | - | | crowdsecurity/sshd-logs | 104386 | 46772 | 57614 | | crowdsecurity/syslog-logs | 137397 | 137395 | 2 | | crowdsecurity/whitelists | 46951 | 46951 | - | +--------------------------------+--------+--------+----------+ INFO [ 0000 ] Local Api Metrics: +----------------------+--------+------+ | ROUTE | METHOD | HITS | +----------------------+--------+------+ | /v1/alerts | GET | 4 | | /v1/alerts | POST | 5400 | | /v1/decisions/stream | GET | 7694 | | /v1/watchers/login | POST | 27 | +----------------------+--------+------+ INFO [ 0000 ] Local Api Machines Metrics: +----------------------------------+------------+--------+------+ | MACHINE | ROUTE | METHOD | HITS | +----------------------------------+------------+--------+------+ | 7f0607a3469243139699bf2f30321fc4 | /v1/alerts | GET | 4 | | 7f0607a3469243139699bf2f30321fc4 | /v1/alerts | POST | 5400 | +----------------------------------+------------+--------+------+ INFO [ 0000 ] Local Api Bouncers Metrics: +------------------------------+----------------------+--------+------+ | BOUNCER | ROUTE | METHOD | HITS | +------------------------------+----------------------+--------+------+ | cs-firewall-bouncer-n3W19Qua | /v1/decisions/stream | GET | 7694 | +------------------------------+----------------------+--------+------+","title":"Command line"},{"location":"observability/dashboard.html","text":"MySQL & PostgreSQL MySQL and PostgreSQL are currently not supported by cscli dashboard . It means that you can run cscli dashboard only if you use SQLite (default) as storage database with your local API. The cscli command cscli dashboard setup will use docker to install metabase docker image and fetch our metabase template to have a configured and ready dashboard. Protip If you use podman instead of docker and want to install the crowdsec dashboard, you need to run: sudo ln -s /var/run/podman/podman.sock /var/run/docker.sock Then you can setup the dashboard with sudo cscli dashboard setup Setup \u00b6 Setup and Start crowdsec metabase dashboard sudo cscli dashboard setup Optional arguments: -l | --listen : ip address to listen on for docker (default is 127.0.0.1 ) -p | --port : port to listen on for docker (default is 8080 ) --password : password for metabase user (default is generated randomly) -f | --force : override existing setup cscli dashboard setup INFO [ 0000 ] Pulling docker image metabase/metabase ........... INFO [ 0002 ] creating container '/crowdsec-metabase' INFO [ 0002 ] Waiting for metabase API to be up ( can take up to a minute ) .............. INFO [ 0051 ] Metabase is ready URL : 'http://127.0.0.1:3000' username : 'crowdsec@crowdsec.net' password : '<RANDOM_PASSWORD>' Protip the dashboard setup command will output generated credentials for metabase. Those are stored in /etc/crowdsec/metabase/metabase.yaml Now you can connect to your dashboard, sign-in with your saved credentials then click on Crowdsec-agent Dashboard to get this: Dashboard docker image can be managed by cscli and docker cli also. Look at the cscli help command using sudo cscli dashboard -h Remove the dashboard \u00b6 Remove crowdsec metabase dashboard sudo cscli dashboard remove [ -f ] Optional arguments: -f | --force : will force remove the dashboard Stop the dashboard \u00b6 Stop crowdsec metabase dashboard sudo cscli dashboard stop Start the dashboard \u00b6 Start crowdsec metabase dashboard sudo cscli dashboard start Note: Please look at this documentation for those of you that would like to deploy metabase without using docker.","title":"Dashboard"},{"location":"observability/dashboard.html#setup","text":"Setup and Start crowdsec metabase dashboard sudo cscli dashboard setup Optional arguments: -l | --listen : ip address to listen on for docker (default is 127.0.0.1 ) -p | --port : port to listen on for docker (default is 8080 ) --password : password for metabase user (default is generated randomly) -f | --force : override existing setup cscli dashboard setup INFO [ 0000 ] Pulling docker image metabase/metabase ........... INFO [ 0002 ] creating container '/crowdsec-metabase' INFO [ 0002 ] Waiting for metabase API to be up ( can take up to a minute ) .............. INFO [ 0051 ] Metabase is ready URL : 'http://127.0.0.1:3000' username : 'crowdsec@crowdsec.net' password : '<RANDOM_PASSWORD>' Protip the dashboard setup command will output generated credentials for metabase. Those are stored in /etc/crowdsec/metabase/metabase.yaml Now you can connect to your dashboard, sign-in with your saved credentials then click on Crowdsec-agent Dashboard to get this: Dashboard docker image can be managed by cscli and docker cli also. Look at the cscli help command using sudo cscli dashboard -h","title":"Setup"},{"location":"observability/dashboard.html#remove-the-dashboard","text":"Remove crowdsec metabase dashboard sudo cscli dashboard remove [ -f ] Optional arguments: -f | --force : will force remove the dashboard","title":"Remove the dashboard"},{"location":"observability/dashboard.html#stop-the-dashboard","text":"Stop crowdsec metabase dashboard sudo cscli dashboard stop","title":"Stop the dashboard"},{"location":"observability/dashboard.html#start-the-dashboard","text":"Start crowdsec metabase dashboard sudo cscli dashboard start Note: Please look at this documentation for those of you that would like to deploy metabase without using docker.","title":"Start the dashboard"},{"location":"observability/logs.html","text":"Logs concern everything that happens to Crowdsec-agent itself (startup, configuration, events like IP ban or an alert, shutdown, and so on). By default, logs are written to /var/log/crowdsec.log , in text format. Logs example time = \"12-05-2020 15:34:21\" level = info msg = \"setting loglevel to info\" time = \"12-05-2020 15:34:21\" level = info msg = \"Crowdsec v0.0.19-9ae496aa9cfd008513976a096accc7cfc43f2d9b\" time = \"12-05-2020 15:34:21\" level = warning msg = \"Loading prometheus collectors\" time = \"12-05-2020 15:34:23\" level = warning msg = \"no version in /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml, assuming '1.0'\" time = \"12-05-2020 15:34:23\" level = warning msg = \"Starting profiling and http server\" time = \"12-05-2020 15:34:24\" level = warning msg = \"no version in /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml, assuming '1.0'\" time = \"12-05-2020 15:34:24\" level = info msg = \"Node has no name,author or description. Skipping.\" time = \"12-05-2020 15:34:24\" level = info msg = \"Loading 2 parser nodes\" file = /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml time = \"12-05-2020 15:34:24\" level = warning msg = \"no version in /etc/crowdsec/parsers/s01-parse/nginx-logs.yaml, assuming '1.0'\" time = \"12-05-2020 15:34:24\" level = info msg = \"Loading 3 parser nodes\" file = /etc/crowdsec/parsers/s01-parse/nginx-logs.yaml time = \"12-05-2020 15:34:24\" level = warning msg = \"no version in /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml, assuming '1.0'\" time = \"13-05-2020 17:42:53\" level = warning msg = \"24 existing LeakyRoutine\" time = \"13-05-2020 18:02:51\" level = info msg = \"Flushed 1 expired entries from Ban Application\" time = \"13-05-2020 18:12:46\" level = info msg = \"Flushed 1 expired entries from Ban Application\" time = \"13-05-2020 18:20:29\" level = warning msg = \"11.11.11.11 triggered a 4h0m0s ip ban remediation for [crowdsecurity/ssh-bf]\" bucket_id = winter-shadow event_time = \"2020-05-13 18:20:29.855776892 +0200 CEST m=+96112.558589990\" scenario = crowdsecurity/ssh-bf source_ip = 11 .11.11.11 time = \"13-05-2020 18:31:26\" level = warning msg = \"22.22.22.22 triggered a 4h0m0s ip ban remediation for [crowdsecurity/ssh-bf]\" bucket_id = dry-mountain event_time = \"2020-05-13 18:31:26.989769738 +0200 CEST m=+96769.692582872\" scenario = crowdsecurity/ssh-bf source_ip = 22 .22.22.22 time = \"13-05-2020 18:41:10\" level = warning msg = \"16 existing LeakyRoutine\" time = \"13-05-2020 18:46:19\" level = warning msg = \"33.33.33.33 triggered a 4h0m0s ip ban remediation for [crowdsecurity/iptables-scan-multi_ports]\" bucket_id = holy-paper event_time = \"2020-05-13 18:46:19.825693323 +0200 CEST m=+97662.528506421\" scenario = crowdsecurity/iptables-scan-multi_ports source_ip = 33 .33.33.33","title":"Logs"},{"location":"observability/overview.html","text":"Observability Overview \u00b6 Observability in security software is crucial, especially when this software might take important decision such as blocking IP addresses. We attempt to provide good observability of crowdsec-agent's behavior : crowdsec-agent itself exposes a prometheus instrumentation Cscli allows you to view part of prometheus metrics in cli ( cscli metrics ) crowdsec-agent logging is contextualized for easy processing for humans , cscli allows you to trivially start a service exposing dashboards (using metabase ) Furthermore, most of crowdsec-agent configuration should allow you to enable partial debug (ie. per-scenario, per-parser etc.)","title":"Overview"},{"location":"observability/overview.html#observability-overview","text":"Observability in security software is crucial, especially when this software might take important decision such as blocking IP addresses. We attempt to provide good observability of crowdsec-agent's behavior : crowdsec-agent itself exposes a prometheus instrumentation Cscli allows you to view part of prometheus metrics in cli ( cscli metrics ) crowdsec-agent logging is contextualized for easy processing for humans , cscli allows you to trivially start a service exposing dashboards (using metabase ) Furthermore, most of crowdsec-agent configuration should allow you to enable partial debug (ie. per-scenario, per-parser etc.)","title":"Observability Overview"},{"location":"observability/prometheus.html","text":"crowdsec-agent can expose a prometheus endpoint for collection (on http://127.0.0.1:6060/metrics by default). The goal of this endpoint, besides the usual resources consumption monitoring, aims at offering a view of crowdsec-agent \"applicative\" behavior : is it processing a lot of logs ? is it parsing them successfully ? are a lot of scenarios being triggered ? are a lot of IPs banned ? etc. All the counters are \"since crowdsec-agent start\". Metrics details \u00b6 Scenarios \u00b6 cs_buckets : number of scenario that currently exist cs_bucket_created_total : total number of instantiation of each scenario cs_bucket_overflowed_total : total number of overflow of each scenario cs_bucket_underflowed_total : total number of underflow of each scenario (bucket was created but expired because of lack of events) cs_bucket_poured_total : total number of event poured to each scenario with source as complementary key example #2030 lines from `/var/log/nginx/access.log` were poured to `crowdsecurity/http-scan-uniques_404` scenario cs_bucket_poured_total{name=\"crowdsecurity/http-scan-uniques_404\",source=\"/var/log/nginx/access.log\"} 2030 Parsers \u00b6 cs_node_hits_total : how many time an event from a specific source was processed by a parser node : example # 235 lines from `auth.log` were processed by the `crowdsecurity/dateparse-enrich` parser cs_node_hits_total{name=\"crowdsecurity/dateparse-enrich\",source=\"/var/log/auth.log\"} 235 cs_node_hits_ko_total : how many times an event from a specific was unsuccessfully parsed by a specific parser example # 2112 lines from `error.log` failed to be parsed by `crowdsecurity/http-logs` cs_node_hits_ko_total{name=\"crowdsecurity/http-logs\",source=\"/var/log/nginx/error.log\"} 2112 cs_node_hits_ok_total : how many times an event from a specific source was successfully parsed by a specific parser cs_parser_hits_total : how many times an event from a source has hit the parser cs_parser_hits_ok_total : how many times an event from a source was successfully parsed cs_parser_hits_ko_total : how many times an event from a source was unsuccessfully parsed Acquisition \u00b6 cs_reader_hits_total : how many events were read from a specific source Local API \u00b6 cs_lapi_route_requests_total : number of calls to each route per method cs_lapi_machine_requests_total : number of calls to each route per method grouped by machines cs_lapi_bouncer_requests_total : number of calls to each route per method grouped by bouncers cs_lapi_decisions_ko_total : number of unsuccessfully responses when bouncers ask for an IP. cs_lapi_decisions_ok_total : number of successfully responses when bouncers ask for an IP. Info \u00b6 cs_info : Information about crowdsec-agent (software version) Exploitation with prometheus server & grafana \u00b6 Those metrics can be scaped by prometheus server and visualized with grafana . They can be downloaded here :","title":"Prometheus"},{"location":"observability/prometheus.html#metrics-details","text":"","title":"Metrics details"},{"location":"observability/prometheus.html#scenarios","text":"cs_buckets : number of scenario that currently exist cs_bucket_created_total : total number of instantiation of each scenario cs_bucket_overflowed_total : total number of overflow of each scenario cs_bucket_underflowed_total : total number of underflow of each scenario (bucket was created but expired because of lack of events) cs_bucket_poured_total : total number of event poured to each scenario with source as complementary key example #2030 lines from `/var/log/nginx/access.log` were poured to `crowdsecurity/http-scan-uniques_404` scenario cs_bucket_poured_total{name=\"crowdsecurity/http-scan-uniques_404\",source=\"/var/log/nginx/access.log\"} 2030","title":"Scenarios"},{"location":"observability/prometheus.html#parsers","text":"cs_node_hits_total : how many time an event from a specific source was processed by a parser node : example # 235 lines from `auth.log` were processed by the `crowdsecurity/dateparse-enrich` parser cs_node_hits_total{name=\"crowdsecurity/dateparse-enrich\",source=\"/var/log/auth.log\"} 235 cs_node_hits_ko_total : how many times an event from a specific was unsuccessfully parsed by a specific parser example # 2112 lines from `error.log` failed to be parsed by `crowdsecurity/http-logs` cs_node_hits_ko_total{name=\"crowdsecurity/http-logs\",source=\"/var/log/nginx/error.log\"} 2112 cs_node_hits_ok_total : how many times an event from a specific source was successfully parsed by a specific parser cs_parser_hits_total : how many times an event from a source has hit the parser cs_parser_hits_ok_total : how many times an event from a source was successfully parsed cs_parser_hits_ko_total : how many times an event from a source was unsuccessfully parsed","title":"Parsers"},{"location":"observability/prometheus.html#acquisition","text":"cs_reader_hits_total : how many events were read from a specific source","title":"Acquisition"},{"location":"observability/prometheus.html#local-api","text":"cs_lapi_route_requests_total : number of calls to each route per method cs_lapi_machine_requests_total : number of calls to each route per method grouped by machines cs_lapi_bouncer_requests_total : number of calls to each route per method grouped by bouncers cs_lapi_decisions_ko_total : number of unsuccessfully responses when bouncers ask for an IP. cs_lapi_decisions_ok_total : number of successfully responses when bouncers ask for an IP.","title":"Local API"},{"location":"observability/prometheus.html#info","text":"cs_info : Information about crowdsec-agent (software version)","title":"Info"},{"location":"observability/prometheus.html#exploitation-with-prometheus-server-grafana","text":"Those metrics can be scaped by prometheus server and visualized with grafana . They can be downloaded here :","title":"Exploitation with prometheus server &amp; grafana"},{"location":"references/acquisition.html","text":"Acquisition format \u00b6 The crowdsec_service section of configuration supports acquisition_path and acquisition_dir (>1.0.7). The default setting is to have acquisition_path pointing to /etc/crowdsec/acquis.yaml . acquisition_dir can be set to point to a directory where every .yaml file is considered as a valid acquisition configuration file. The acquisition file(s) define which source of information (ie. files or journald streams) are read by crowdsec at runtime. The file is a list of object representing groups of files to read, with the following properties. A least one of : filename: a string representing the path to a file (globbing supported) filenames: a list of string represent paths to files (globbing supported) journalctl_filter: a list of string passed as arguments to journalctl And a labels object with a field type indicating the log's type : filenames : - /var/log/nginx/access-*.log - /var/log/nginx/error.log labels : type : nginx --- filenames : - /var/log/auth.log labels : type : syslog --- journalctl_filter : - \"_SYSTEMD_UNIT=ssh.service\" labels : type : syslog The labels.type is important as it is what will determine which parser will try to process the logs. The log won't be processed by the syslog parser if its type is not syslog : $ cat /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml filter: \"evt.Line.Labels.type == 'syslog'\" ... On the other hand, nginx tends to write its own logs without using syslog : $ cat /etc/crowdsec/parsers/s01-parse/nginx-logs.yaml filter: \"evt.Parsed.program startsWith 'nginx'\" ... If for example your nginx was logging via syslog, you need to set its labels.type to syslog so that it's first parsed by the syslog parser, and then by the nginx parser (notice they are in different stages).","title":"Acquisition format"},{"location":"references/acquisition.html#acquisition-format","text":"The crowdsec_service section of configuration supports acquisition_path and acquisition_dir (>1.0.7). The default setting is to have acquisition_path pointing to /etc/crowdsec/acquis.yaml . acquisition_dir can be set to point to a directory where every .yaml file is considered as a valid acquisition configuration file. The acquisition file(s) define which source of information (ie. files or journald streams) are read by crowdsec at runtime. The file is a list of object representing groups of files to read, with the following properties. A least one of : filename: a string representing the path to a file (globbing supported) filenames: a list of string represent paths to files (globbing supported) journalctl_filter: a list of string passed as arguments to journalctl And a labels object with a field type indicating the log's type : filenames : - /var/log/nginx/access-*.log - /var/log/nginx/error.log labels : type : nginx --- filenames : - /var/log/auth.log labels : type : syslog --- journalctl_filter : - \"_SYSTEMD_UNIT=ssh.service\" labels : type : syslog The labels.type is important as it is what will determine which parser will try to process the logs. The log won't be processed by the syslog parser if its type is not syslog : $ cat /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml filter: \"evt.Line.Labels.type == 'syslog'\" ... On the other hand, nginx tends to write its own logs without using syslog : $ cat /etc/crowdsec/parsers/s01-parse/nginx-logs.yaml filter: \"evt.Parsed.program startsWith 'nginx'\" ... If for example your nginx was logging via syslog, you need to set its labels.type to syslog so that it's first parsed by the syslog parser, and then by the nginx parser (notice they are in different stages).","title":"Acquisition format"},{"location":"references/alerts.html","text":"Alerts \u00b6 An Alert is the runtime representation of a bucket overflow. The representation of the object can be found here : Alert object documentation","title":"Alert object"},{"location":"references/alerts.html#alerts","text":"An Alert is the runtime representation of a bucket overflow. The representation of the object can be found here : Alert object documentation","title":"Alerts"},{"location":"references/collections.html","text":"Collections \u00b6 Collections are bundle of parsers, scenarios, postoverflows that form a coherent package. Collections are present in /etc/crowdsec/collections/ and follow this format : /etc/crowdsec/collections/linux.yaml #the list of parsers it contains parsers : - crowdsecurity/syslog-logs - crowdsecurity/geoip-enrich - crowdsecurity/dateparse-enrich #the list of collections it contains collections : - crowdsecurity/sshd # the list of postoverflows it contains # postoverflows: # - crowdsecurity/seo-bots-whitelist # the list of scenarios it contains # scenarios: # - crowdsecurity/http-crawl-non_statics description : \"core linux support : syslog+geoip+ssh\" author : crowdsecurity tags : - linux It mostly exists as a convenience for the user when using the hub.","title":"Collections format"},{"location":"references/collections.html#collections","text":"Collections are bundle of parsers, scenarios, postoverflows that form a coherent package. Collections are present in /etc/crowdsec/collections/ and follow this format : /etc/crowdsec/collections/linux.yaml #the list of parsers it contains parsers : - crowdsecurity/syslog-logs - crowdsecurity/geoip-enrich - crowdsecurity/dateparse-enrich #the list of collections it contains collections : - crowdsecurity/sshd # the list of postoverflows it contains # postoverflows: # - crowdsecurity/seo-bots-whitelist # the list of scenarios it contains # scenarios: # - crowdsecurity/http-crawl-non_statics description : \"core linux support : syslog+geoip+ssh\" author : crowdsecurity tags : - linux It mostly exists as a convenience for the user when using the hub.","title":"Collections"},{"location":"references/crowdsec-config.html","text":"Crowdsec configuration \u00b6 Crowdsec-agent has a main yaml configuration file, usually located in /etc/crowdsec/config.yaml . Configuration example \u00b6 Default configuration common : daemonize : true pid_dir : /var/run/ log_media : file log_level : info log_dir : /var/log/ working_dir : . config_paths : config_dir : /etc/crowdsec/ data_dir : /var/lib/crowdsec/data/ simulation_path : /etc/crowdsec/simulation.yaml hub_dir : /etc/crowdsec/hub/ index_path : /etc/crowdsec/hub/.index.json crowdsec_service : acquisition_path : /etc/crowdsec/acquis.yaml #acquisition_dir: /etc/crowdsec/acquis/ parser_routines : 1 buckets_routines : 1 output_routines : 1 cscli : output : human hub_branch : wip_lapi db_config : log_level : info type : sqlite db_path : /var/lib/crowdsec/data/crowdsec.db #user: #password: #db_name: #host: #port: flush : max_items : 5000 max_age : 7d api : client : insecure_skip_verify : false credentials_path : /etc/crowdsec/local_api_credentials.yaml server : log_level : info listen_uri : 127.0.0.1:8080 profiles_path : /etc/crowdsec/profiles.yaml use_forwarded_for_headers : false online_client : # Crowdsec API credentials_path : /etc/crowdsec/online_api_credentials.yaml # tls: # cert_file: /etc/crowdsec/ssl/cert.pem # key_file: /etc/crowdsec/ssl/key.pem prometheus : enabled : true level : full listen_addr : 127.0.0.1 listen_port : 6060 Environment variable \u00b6 It is possible to set a configuration value based on an enrivonement variables. For example, if you don't want to store your database password in the configuration file, you can do this: db_config : type : mysql user : database_user password : ${DB_PASSWORD} db_name : db_name host : 192.168.0.2 port : 3306 And export the environment variable such as: export DB_PASSWORD = \"<db_password>\" Warning Note : you need to be root or put the environment variable in /etc/environement Configuration format \u00b6 common : daemonize : (true|false) pid_dir : <path_to_pid_folder> log_media : (file|stdout) log_level : (error|info|debug|trace) log_dir : <path_to_log_folder> working_dir : <path_to_working_folder> config_paths : config_dir : <path_to_crowdsec_config_folder> data_dir : <path_to_crowdsec_data_folder> simulation_path : <path_to_simulation_file> hub_dir : <path_to_crowdsec_hub_folder> index_path : <path_to_hub_index_file> crowdsec_service : acquisition_path : <acqusition_file_path> acquisition_dir : <acquisition_dir_path> parser_routines : <number_of_parser_routines> buckets_routines : <number_of_buckets_routines> output_routines : <number_of_output_routines> cscli : output : (human|json|raw) hub_branch : <hub_branch> db_config : type : <db_type> db_path : <path_to_database_file> user : <db_user> # for mysql/pgsql password : <db_password> # for mysql/pgsql db_name : <db_name> # for mysql/pgsql host : <db_host_ip> # for mysql/pgsql port : <db_host_port> # for mysql/pgsql sslmode : <required/disable> # for pgsql flush : max_items : <max_alerts_in_db> max_age : <max_age_of_alerts_in_db> api : client : insecure_skip_verify : (true|false) credentials_path : <path_to_local_api_client_credential_file> server : log_level : (error|info|debug|trace>) listen_uri : <listen_uri> # host:port profiles_path : <path_to_profile_file> use_forwarded_for_headers : <true|false> online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file> prometheus : enabled : (true|false) level : (full|aggregated) listen_addr : <listen_address> listen_port : <listen_port> Configuration directives \u00b6 common \u00b6 common : daemonize : (true|false) pid_dir : <path_to_pid_folder> log_media : (file|stdout) log_level : (error|info|debug|trace) log_dir : <path_to_log_folder> working_dir : <path_to_working_folder> daemonize \u00b6 bool Daemonize or not the crowdsec daemon. pid_dir \u00b6 string Folder to store PID file. log_media \u00b6 string Log media. Can be stdout or file . log_level \u00b6 string Log level. Can be error , info , debug , trace . log_folder \u00b6 string Folder to write log file. Warning Works only with log_media = file . working_dir \u00b6 string Current working directory. config_paths \u00b6 This section contains most paths to various sub configuration items. config_paths : config_dir : <path_to_crowdsec_config_folder> data_dir : <path_to_crowdsec_data_folder> simulation_path : <path_to_simulation_file> hub_dir : <path_to_crowdsec_hub_folder> index_path : <path_to_hub_index_file> config_dir \u00b6 string The main configuration directory of crowdsec. data_dir \u00b6 string This is where crowdsec is going to store data, such as files downloaded by scenarios, geolocalisation database, metabase configuration database, or even SQLite database. simulation_path \u00b6 string The path to the profiles configuration. hub_dir \u00b6 string The directory where cscli will store parsers, scenarios, collections and such. index_path \u00b6 string Tath to the .index.json file downloaded by cscli to know the list of available configurations. crowdsec_service \u00b6 This section is only used by crowdsec agent. crowdsec_service : acquisition_path : <acqusition_file_path> acquisition_dir : <acqusition_dir_path> parser_routines : <number_of_parser_routines> buckets_routines : <number_of_buckets_routines> output_routines : <number_of_output_routines> parser_routines \u00b6 int Number of dedicated goroutines for parsing files. buckets_routines \u00b6 int Number of dedicated goroutines for managing live buckets. output_routines \u00b6 int Number of dedicated goroutines for pushing data to local api. acquisition_path \u00b6 string Path to the yaml file containing logs that needs to be read. acquisition_dir \u00b6 string (>1.0.7) Path to a directory where each yaml is considered as a acquisition configuration file containing logs that needs to be read. cscli \u00b6 This section is only used by cscli . cscli : output : (human|json|raw) hub_branch : <hub_branch> prometheus_uri : <uri> output \u00b6 string The default output format (human, json or raw). hub_branch \u00b6 string The git branch on which cscli is going to fetch configurations. prometheus_uri \u00b6 uri (>1.0.7) An uri (without the trailing /metrics ) that will be used by cscli metrics command, ie. http://127.0.0.1:6060/ db_config \u00b6 Please refer to the database configuration . api \u00b6 The api section is used by both cscli , crowdsec and the local API. api : client : insecure_skip_verify : (true|false) credentials_path : <path_to_local_api_client_credential_file> server : log_level : (error|info|debug|trace>) listen_uri : <listen_uri> # host:port profiles_path : <path_to_profile_file> use_forwarded_for_headers : (true|false) online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file> client \u00b6 The client subsection is used by crowdsec and cscli to read and write decisions to the local API. client : insecure_skip_verify : (true|false) credentials_path : <path_to_local_api_client_credential_file> insecure_skip_verify \u00b6 bool Allows the use of https with self-signed certificates. credentials_path \u00b6 string Path to the credential files (contains API url + login/password). server \u00b6 The server subsection is the local API configuration. server : log_level : (error|info|debug|trace) listen_uri : <listen_uri> # host:port profiles_path : <path_to_profile_file> use_forwarded_for_headers : (true|false) online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file> listen_uri \u00b6 string Address and port listen configuration, the form host:port . profiles_path \u00b6 string The path to the profiles configuration. use_forwarded_for_headers \u00b6 string Allow the usage of X-Forwarded-For or X-Real-IP to get the client IP address. Do not enable if you are not running the LAPI behind a trusted reverse-proxy or LB. online_client \u00b6 Configuration to push signals and receive bad IPs from Crowdsec API. online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> credentials_path \u00b6 string Path to a file containing credentials for the Central API. tls \u00b6 if present, holds paths to certs and key files. tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file> cert_file \u00b6 string Path to certificate file. key_file \u00b6 string Path to certficate key file. prometheus \u00b6 This section is used by local API and crowdsec. prometheus : enabled : (true|false) level : (full|aggregated) listen_addr : <listen_address> listen_port : <listen_port> enabled \u00b6 bool Allows to enable/disable prometheus instrumentation. level \u00b6 string Can be full (all metrics) or aggregated (to allow minimal metrics that will keep cardinality low). listen_addr \u00b6 string Prometheus listen url. listen_port \u00b6 int Prometheus listen port.","title":"Configuration format"},{"location":"references/crowdsec-config.html#crowdsec-configuration","text":"Crowdsec-agent has a main yaml configuration file, usually located in /etc/crowdsec/config.yaml .","title":"Crowdsec configuration"},{"location":"references/crowdsec-config.html#configuration-example","text":"Default configuration common : daemonize : true pid_dir : /var/run/ log_media : file log_level : info log_dir : /var/log/ working_dir : . config_paths : config_dir : /etc/crowdsec/ data_dir : /var/lib/crowdsec/data/ simulation_path : /etc/crowdsec/simulation.yaml hub_dir : /etc/crowdsec/hub/ index_path : /etc/crowdsec/hub/.index.json crowdsec_service : acquisition_path : /etc/crowdsec/acquis.yaml #acquisition_dir: /etc/crowdsec/acquis/ parser_routines : 1 buckets_routines : 1 output_routines : 1 cscli : output : human hub_branch : wip_lapi db_config : log_level : info type : sqlite db_path : /var/lib/crowdsec/data/crowdsec.db #user: #password: #db_name: #host: #port: flush : max_items : 5000 max_age : 7d api : client : insecure_skip_verify : false credentials_path : /etc/crowdsec/local_api_credentials.yaml server : log_level : info listen_uri : 127.0.0.1:8080 profiles_path : /etc/crowdsec/profiles.yaml use_forwarded_for_headers : false online_client : # Crowdsec API credentials_path : /etc/crowdsec/online_api_credentials.yaml # tls: # cert_file: /etc/crowdsec/ssl/cert.pem # key_file: /etc/crowdsec/ssl/key.pem prometheus : enabled : true level : full listen_addr : 127.0.0.1 listen_port : 6060","title":"Configuration example"},{"location":"references/crowdsec-config.html#environment-variable","text":"It is possible to set a configuration value based on an enrivonement variables. For example, if you don't want to store your database password in the configuration file, you can do this: db_config : type : mysql user : database_user password : ${DB_PASSWORD} db_name : db_name host : 192.168.0.2 port : 3306 And export the environment variable such as: export DB_PASSWORD = \"<db_password>\" Warning Note : you need to be root or put the environment variable in /etc/environement","title":"Environment variable"},{"location":"references/crowdsec-config.html#configuration-format","text":"common : daemonize : (true|false) pid_dir : <path_to_pid_folder> log_media : (file|stdout) log_level : (error|info|debug|trace) log_dir : <path_to_log_folder> working_dir : <path_to_working_folder> config_paths : config_dir : <path_to_crowdsec_config_folder> data_dir : <path_to_crowdsec_data_folder> simulation_path : <path_to_simulation_file> hub_dir : <path_to_crowdsec_hub_folder> index_path : <path_to_hub_index_file> crowdsec_service : acquisition_path : <acqusition_file_path> acquisition_dir : <acquisition_dir_path> parser_routines : <number_of_parser_routines> buckets_routines : <number_of_buckets_routines> output_routines : <number_of_output_routines> cscli : output : (human|json|raw) hub_branch : <hub_branch> db_config : type : <db_type> db_path : <path_to_database_file> user : <db_user> # for mysql/pgsql password : <db_password> # for mysql/pgsql db_name : <db_name> # for mysql/pgsql host : <db_host_ip> # for mysql/pgsql port : <db_host_port> # for mysql/pgsql sslmode : <required/disable> # for pgsql flush : max_items : <max_alerts_in_db> max_age : <max_age_of_alerts_in_db> api : client : insecure_skip_verify : (true|false) credentials_path : <path_to_local_api_client_credential_file> server : log_level : (error|info|debug|trace>) listen_uri : <listen_uri> # host:port profiles_path : <path_to_profile_file> use_forwarded_for_headers : <true|false> online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file> prometheus : enabled : (true|false) level : (full|aggregated) listen_addr : <listen_address> listen_port : <listen_port>","title":"Configuration format"},{"location":"references/crowdsec-config.html#configuration-directives","text":"","title":"Configuration directives"},{"location":"references/crowdsec-config.html#common","text":"common : daemonize : (true|false) pid_dir : <path_to_pid_folder> log_media : (file|stdout) log_level : (error|info|debug|trace) log_dir : <path_to_log_folder> working_dir : <path_to_working_folder>","title":"common"},{"location":"references/crowdsec-config.html#daemonize","text":"bool Daemonize or not the crowdsec daemon.","title":"daemonize"},{"location":"references/crowdsec-config.html#pid_dir","text":"string Folder to store PID file.","title":"pid_dir"},{"location":"references/crowdsec-config.html#log_media","text":"string Log media. Can be stdout or file .","title":"log_media"},{"location":"references/crowdsec-config.html#log_level","text":"string Log level. Can be error , info , debug , trace .","title":"log_level"},{"location":"references/crowdsec-config.html#log_folder","text":"string Folder to write log file. Warning Works only with log_media = file .","title":"log_folder"},{"location":"references/crowdsec-config.html#working_dir","text":"string Current working directory.","title":"working_dir"},{"location":"references/crowdsec-config.html#config_paths","text":"This section contains most paths to various sub configuration items. config_paths : config_dir : <path_to_crowdsec_config_folder> data_dir : <path_to_crowdsec_data_folder> simulation_path : <path_to_simulation_file> hub_dir : <path_to_crowdsec_hub_folder> index_path : <path_to_hub_index_file>","title":"config_paths"},{"location":"references/crowdsec-config.html#config_dir","text":"string The main configuration directory of crowdsec.","title":"config_dir"},{"location":"references/crowdsec-config.html#data_dir","text":"string This is where crowdsec is going to store data, such as files downloaded by scenarios, geolocalisation database, metabase configuration database, or even SQLite database.","title":"data_dir"},{"location":"references/crowdsec-config.html#simulation_path","text":"string The path to the profiles configuration.","title":"simulation_path"},{"location":"references/crowdsec-config.html#hub_dir","text":"string The directory where cscli will store parsers, scenarios, collections and such.","title":"hub_dir"},{"location":"references/crowdsec-config.html#index_path","text":"string Tath to the .index.json file downloaded by cscli to know the list of available configurations.","title":"index_path"},{"location":"references/crowdsec-config.html#crowdsec_service","text":"This section is only used by crowdsec agent. crowdsec_service : acquisition_path : <acqusition_file_path> acquisition_dir : <acqusition_dir_path> parser_routines : <number_of_parser_routines> buckets_routines : <number_of_buckets_routines> output_routines : <number_of_output_routines>","title":"crowdsec_service"},{"location":"references/crowdsec-config.html#parser_routines","text":"int Number of dedicated goroutines for parsing files.","title":"parser_routines"},{"location":"references/crowdsec-config.html#buckets_routines","text":"int Number of dedicated goroutines for managing live buckets.","title":"buckets_routines"},{"location":"references/crowdsec-config.html#output_routines","text":"int Number of dedicated goroutines for pushing data to local api.","title":"output_routines"},{"location":"references/crowdsec-config.html#acquisition_path","text":"string Path to the yaml file containing logs that needs to be read.","title":"acquisition_path"},{"location":"references/crowdsec-config.html#acquisition_dir","text":"string (>1.0.7) Path to a directory where each yaml is considered as a acquisition configuration file containing logs that needs to be read.","title":"acquisition_dir"},{"location":"references/crowdsec-config.html#cscli","text":"This section is only used by cscli . cscli : output : (human|json|raw) hub_branch : <hub_branch> prometheus_uri : <uri>","title":"cscli"},{"location":"references/crowdsec-config.html#output","text":"string The default output format (human, json or raw).","title":"output"},{"location":"references/crowdsec-config.html#hub_branch","text":"string The git branch on which cscli is going to fetch configurations.","title":"hub_branch"},{"location":"references/crowdsec-config.html#prometheus_uri","text":"uri (>1.0.7) An uri (without the trailing /metrics ) that will be used by cscli metrics command, ie. http://127.0.0.1:6060/","title":"prometheus_uri"},{"location":"references/crowdsec-config.html#db_config","text":"Please refer to the database configuration .","title":"db_config"},{"location":"references/crowdsec-config.html#api","text":"The api section is used by both cscli , crowdsec and the local API. api : client : insecure_skip_verify : (true|false) credentials_path : <path_to_local_api_client_credential_file> server : log_level : (error|info|debug|trace>) listen_uri : <listen_uri> # host:port profiles_path : <path_to_profile_file> use_forwarded_for_headers : (true|false) online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file>","title":"api"},{"location":"references/crowdsec-config.html#client","text":"The client subsection is used by crowdsec and cscli to read and write decisions to the local API. client : insecure_skip_verify : (true|false) credentials_path : <path_to_local_api_client_credential_file>","title":"client"},{"location":"references/crowdsec-config.html#insecure_skip_verify","text":"bool Allows the use of https with self-signed certificates.","title":"insecure_skip_verify"},{"location":"references/crowdsec-config.html#credentials_path","text":"string Path to the credential files (contains API url + login/password).","title":"credentials_path"},{"location":"references/crowdsec-config.html#server","text":"The server subsection is the local API configuration. server : log_level : (error|info|debug|trace) listen_uri : <listen_uri> # host:port profiles_path : <path_to_profile_file> use_forwarded_for_headers : (true|false) online_client : credentials_path : <path_to_crowdsec_api_client_credential_file> tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file>","title":"server"},{"location":"references/crowdsec-config.html#listen_uri","text":"string Address and port listen configuration, the form host:port .","title":"listen_uri"},{"location":"references/crowdsec-config.html#profiles_path","text":"string The path to the profiles configuration.","title":"profiles_path"},{"location":"references/crowdsec-config.html#use_forwarded_for_headers","text":"string Allow the usage of X-Forwarded-For or X-Real-IP to get the client IP address. Do not enable if you are not running the LAPI behind a trusted reverse-proxy or LB.","title":"use_forwarded_for_headers"},{"location":"references/crowdsec-config.html#online_client","text":"Configuration to push signals and receive bad IPs from Crowdsec API. online_client : credentials_path : <path_to_crowdsec_api_client_credential_file>","title":"online_client"},{"location":"references/crowdsec-config.html#credentials_path_1","text":"string Path to a file containing credentials for the Central API.","title":"credentials_path"},{"location":"references/crowdsec-config.html#tls","text":"if present, holds paths to certs and key files. tls : cert_file : <path_to_certificat_file> key_file : <path_to_certificat_key_file>","title":"tls"},{"location":"references/crowdsec-config.html#cert_file","text":"string Path to certificate file.","title":"cert_file"},{"location":"references/crowdsec-config.html#key_file","text":"string Path to certficate key file.","title":"key_file"},{"location":"references/crowdsec-config.html#prometheus","text":"This section is used by local API and crowdsec. prometheus : enabled : (true|false) level : (full|aggregated) listen_addr : <listen_address> listen_port : <listen_port>","title":"prometheus"},{"location":"references/crowdsec-config.html#enabled","text":"bool Allows to enable/disable prometheus instrumentation.","title":"enabled"},{"location":"references/crowdsec-config.html#level","text":"string Can be full (all metrics) or aggregated (to allow minimal metrics that will keep cardinality low).","title":"level"},{"location":"references/crowdsec-config.html#listen_addr","text":"string Prometheus listen url.","title":"listen_addr"},{"location":"references/crowdsec-config.html#listen_port","text":"int Prometheus listen port.","title":"listen_port"},{"location":"references/database.html","text":"Database \u00b6 The database is mostly used by the local API but also by cscli for some tasks. Currently, 3 databases are supported: sqlite (default database) mysql postgresql Warning It is recommanded to use mysql or postgresql if you expect to have a lot of traffic on the API. The database configuration can be found in the crowdsec configuration file (default: /etc/crowdsec/config.yaml). Its located under the db_config block. Configuration Examples \u00b6 SQLite db_config : type : sqlite db_path : /var/lib/crowdsec/data/crowdsec.db flush : max_items : 5000 max_age : 7d MySQL db_config : type : mysql user : crowdsec password : crowdsecpassword db_name : crowdsec host : \"127.0.0.1\" port : 3306 flush : max_items : 5000 max_age : 7d PostgreSQL db_config : type : postgresql user : crowdsec password : crowdsecpassword db_name : crowdsec host : \"127.0.0.1\" port : 5432 sslmode : disable flush : max_items : 5000 max_age : 7d Configuration Format \u00b6 db_config \u00b6 Contains the configuration of the database db_config : type : <db_type> db_path : <path_to_database_file> # for sqlite user : <db_user> # for mysql/pgsql password : <db_password> # for mysql/pgsql db_name : <db_name> # for mysql/pgsql host : <db_host_ip> # for mysql/pgsql port : <db_host_port> # for mysql/pgsql sslmode : <required/disable> # for pgsql flush : max_items : <max_alerts_in_db> max_age : <max_age_of_alerts_in_db> Configuration Directives \u00b6 type \u00b6 db_config : type : sqlite The type of database to use. It can be: sqlite mysql postgresql db_path \u00b6 db_config : type : sqlite db_path : \"/var/lib/crowdsec/data/crowdsec.db The path to the database file (only if the type of database is sqlite ) user \u00b6 db_config : type : mysql|postgresql user : foo The username to connect to the database (only if the type of database is mysql or postgresql ) password \u00b6 db_config : type : mysql|postgresql password : foobar The password to connect to the database (only if the type of database is mysql or postgresql ) db_name \u00b6 db_config : type : mysql|postgresql db_name : crowdsec The database name to connect to (only if the type of database is mysql or postgresql ) db_host \u00b6 db_config : type : mysql|postgresql user : foo The host to connect to (only if the type of database is mysql or postgresql ) db_port \u00b6 db_config : type : mysql|postgresql user : foo The port to connect to (only if the type of database is mysql or postgresql ) db_config : type : postgresql sslmode : required Required or disable ssl connection to database (only if the type of database is postgresql ) flush \u00b6 flush : max_items : <nb_max_alerts_in_database> max_age : <max_alerts_age_in_database> max_items \u00b6 int Number max of alerts in database. max_age \u00b6 string Alerts retention time. Supported units: s : seconds m : minutes h : hours d : days Database schema \u00b6 crowdsec-agent uses the ent framework to manage the database. This is the schema of the database (as seen by entc describe ) Alert: +-----------------+-----------+--------+----------+----------+---------+---------------+-----------+----------------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +-----------------+-----------+--------+----------+----------+---------+---------------+-----------+----------------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | scenario | string | false | false | false | false | false | false | json:\"scenario,omitempty\" | 0 | | bucketId | string | false | true | false | true | false | false | json:\"bucketId,omitempty\" | 0 | | message | string | false | true | false | true | false | false | json:\"message,omitempty\" | 0 | | eventsCount | int32 | false | true | false | true | false | false | json:\"eventsCount,omitempty\" | 0 | | startedAt | time.Time | false | true | false | true | false | false | json:\"startedAt,omitempty\" | 0 | | stoppedAt | time.Time | false | true | false | true | false | false | json:\"stoppedAt,omitempty\" | 0 | | sourceIp | string | false | true | false | false | false | false | json:\"sourceIp,omitempty\" | 0 | | sourceRange | string | false | true | false | false | false | false | json:\"sourceRange,omitempty\" | 0 | | sourceAsNumber | string | false | true | false | false | false | false | json:\"sourceAsNumber,omitempty\" | 0 | | sourceAsName | string | false | true | false | false | false | false | json:\"sourceAsName,omitempty\" | 0 | | sourceCountry | string | false | true | false | false | false | false | json:\"sourceCountry,omitempty\" | 0 | | sourceLatitude | float32 | false | true | false | false | false | false | json:\"sourceLatitude,omitempty\" | 0 | | sourceLongitude | float32 | false | true | false | false | false | false | json:\"sourceLongitude,omitempty\" | 0 | | sourceScope | string | false | true | false | false | false | false | json:\"sourceScope,omitempty\" | 0 | | sourceValue | string | false | true | false | false | false | false | json:\"sourceValue,omitempty\" | 0 | | capacity | int32 | false | true | false | false | false | false | json:\"capacity,omitempty\" | 0 | | leakSpeed | string | false | true | false | false | false | false | json:\"leakSpeed,omitempty\" | 0 | | scenarioVersion | string | false | true | false | false | false | false | json:\"scenarioVersion,omitempty\" | 0 | | scenarioHash | string | false | true | false | false | false | false | json:\"scenarioHash,omitempty\" | 0 | | simulated | bool | false | false | false | true | false | false | json:\"simulated,omitempty\" | 0 | +-----------------+-----------+--------+----------+----------+---------+---------------+-----------+----------------------------------+------------+ +-----------+----------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-----------+----------+---------+---------+----------+--------+----------+ | owner | Machine | true | alerts | M2O | true | true | | decisions | Decision | false | | O2M | false | true | | events | Event | false | | O2M | false | true | | metas | Meta | false | | O2M | false | true | +-----------+----------+---------+---------+----------+--------+----------+ Bouncer: +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | name | string | true | false | false | false | false | false | json:\"name,omitempty\" | 0 | | api_key | string | false | false | false | false | false | false | json:\"api_key,omitempty\" | 0 | | revoked | bool | false | false | false | false | false | false | json:\"revoked,omitempty\" | 0 | | ip_address | string | false | true | false | true | false | false | json:\"ip_address,omitempty\" | 0 | | type | string | false | true | false | false | false | false | json:\"type,omitempty\" | 0 | | version | string | false | true | false | false | false | false | json:\"version,omitempty\" | 0 | | until | time.Time | false | true | false | true | false | false | json:\"until,omitempty\" | 0 | | last_pull | time.Time | false | false | false | true | false | false | json:\"last_pull,omitempty\" | 0 | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ Decision: +--------------+-----------+--------+----------+----------+---------+---------------+-----------+-------------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +--------------+-----------+--------+----------+----------+---------+---------------+-----------+-------------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | until | time.Time | false | false | false | false | false | false | json:\"until,omitempty\" | 0 | | scenario | string | false | false | false | false | false | false | json:\"scenario,omitempty\" | 0 | | type | string | false | false | false | false | false | false | json:\"type,omitempty\" | 0 | | start_ip | int64 | false | true | false | false | false | false | json:\"start_ip,omitempty\" | 0 | | end_ip | int64 | false | true | false | false | false | false | json:\"end_ip,omitempty\" | 0 | | start_suffix | int64 | false | true | false | false | false | false | json:\"start_suffix,omitempty\" | 0 | | end_suffix | int64 | false | true | false | false | false | false | json:\"end_suffix,omitempty\" | 0 | | ip_size | int64 | false | true | false | false | false | false | json:\"ip_size,omitempty\" | 0 | | scope | string | false | false | false | false | false | false | json:\"scope,omitempty\" | 0 | | value | string | false | false | false | false | false | false | json:\"value,omitempty\" | 0 | | origin | string | false | false | false | false | false | false | json:\"origin,omitempty\" | 0 | | simulated | bool | false | false | false | true | false | false | json:\"simulated,omitempty\" | 0 | +--------------+-----------+--------+----------+----------+---------+---------------+-----------+-------------------------------+------------+ +-------+-------+---------+-----------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-------+-------+---------+-----------+----------+--------+----------+ | owner | Alert | true | decisions | M2O | true | true | +-------+-------+---------+-----------+----------+--------+----------+ Event: +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | time | time.Time | false | false | false | false | false | false | json:\"time,omitempty\" | 0 | | serialized | string | false | false | false | false | false | false | json:\"serialized,omitempty\" | 1 | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ +-------+-------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-------+-------+---------+---------+----------+--------+----------+ | owner | Alert | true | events | M2O | true | true | +-------+-------+---------+---------+----------+--------+----------+ Machine: +-------------+-----------+--------+----------+----------+---------+---------------+-----------+------------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +-------------+-----------+--------+----------+----------+---------+---------------+-----------+------------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | machineId | string | true | false | false | false | false | false | json:\"machineId,omitempty\" | 0 | | password | string | false | false | false | false | false | false | json:\"password,omitempty\" | 0 | | ipAddress | string | false | false | false | false | false | false | json:\"ipAddress,omitempty\" | 0 | | scenarios | string | false | true | false | false | false | false | json:\"scenarios,omitempty\" | 1 | | version | string | false | true | false | false | false | false | json:\"version,omitempty\" | 0 | | isValidated | bool | false | false | false | true | false | false | json:\"isValidated,omitempty\" | 0 | | status | string | false | true | false | false | false | false | json:\"status,omitempty\" | 0 | +-------------+-----------+--------+----------+----------+---------+---------------+-----------+------------------------------+------------+ +--------+-------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +--------+-------+---------+---------+----------+--------+----------+ | alerts | Alert | false | | O2M | false | true | +--------+-------+---------+---------+----------+--------+----------+ Meta: +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | key | string | false | false | false | false | false | false | json:\"key,omitempty\" | 0 | | value | string | false | false | false | false | false | false | json:\"value,omitempty\" | 1 | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ +-------+-------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-------+-------+---------+---------+----------+--------+----------+ | owner | Alert | true | metas | M2O | true | true | +-------+-------+---------+---------+----------+--------+----------+","title":"Database format"},{"location":"references/database.html#database","text":"The database is mostly used by the local API but also by cscli for some tasks. Currently, 3 databases are supported: sqlite (default database) mysql postgresql Warning It is recommanded to use mysql or postgresql if you expect to have a lot of traffic on the API. The database configuration can be found in the crowdsec configuration file (default: /etc/crowdsec/config.yaml). Its located under the db_config block.","title":"Database"},{"location":"references/database.html#configuration-examples","text":"SQLite db_config : type : sqlite db_path : /var/lib/crowdsec/data/crowdsec.db flush : max_items : 5000 max_age : 7d MySQL db_config : type : mysql user : crowdsec password : crowdsecpassword db_name : crowdsec host : \"127.0.0.1\" port : 3306 flush : max_items : 5000 max_age : 7d PostgreSQL db_config : type : postgresql user : crowdsec password : crowdsecpassword db_name : crowdsec host : \"127.0.0.1\" port : 5432 sslmode : disable flush : max_items : 5000 max_age : 7d","title":"Configuration Examples"},{"location":"references/database.html#configuration-format","text":"","title":"Configuration Format"},{"location":"references/database.html#db_config","text":"Contains the configuration of the database db_config : type : <db_type> db_path : <path_to_database_file> # for sqlite user : <db_user> # for mysql/pgsql password : <db_password> # for mysql/pgsql db_name : <db_name> # for mysql/pgsql host : <db_host_ip> # for mysql/pgsql port : <db_host_port> # for mysql/pgsql sslmode : <required/disable> # for pgsql flush : max_items : <max_alerts_in_db> max_age : <max_age_of_alerts_in_db>","title":"db_config"},{"location":"references/database.html#configuration-directives","text":"","title":"Configuration Directives"},{"location":"references/database.html#type","text":"db_config : type : sqlite The type of database to use. It can be: sqlite mysql postgresql","title":"type"},{"location":"references/database.html#db_path","text":"db_config : type : sqlite db_path : \"/var/lib/crowdsec/data/crowdsec.db The path to the database file (only if the type of database is sqlite )","title":"db_path"},{"location":"references/database.html#user","text":"db_config : type : mysql|postgresql user : foo The username to connect to the database (only if the type of database is mysql or postgresql )","title":"user"},{"location":"references/database.html#password","text":"db_config : type : mysql|postgresql password : foobar The password to connect to the database (only if the type of database is mysql or postgresql )","title":"password"},{"location":"references/database.html#db_name","text":"db_config : type : mysql|postgresql db_name : crowdsec The database name to connect to (only if the type of database is mysql or postgresql )","title":"db_name"},{"location":"references/database.html#db_host","text":"db_config : type : mysql|postgresql user : foo The host to connect to (only if the type of database is mysql or postgresql )","title":"db_host"},{"location":"references/database.html#db_port","text":"db_config : type : mysql|postgresql user : foo The port to connect to (only if the type of database is mysql or postgresql ) db_config : type : postgresql sslmode : required Required or disable ssl connection to database (only if the type of database is postgresql )","title":"db_port"},{"location":"references/database.html#flush","text":"flush : max_items : <nb_max_alerts_in_database> max_age : <max_alerts_age_in_database>","title":"flush"},{"location":"references/database.html#max_items","text":"int Number max of alerts in database.","title":"max_items"},{"location":"references/database.html#max_age","text":"string Alerts retention time. Supported units: s : seconds m : minutes h : hours d : days","title":"max_age"},{"location":"references/database.html#database-schema","text":"crowdsec-agent uses the ent framework to manage the database. This is the schema of the database (as seen by entc describe ) Alert: +-----------------+-----------+--------+----------+----------+---------+---------------+-----------+----------------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +-----------------+-----------+--------+----------+----------+---------+---------------+-----------+----------------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | scenario | string | false | false | false | false | false | false | json:\"scenario,omitempty\" | 0 | | bucketId | string | false | true | false | true | false | false | json:\"bucketId,omitempty\" | 0 | | message | string | false | true | false | true | false | false | json:\"message,omitempty\" | 0 | | eventsCount | int32 | false | true | false | true | false | false | json:\"eventsCount,omitempty\" | 0 | | startedAt | time.Time | false | true | false | true | false | false | json:\"startedAt,omitempty\" | 0 | | stoppedAt | time.Time | false | true | false | true | false | false | json:\"stoppedAt,omitempty\" | 0 | | sourceIp | string | false | true | false | false | false | false | json:\"sourceIp,omitempty\" | 0 | | sourceRange | string | false | true | false | false | false | false | json:\"sourceRange,omitempty\" | 0 | | sourceAsNumber | string | false | true | false | false | false | false | json:\"sourceAsNumber,omitempty\" | 0 | | sourceAsName | string | false | true | false | false | false | false | json:\"sourceAsName,omitempty\" | 0 | | sourceCountry | string | false | true | false | false | false | false | json:\"sourceCountry,omitempty\" | 0 | | sourceLatitude | float32 | false | true | false | false | false | false | json:\"sourceLatitude,omitempty\" | 0 | | sourceLongitude | float32 | false | true | false | false | false | false | json:\"sourceLongitude,omitempty\" | 0 | | sourceScope | string | false | true | false | false | false | false | json:\"sourceScope,omitempty\" | 0 | | sourceValue | string | false | true | false | false | false | false | json:\"sourceValue,omitempty\" | 0 | | capacity | int32 | false | true | false | false | false | false | json:\"capacity,omitempty\" | 0 | | leakSpeed | string | false | true | false | false | false | false | json:\"leakSpeed,omitempty\" | 0 | | scenarioVersion | string | false | true | false | false | false | false | json:\"scenarioVersion,omitempty\" | 0 | | scenarioHash | string | false | true | false | false | false | false | json:\"scenarioHash,omitempty\" | 0 | | simulated | bool | false | false | false | true | false | false | json:\"simulated,omitempty\" | 0 | +-----------------+-----------+--------+----------+----------+---------+---------------+-----------+----------------------------------+------------+ +-----------+----------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-----------+----------+---------+---------+----------+--------+----------+ | owner | Machine | true | alerts | M2O | true | true | | decisions | Decision | false | | O2M | false | true | | events | Event | false | | O2M | false | true | | metas | Meta | false | | O2M | false | true | +-----------+----------+---------+---------+----------+--------+----------+ Bouncer: +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | name | string | true | false | false | false | false | false | json:\"name,omitempty\" | 0 | | api_key | string | false | false | false | false | false | false | json:\"api_key,omitempty\" | 0 | | revoked | bool | false | false | false | false | false | false | json:\"revoked,omitempty\" | 0 | | ip_address | string | false | true | false | true | false | false | json:\"ip_address,omitempty\" | 0 | | type | string | false | true | false | false | false | false | json:\"type,omitempty\" | 0 | | version | string | false | true | false | false | false | false | json:\"version,omitempty\" | 0 | | until | time.Time | false | true | false | true | false | false | json:\"until,omitempty\" | 0 | | last_pull | time.Time | false | false | false | true | false | false | json:\"last_pull,omitempty\" | 0 | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ Decision: +--------------+-----------+--------+----------+----------+---------+---------------+-----------+-------------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +--------------+-----------+--------+----------+----------+---------+---------------+-----------+-------------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | until | time.Time | false | false | false | false | false | false | json:\"until,omitempty\" | 0 | | scenario | string | false | false | false | false | false | false | json:\"scenario,omitempty\" | 0 | | type | string | false | false | false | false | false | false | json:\"type,omitempty\" | 0 | | start_ip | int64 | false | true | false | false | false | false | json:\"start_ip,omitempty\" | 0 | | end_ip | int64 | false | true | false | false | false | false | json:\"end_ip,omitempty\" | 0 | | start_suffix | int64 | false | true | false | false | false | false | json:\"start_suffix,omitempty\" | 0 | | end_suffix | int64 | false | true | false | false | false | false | json:\"end_suffix,omitempty\" | 0 | | ip_size | int64 | false | true | false | false | false | false | json:\"ip_size,omitempty\" | 0 | | scope | string | false | false | false | false | false | false | json:\"scope,omitempty\" | 0 | | value | string | false | false | false | false | false | false | json:\"value,omitempty\" | 0 | | origin | string | false | false | false | false | false | false | json:\"origin,omitempty\" | 0 | | simulated | bool | false | false | false | true | false | false | json:\"simulated,omitempty\" | 0 | +--------------+-----------+--------+----------+----------+---------+---------------+-----------+-------------------------------+------------+ +-------+-------+---------+-----------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-------+-------+---------+-----------+----------+--------+----------+ | owner | Alert | true | decisions | M2O | true | true | +-------+-------+---------+-----------+----------+--------+----------+ Event: +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | time | time.Time | false | false | false | false | false | false | json:\"time,omitempty\" | 0 | | serialized | string | false | false | false | false | false | false | json:\"serialized,omitempty\" | 1 | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ +-------+-------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-------+-------+---------+---------+----------+--------+----------+ | owner | Alert | true | events | M2O | true | true | +-------+-------+---------+---------+----------+--------+----------+ Machine: +-------------+-----------+--------+----------+----------+---------+---------------+-----------+------------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +-------------+-----------+--------+----------+----------+---------+---------------+-----------+------------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | machineId | string | true | false | false | false | false | false | json:\"machineId,omitempty\" | 0 | | password | string | false | false | false | false | false | false | json:\"password,omitempty\" | 0 | | ipAddress | string | false | false | false | false | false | false | json:\"ipAddress,omitempty\" | 0 | | scenarios | string | false | true | false | false | false | false | json:\"scenarios,omitempty\" | 1 | | version | string | false | true | false | false | false | false | json:\"version,omitempty\" | 0 | | isValidated | bool | false | false | false | true | false | false | json:\"isValidated,omitempty\" | 0 | | status | string | false | true | false | false | false | false | json:\"status,omitempty\" | 0 | +-------------+-----------+--------+----------+----------+---------+---------------+-----------+------------------------------+------------+ +--------+-------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +--------+-------+---------+---------+----------+--------+----------+ | alerts | Alert | false | | O2M | false | true | +--------+-------+---------+---------+----------+--------+----------+ Meta: +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | Field | Type | Unique | Optional | Nillable | Default | UpdateDefault | Immutable | StructTag | Validators | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ | id | int | false | false | false | false | false | false | json:\"id,omitempty\" | 0 | | created_at | time.Time | false | false | false | true | false | false | json:\"created_at,omitempty\" | 0 | | updated_at | time.Time | false | false | false | true | false | false | json:\"updated_at,omitempty\" | 0 | | key | string | false | false | false | false | false | false | json:\"key,omitempty\" | 0 | | value | string | false | false | false | false | false | false | json:\"value,omitempty\" | 1 | +------------+-----------+--------+----------+----------+---------+---------------+-----------+-----------------------------+------------+ +-------+-------+---------+---------+----------+--------+----------+ | Edge | Type | Inverse | BackRef | Relation | Unique | Optional | +-------+-------+---------+---------+----------+--------+----------+ | owner | Alert | true | metas | M2O | true | true | +-------+-------+---------+---------+----------+--------+----------+","title":"Database schema"},{"location":"references/decisions.html","text":"Decisions \u00b6 A Decision is the runtime representation of a bucket overflow consequence : an action being taken against an IP, a Range, a User etc. The representation of the object can be found here : Decision object documentation Those objects are not meant to be manipulated directly by parsers and such, but rather be consumed by the bouncers via the local API .","title":"Decision object"},{"location":"references/decisions.html#decisions","text":"A Decision is the runtime representation of a bucket overflow consequence : an action being taken against an IP, a Range, a User etc. The representation of the object can be found here : Decision object documentation Those objects are not meant to be manipulated directly by parsers and such, but rather be consumed by the bouncers via the local API .","title":"Decisions"},{"location":"references/enrichers.html","text":"Enrichers \u00b6 Enrichers are parsers that can rely on external methods to provide extra contextual information to the event. The enrichers are usually in the s02-enrich stage (after most of the parsing happened). Enrichers functions should all accept a string as a parameter, and return an associative string array, that will be automatically merged into the Enriched map of the event . Warning At the time of writing, enrichers plugin mechanism implementation is still ongoing (read: the list of available enrichment methods is currently hardcoded). As an example let's look into the geoip-enrich parser/enricher : It relies on the geolite2 data created by maxmind and the geoip2 golang module to provide the actual data. It exposes three methods : GeoIpCity GeoIpASN and IpToRange that are used by the crowdsecurity/geoip-enrich . Enrichers can be installed as any other parsers with the following command: sudo cscli parsers install crowdsecurity/geoip-enrich Take a tour at the Crowdsec Hub to find them !","title":"Enrichers format"},{"location":"references/enrichers.html#enrichers","text":"Enrichers are parsers that can rely on external methods to provide extra contextual information to the event. The enrichers are usually in the s02-enrich stage (after most of the parsing happened). Enrichers functions should all accept a string as a parameter, and return an associative string array, that will be automatically merged into the Enriched map of the event . Warning At the time of writing, enrichers plugin mechanism implementation is still ongoing (read: the list of available enrichment methods is currently hardcoded). As an example let's look into the geoip-enrich parser/enricher : It relies on the geolite2 data created by maxmind and the geoip2 golang module to provide the actual data. It exposes three methods : GeoIpCity GeoIpASN and IpToRange that are used by the crowdsecurity/geoip-enrich . Enrichers can be installed as any other parsers with the following command: sudo cscli parsers install crowdsecurity/geoip-enrich Take a tour at the Crowdsec Hub to find them !","title":"Enrichers"},{"location":"references/events.html","text":"Events \u00b6 An Event is the runtime representation of an item being processed by crowdsec, it can be: a log line being parsed an overflow being reprocessed The Event object is modified by parsers, scenarios, and directly via user statics expressions (for example). The representation of the object can be found here : Event object documentation LOG relevant fields \u00b6 Type is types.LOG Whitelisted : if true the LOG or OVFLW will be dropped Line : representation of the raw line Raw : the raw line representation Src : a label for the source Time : acquisition timestamp Labels : the static labels (from acquis.yaml) associated to the source Process : if set to false, processing of line will stop Parsed : a map[string]string that can be used during parsing and enrichment. This is where GROK patterns will output their captures by default Enriched : a map[string]string that can be used during parsing and enrichment. This is where enrichment functions will output their captures by default Meta : a map[string]string that can be used to store important information about a log. This map is serialized into DB when storing event. Overflow : representation of an Overflow if Type is set to OVFLW Time : processing timestamp StrTime : string representation of log timestamp. Can be set by parsers that capture timestamp in logs. Will be automatically processed by crowdsecurity/dateparse-enrich when processing logs in forensic mode to set MarshaledTime MarshaledTime : if non-empty, the event's timestamp that will be used when processing buckets (for forensic mode) OVERFLOW relevant fields \u00b6 Type is types.OVFLW Whitelisted : if true the LOG or OVFLW will be dropped Overflow : representation of an Overflow if Type is set to OVFLW Time : processing timestamp StrTime : string representation of log timestamp. Can be set by parsers that capture timestamp in logs. Will be automatically processed by crowdsecurity/dateparse-enrich when processing logs in forensic mode to set MarshaledTime MarshaledTime : if non-empty, the event's timestamp that will be used when processing buckets (for forensic mode) Overflow : Whitelisted : if true the OVFLW will be dropped Reprocess : if true, the OVFLOW will be reprocessed (inference) Sources : a map[string]models.Source representing the distinct sources that triggered the overflow, with their types and values. Alert and APIAlerts : representation of the signals that will be sent to LAPI.","title":"Event object"},{"location":"references/events.html#events","text":"An Event is the runtime representation of an item being processed by crowdsec, it can be: a log line being parsed an overflow being reprocessed The Event object is modified by parsers, scenarios, and directly via user statics expressions (for example). The representation of the object can be found here : Event object documentation","title":"Events"},{"location":"references/events.html#log-relevant-fields","text":"Type is types.LOG Whitelisted : if true the LOG or OVFLW will be dropped Line : representation of the raw line Raw : the raw line representation Src : a label for the source Time : acquisition timestamp Labels : the static labels (from acquis.yaml) associated to the source Process : if set to false, processing of line will stop Parsed : a map[string]string that can be used during parsing and enrichment. This is where GROK patterns will output their captures by default Enriched : a map[string]string that can be used during parsing and enrichment. This is where enrichment functions will output their captures by default Meta : a map[string]string that can be used to store important information about a log. This map is serialized into DB when storing event. Overflow : representation of an Overflow if Type is set to OVFLW Time : processing timestamp StrTime : string representation of log timestamp. Can be set by parsers that capture timestamp in logs. Will be automatically processed by crowdsecurity/dateparse-enrich when processing logs in forensic mode to set MarshaledTime MarshaledTime : if non-empty, the event's timestamp that will be used when processing buckets (for forensic mode)","title":"LOG relevant fields"},{"location":"references/events.html#overflow-relevant-fields","text":"Type is types.OVFLW Whitelisted : if true the LOG or OVFLW will be dropped Overflow : representation of an Overflow if Type is set to OVFLW Time : processing timestamp StrTime : string representation of log timestamp. Can be set by parsers that capture timestamp in logs. Will be automatically processed by crowdsecurity/dateparse-enrich when processing logs in forensic mode to set MarshaledTime MarshaledTime : if non-empty, the event's timestamp that will be used when processing buckets (for forensic mode) Overflow : Whitelisted : if true the OVFLW will be dropped Reprocess : if true, the OVFLOW will be reprocessed (inference) Sources : a map[string]models.Source representing the distinct sources that triggered the overflow, with their types and values. Alert and APIAlerts : representation of the signals that will be sent to LAPI.","title":"OVERFLOW relevant fields"},{"location":"references/expressions.html","text":"Expressions \u00b6 antonmedv/expr - Expression evaluation engine for Go: fast, non-Turing complete, dynamic typing, static typing Several places of crowdsec-agent's configuration use expr , notably : Filter that are used to determine events eligibility in parsers and scenarios or profiles Statics use expr in the expression directive, to compute complex values Whitelists rely on expression directive to allow more complex whitelists filters To learn more about expr , check the github page of the project . When crowdsec-agent relies on expr , a context is provided to let the expression access relevant objects : evt. is the representation of the current event and is the most relevant object in profiles , alert is accessible via the sig. object If the debug is enabled (in the scenario or parser where expr is used), additional debug will be displayed regarding evaluated expressions. Helpers \u00b6 In order to makes its use in crowdsec-agent more efficient, we added a few helpers that are documented bellow. Atof(string) float64 \u00b6 Parses a string representation of a float number to an actual float number (binding on strconv.ParseFloat ) Atof(evt.Parsed.tcp_port) JsonExtract(JsonBlob, FieldName) string \u00b6 Extract the FieldName from the JsonBlob and returns it as a string. (binding on jsonparser ) JsonExtract(evt.Parsed.some_json_blob, \"foo.bar[0].one_item\") File(FileName) []string \u00b6 Returns the content of FileName as an array of string, while providing cache mechanism. evt.Parsed.some_field in File('some_patterns.txt') any(File('rdns_seo_bots.txt'), { evt.Enriched.reverse_dns endsWith #}) RegexpInFile(StringToMatch, FileName) bool \u00b6 Returns true if the StringToMatch is matched by one of the expressions contained in FileName (uses RE2 regexp engine). RegexpInFile( evt.Enriched.reverse_dns, 'my_legit_seo_whitelists.txt') Upper(string) string \u00b6 Returns the uppercase version of the string Upper(\"yop\") IpInRange(IPStr, RangeStr) bool \u00b6 Returns true if the IP IPStr is contained in the IP range RangeStr (uses net.ParseCIDR ) IpInRange(\"1.2.3.4\", \"1.2.3.0/24\") TimeNow() string \u00b6 Return RFC3339 formatted time TimeNow()","title":"Expressions helpers"},{"location":"references/expressions.html#expressions","text":"antonmedv/expr - Expression evaluation engine for Go: fast, non-Turing complete, dynamic typing, static typing Several places of crowdsec-agent's configuration use expr , notably : Filter that are used to determine events eligibility in parsers and scenarios or profiles Statics use expr in the expression directive, to compute complex values Whitelists rely on expression directive to allow more complex whitelists filters To learn more about expr , check the github page of the project . When crowdsec-agent relies on expr , a context is provided to let the expression access relevant objects : evt. is the representation of the current event and is the most relevant object in profiles , alert is accessible via the sig. object If the debug is enabled (in the scenario or parser where expr is used), additional debug will be displayed regarding evaluated expressions.","title":"Expressions"},{"location":"references/expressions.html#helpers","text":"In order to makes its use in crowdsec-agent more efficient, we added a few helpers that are documented bellow.","title":"Helpers"},{"location":"references/expressions.html#atofstring-float64","text":"Parses a string representation of a float number to an actual float number (binding on strconv.ParseFloat ) Atof(evt.Parsed.tcp_port)","title":"Atof(string) float64"},{"location":"references/expressions.html#jsonextractjsonblob-fieldname-string","text":"Extract the FieldName from the JsonBlob and returns it as a string. (binding on jsonparser ) JsonExtract(evt.Parsed.some_json_blob, \"foo.bar[0].one_item\")","title":"JsonExtract(JsonBlob, FieldName) string"},{"location":"references/expressions.html#filefilename-string","text":"Returns the content of FileName as an array of string, while providing cache mechanism. evt.Parsed.some_field in File('some_patterns.txt') any(File('rdns_seo_bots.txt'), { evt.Enriched.reverse_dns endsWith #})","title":"File(FileName) []string"},{"location":"references/expressions.html#regexpinfilestringtomatch-filename-bool","text":"Returns true if the StringToMatch is matched by one of the expressions contained in FileName (uses RE2 regexp engine). RegexpInFile( evt.Enriched.reverse_dns, 'my_legit_seo_whitelists.txt')","title":"RegexpInFile(StringToMatch, FileName) bool"},{"location":"references/expressions.html#upperstring-string","text":"Returns the uppercase version of the string Upper(\"yop\")","title":"Upper(string) string"},{"location":"references/expressions.html#ipinrangeipstr-rangestr-bool","text":"Returns true if the IP IPStr is contained in the IP range RangeStr (uses net.ParseCIDR ) IpInRange(\"1.2.3.4\", \"1.2.3.0/24\")","title":"IpInRange(IPStr, RangeStr) bool"},{"location":"references/expressions.html#timenow-string","text":"Return RFC3339 formatted time TimeNow()","title":"TimeNow() string"},{"location":"references/parsers.html","text":"Understanding parsers \u00b6 A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing, or use specific expr feature to perform parsing on specific data, such as JSON. Parsers are organized into stages to allow pipelines and branching in parsing. See the Crowdsec Hub to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing The parsers usually reside in /etc/crowdsec/parsers/<STAGE>/ . Parser configuration format \u00b6 A parser node might look like : onsuccess : next_stage debug : true filter : \"evt.Parsed.program == 'kernel'\" name : crowdsecurity/demo-iptables description : \"Parse iptables drop logs\" pattern_syntax : MYCAP : \".*\" grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ apply_on : evt.Parsed.some_field statics : - parsed : something expression : JsonExtract(evt.Event.extracted_value, \"nested.an_array[0]\") - meta : log_type value : parsed_testlog - meta : source_ip expression : \"evt.Parsed.src_ip\" The parser nodes are processed sequentially based on the alphabetical order of stage and subsequent files. If the node is considered successful (grok is present and returned data or no grok is present) and \"onsuccess\" equals to next_stage , then the event is moved to the next stage. Parser trees \u00b6 A parser node can contain sub-nodes, to provide proper branching (on top of stages). It can be useful when you want to apply different parsing based on different criterias, or when you have a set of candidates parsers that you want to apply to an event : #This first node will capture/extract some value filter : \"evt.Line.Labels.type == 'type1'\" name : tests/base-grok-root pattern_syntax : MYCAP : \".*\" grok : pattern : ^... %{MYCAP:extracted_value} ...$ apply_on : Line.Raw statics : - meta : state value : root-done - meta : state_sub expression : evt.Parsed.extracted_value --- #and this node will apply different patterns to it filter : \"evt.Line.Labels.type == 'type1' && evt.Meta.state == 'root-done'\" name : tests/base-grok-leafs onsuccess : next_stage #the sub-nodes will process the result of the master node nodes : - filter : \"evt.Parsed.extracted_value == 'VALUE1'\" debug : true statics : - meta : final_state value : leaf1 - filter : \"evt.Parsed.extracted_value == 'VALUE2'\" debug : true statics : - meta : final_state value : leaf2 The logic is that the tests/base-grok-root node will be processed first and will alter the event (here mostly by extracting some text from the Line.Raw field into Parsed thanks to the grok pattern and the statics directive). The event will then continue its life and be parsed by the the following tests/base-grok-leafs node. This node has onsuccess set to next_stage which means that if the node is successful, the event will be moved to the next stage. This node consists actually of two sub-nodes that have different conditions (branching) to allow differential treatment of said event. A real-life example can be seen when it comes to parsing HTTP logs. HTTP ACCESS and ERROR logs often have different formats, and thus our \"nginx\" parser needs to handle both formats Nginx parser filter : \"evt.Parsed.program == 'nginx'\" onsuccess : next_stage name : crowdsecurity/nginx-logs nodes : - grok : #this is the access log name : NGINXACCESS apply_on : message statics : - meta : log_type value : http_access-log - target : evt.StrTime expression : evt.Parsed.time_local - grok : # and this one the error log name : NGINXERROR apply_on : message statics : - meta : log_type value : http_error-log - target : evt.StrTime expression : evt.Parsed.time # these ones apply for both grok patterns statics : - meta : service value : http - meta : source_ip expression : \"evt.Parsed.remote_addr\" - meta : http_status expression : \"evt.Parsed.status\" - meta : http_path expression : \"evt.Parsed.request\" Parser directives \u00b6 debug \u00b6 debug : true|false default: false If set to to true , enabled node level debugging. It is meant to help understanding parser node behavior by providing contextual logging : assignments made by statics DEBU[31-07-2020 16:36:28] + Processing 4 statics id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[service] = 'http' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[source_ip] = '127.0.0.1' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_status] = '200' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_path] = '/' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse assignments made by grok pattern DEBU[31-07-2020 16:36:28] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['time_local'] = '21/Jul/2020:16:13:05 +0200' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['method'] = 'GET' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['request'] = '/' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['http_user_agent'] = 'curl/7.58.0' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['remote_addr'] = '127.0.0.1' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse debug of filters and expression results DEBU[31-07-2020 16:36:28] eval(evt.Parsed.program == 'nginx') = TRUE id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] eval variables: id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] evt.Parsed.program = 'nginx' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse filter \u00b6 filter : expression filter must be a valid expr expression that will be evaluated against the event . If filter evaluation returns true or is absent, node will be processed. If filter returns false or a non-boolean, node won't be processed. Here is the expr documentation . Examples : filter: \"evt.Meta.foo == 'test'\" filter: \"evt.Meta.bar == 'test' && evt.Meta.foo == 'test2' grok \u00b6 grok : name : NAMED_EXISTING_PATTERN apply_on : source_field grok : pattern : ^a valid RE2 expression with %{CAPTURE:field}$ apply_on : source_field The grok structure in a node represent a regular expression with capture group (grok pattern) that must be applied on a field of event. The pattern can : be imported by name (if present within the core of crowdsec-agent) defined in place In both case, the pattern must be a valid RE2 expression. The field(s) returned by the regular expression are going to be merged into the Parsed associative array of the Event . name \u00b6 name : explicit_string The mandatory name of the node. If not present, node will be skipped at runtime. It is used for example in debug log to help you track things. nodes \u00b6 nodes : - filter : ... grok : ... nodes is a list of parser nodes, allowing you to build trees. Each subnode must be valid, and if any of the subnodes succeed, the whole node is considered successful. onsuccess \u00b6 onsuccess: next_stage|continue default: continue if set to next_stage and the node is considered successful, the event will be moved directly to the next stage without processing other nodes in the current stage. note: if it's a parser tree, and a \"leaf\" node succeeds, it is the parent's \"onsuccess\" that is evaluated. pattern_syntax \u00b6 pattern_syntax : CAPTURE_NAME : VALID_RE2_EXPRESSION pattern_syntax allows user to define named capture group expressions for future use in grok patterns. Regexp must be a valid RE2 expression. pattern_syntax : MYCAP : \".*\" grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ apply_on : Line.Raw statics \u00b6 statics : - target : evt.Meta.target_field value : static_value - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression' - enriched : target_field value : static_value statics is a list of directives that will be executed when the node is considered successful. Each entry of the list is composed of a target (where to write) and a source (what data to write). target \u00b6 The target aims at being any part of the event object, and can be expressed in different ways : meta: <target_field> parsed: <target_field> enriched: <target_field> a dynamic target (please note that the current event is accessible via the evt. variable) : target: evt.Meta.foobar target: Meta.foobar target: evt.StrTime value \u00b6 The source itself can be either a static value, or an expr result : statics : - meta : target_field value : static_value - meta : target_field expression : evt.Meta.another_field - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression' value \u00b6 string A static value expression \u00b6 string A valid expr expression to eval. The result of the evaluation will be set in the target field. data \u00b6 data : - source_url : https://URL/TO/FILE dest_file : LOCAL_FILENAME type : (regexp|string) data allows user to specify an external source of data. This section is only relevant when cscli is used to install parser from hub, as it will download the source_url and store it to dest_file . When the parser is not installed from the hub, crowdsec-agent won't download the URL, but the file must exist for the parser to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string Parser concepts \u00b6 Success and failure \u00b6 A parser is considered \"successful\" if : A grok pattern was present and successfully matched No grok pattern was present Patterns documentation \u00b6 You can find exhaustive patterns documentation here .","title":"Parsers format"},{"location":"references/parsers.html#understanding-parsers","text":"A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing, or use specific expr feature to perform parsing on specific data, such as JSON. Parsers are organized into stages to allow pipelines and branching in parsing. See the Crowdsec Hub to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing The parsers usually reside in /etc/crowdsec/parsers/<STAGE>/ .","title":"Understanding parsers"},{"location":"references/parsers.html#parser-configuration-format","text":"A parser node might look like : onsuccess : next_stage debug : true filter : \"evt.Parsed.program == 'kernel'\" name : crowdsecurity/demo-iptables description : \"Parse iptables drop logs\" pattern_syntax : MYCAP : \".*\" grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ apply_on : evt.Parsed.some_field statics : - parsed : something expression : JsonExtract(evt.Event.extracted_value, \"nested.an_array[0]\") - meta : log_type value : parsed_testlog - meta : source_ip expression : \"evt.Parsed.src_ip\" The parser nodes are processed sequentially based on the alphabetical order of stage and subsequent files. If the node is considered successful (grok is present and returned data or no grok is present) and \"onsuccess\" equals to next_stage , then the event is moved to the next stage.","title":"Parser configuration format"},{"location":"references/parsers.html#parser-trees","text":"A parser node can contain sub-nodes, to provide proper branching (on top of stages). It can be useful when you want to apply different parsing based on different criterias, or when you have a set of candidates parsers that you want to apply to an event : #This first node will capture/extract some value filter : \"evt.Line.Labels.type == 'type1'\" name : tests/base-grok-root pattern_syntax : MYCAP : \".*\" grok : pattern : ^... %{MYCAP:extracted_value} ...$ apply_on : Line.Raw statics : - meta : state value : root-done - meta : state_sub expression : evt.Parsed.extracted_value --- #and this node will apply different patterns to it filter : \"evt.Line.Labels.type == 'type1' && evt.Meta.state == 'root-done'\" name : tests/base-grok-leafs onsuccess : next_stage #the sub-nodes will process the result of the master node nodes : - filter : \"evt.Parsed.extracted_value == 'VALUE1'\" debug : true statics : - meta : final_state value : leaf1 - filter : \"evt.Parsed.extracted_value == 'VALUE2'\" debug : true statics : - meta : final_state value : leaf2 The logic is that the tests/base-grok-root node will be processed first and will alter the event (here mostly by extracting some text from the Line.Raw field into Parsed thanks to the grok pattern and the statics directive). The event will then continue its life and be parsed by the the following tests/base-grok-leafs node. This node has onsuccess set to next_stage which means that if the node is successful, the event will be moved to the next stage. This node consists actually of two sub-nodes that have different conditions (branching) to allow differential treatment of said event. A real-life example can be seen when it comes to parsing HTTP logs. HTTP ACCESS and ERROR logs often have different formats, and thus our \"nginx\" parser needs to handle both formats Nginx parser filter : \"evt.Parsed.program == 'nginx'\" onsuccess : next_stage name : crowdsecurity/nginx-logs nodes : - grok : #this is the access log name : NGINXACCESS apply_on : message statics : - meta : log_type value : http_access-log - target : evt.StrTime expression : evt.Parsed.time_local - grok : # and this one the error log name : NGINXERROR apply_on : message statics : - meta : log_type value : http_error-log - target : evt.StrTime expression : evt.Parsed.time # these ones apply for both grok patterns statics : - meta : service value : http - meta : source_ip expression : \"evt.Parsed.remote_addr\" - meta : http_status expression : \"evt.Parsed.status\" - meta : http_path expression : \"evt.Parsed.request\"","title":"Parser trees"},{"location":"references/parsers.html#parser-directives","text":"","title":"Parser directives"},{"location":"references/parsers.html#debug","text":"debug : true|false default: false If set to to true , enabled node level debugging. It is meant to help understanding parser node behavior by providing contextual logging : assignments made by statics DEBU[31-07-2020 16:36:28] + Processing 4 statics id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[service] = 'http' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[source_ip] = '127.0.0.1' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_status] = '200' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_path] = '/' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse assignments made by grok pattern DEBU[31-07-2020 16:36:28] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['time_local'] = '21/Jul/2020:16:13:05 +0200' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['method'] = 'GET' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['request'] = '/' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['http_user_agent'] = 'curl/7.58.0' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['remote_addr'] = '127.0.0.1' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse debug of filters and expression results DEBU[31-07-2020 16:36:28] eval(evt.Parsed.program == 'nginx') = TRUE id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] eval variables: id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] evt.Parsed.program = 'nginx' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse","title":"debug"},{"location":"references/parsers.html#filter","text":"filter : expression filter must be a valid expr expression that will be evaluated against the event . If filter evaluation returns true or is absent, node will be processed. If filter returns false or a non-boolean, node won't be processed. Here is the expr documentation . Examples : filter: \"evt.Meta.foo == 'test'\" filter: \"evt.Meta.bar == 'test' && evt.Meta.foo == 'test2'","title":"filter"},{"location":"references/parsers.html#grok","text":"grok : name : NAMED_EXISTING_PATTERN apply_on : source_field grok : pattern : ^a valid RE2 expression with %{CAPTURE:field}$ apply_on : source_field The grok structure in a node represent a regular expression with capture group (grok pattern) that must be applied on a field of event. The pattern can : be imported by name (if present within the core of crowdsec-agent) defined in place In both case, the pattern must be a valid RE2 expression. The field(s) returned by the regular expression are going to be merged into the Parsed associative array of the Event .","title":"grok"},{"location":"references/parsers.html#name","text":"name : explicit_string The mandatory name of the node. If not present, node will be skipped at runtime. It is used for example in debug log to help you track things.","title":"name"},{"location":"references/parsers.html#nodes","text":"nodes : - filter : ... grok : ... nodes is a list of parser nodes, allowing you to build trees. Each subnode must be valid, and if any of the subnodes succeed, the whole node is considered successful.","title":"nodes"},{"location":"references/parsers.html#onsuccess","text":"onsuccess: next_stage|continue default: continue if set to next_stage and the node is considered successful, the event will be moved directly to the next stage without processing other nodes in the current stage. note: if it's a parser tree, and a \"leaf\" node succeeds, it is the parent's \"onsuccess\" that is evaluated.","title":"onsuccess"},{"location":"references/parsers.html#pattern_syntax","text":"pattern_syntax : CAPTURE_NAME : VALID_RE2_EXPRESSION pattern_syntax allows user to define named capture group expressions for future use in grok patterns. Regexp must be a valid RE2 expression. pattern_syntax : MYCAP : \".*\" grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ apply_on : Line.Raw","title":"pattern_syntax"},{"location":"references/parsers.html#statics","text":"statics : - target : evt.Meta.target_field value : static_value - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression' - enriched : target_field value : static_value statics is a list of directives that will be executed when the node is considered successful. Each entry of the list is composed of a target (where to write) and a source (what data to write).","title":"statics"},{"location":"references/parsers.html#target","text":"The target aims at being any part of the event object, and can be expressed in different ways : meta: <target_field> parsed: <target_field> enriched: <target_field> a dynamic target (please note that the current event is accessible via the evt. variable) : target: evt.Meta.foobar target: Meta.foobar target: evt.StrTime","title":"target"},{"location":"references/parsers.html#value","text":"The source itself can be either a static value, or an expr result : statics : - meta : target_field value : static_value - meta : target_field expression : evt.Meta.another_field - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression'","title":"value"},{"location":"references/parsers.html#value_1","text":"string A static value","title":"value"},{"location":"references/parsers.html#expression","text":"string A valid expr expression to eval. The result of the evaluation will be set in the target field.","title":"expression"},{"location":"references/parsers.html#data","text":"data : - source_url : https://URL/TO/FILE dest_file : LOCAL_FILENAME type : (regexp|string) data allows user to specify an external source of data. This section is only relevant when cscli is used to install parser from hub, as it will download the source_url and store it to dest_file . When the parser is not installed from the hub, crowdsec-agent won't download the URL, but the file must exist for the parser to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string","title":"data"},{"location":"references/parsers.html#parser-concepts","text":"","title":"Parser concepts"},{"location":"references/parsers.html#success-and-failure","text":"A parser is considered \"successful\" if : A grok pattern was present and successfully matched No grok pattern was present","title":"Success and failure"},{"location":"references/parsers.html#patterns-documentation","text":"You can find exhaustive patterns documentation here .","title":"Patterns documentation"},{"location":"references/patterns-documentation.html","text":"Patterns documentation \u00b6 You will find here a generated documentation of all the patterns loaded by crowdsec. They are sorted by pattern length, and are meant to be used in parsers, in the form %{PATTERN_NAME}. MONGO3_SEVERITY \u00b6 Pattern : \\w GREEDYDATA \u00b6 Pattern : .* DATA \u00b6 Pattern : .*? NOTSPACE \u00b6 Pattern : \\S+ SPACE \u00b6 Pattern : \\s* RAIL_ACTION \u00b6 Pattern : \\w+ JAVALOGMESSAGE \u00b6 Pattern : (.*) DAY2 \u00b6 Pattern : \\d{2} NOTDQUOTE \u00b6 Pattern : [^\"]* RAILS_CONSTROLLER \u00b6 Pattern : [^#]+ RUUID \u00b6 Pattern : \\s{32} SYSLOG5424PRINTASCII \u00b6 Pattern : [!-~]+ BACULA_VERSION \u00b6 Pattern : %{USER} WORD \u00b6 Pattern : \\b\\w+\\b BACULA_JOB \u00b6 Pattern : %{USER} CRON_ACTION \u00b6 Pattern : [A-Z ]+ BACULA_VOLUME \u00b6 Pattern : %{USER} BACULA_DEVICE \u00b6 Pattern : %{USER} TZ \u00b6 Pattern : [A-Z]{3} NUMTZ \u00b6 Pattern : [+-]\\d{4} MONGO3_COMPONENT \u00b6 Pattern : %{WORD}|- MONGO_WORDDASH \u00b6 Pattern : \\b[\\w-]+\\b NAGIOS_TYPE_HOST_ALERT \u00b6 Pattern : HOST ALERT NONNEGINT \u00b6 Pattern : \\b[0-9]+\\b MINUTE \u00b6 Pattern : [0-5][0-9] BACULA_DEVICEPATH \u00b6 Pattern : %{UNIXPATH} SYSLOGHOST \u00b6 Pattern : %{IPORHOST} REDISLOG1 \u00b6 Pattern : %{REDISLOG} USER \u00b6 Pattern : %{USERNAME} NUMBER \u00b6 Pattern : %{BASE10NUM} SYSLOG5424SD \u00b6 Pattern : \\[%{DATA}\\]+ ISO8601_SECOND \u00b6 Pattern : %{SECOND}|60 NGUSER \u00b6 Pattern : %{NGUSERNAME} MONTHNUM2 \u00b6 Pattern : 0[1-9]|1[0-2] BACULA_HOST \u00b6 Pattern : [a-zA-Z0-9-]+ EXIM_PID \u00b6 Pattern : \\[%{POSINT}\\] NAGIOS_TYPE_SERVICE_ALERT \u00b6 Pattern : SERVICE ALERT YEAR \u00b6 Pattern : (?:\\d\\d){1,2} MONTHNUM \u00b6 Pattern : 0?[1-9]|1[0-2] CISCO_XLATE_TYPE \u00b6 Pattern : static|dynamic RAILS_CONTEXT \u00b6 Pattern : (?:%{DATA}\\n)* BACULA_LOG_ENDPRUNE \u00b6 Pattern : End auto prune. POSINT \u00b6 Pattern : \\b[1-9][0-9]*\\b INT \u00b6 Pattern : [+-]?(?:[0-9]+) USERNAME \u00b6 Pattern : [a-zA-Z0-9._-]+ IP \u00b6 Pattern : %{IPV6}|%{IPV4} QS \u00b6 Pattern : %{QUOTEDSTRING} MODSECRULEVERS \u00b6 Pattern : \\[ver \"[^\"]+\"\\] NAGIOS_TYPE_EXTERNAL_COMMAND \u00b6 Pattern : EXTERNAL COMMAND NAGIOS_EC_ENABLE_SVC_CHECK \u00b6 Pattern : ENABLE_SVC_CHECK IPORHOST \u00b6 Pattern : %{IP}|%{HOSTNAME} NAGIOS_EC_ENABLE_HOST_CHECK \u00b6 Pattern : ENABLE_HOST_CHECK NAGIOS_TYPE_HOST_NOTIFICATION \u00b6 Pattern : HOST NOTIFICATION NAGIOS_EC_DISABLE_SVC_CHECK \u00b6 Pattern : DISABLE_SVC_CHECK NAGIOS_TYPE_PASSIVE_HOST_CHECK \u00b6 Pattern : PASSIVE HOST CHECK NAGIOS_TYPE_HOST_EVENT_HANDLER \u00b6 Pattern : HOST EVENT HANDLER HOUR \u00b6 Pattern : 2[0123]|[01]?[0-9] DATESTAMP \u00b6 Pattern : %{DATE}[- ]%{TIME} NAGIOS_TYPE_CURRENT_HOST_STATE \u00b6 Pattern : CURRENT HOST STATE NAGIOS_EC_DISABLE_HOST_CHECK \u00b6 Pattern : DISABLE_HOST_CHECK NGUSERNAME \u00b6 Pattern : [a-zA-Z\\.\\@\\-\\+_%]+ NAGIOS_TYPE_HOST_FLAPPING_ALERT \u00b6 Pattern : HOST FLAPPING ALERT NAGIOS_TYPE_HOST_DOWNTIME_ALERT \u00b6 Pattern : HOST DOWNTIME ALERT JAVAFILE \u00b6 Pattern : (?:[A-Za-z0-9_. -]+) NAGIOS_TYPE_SERVICE_NOTIFICATION \u00b6 Pattern : SERVICE NOTIFICATION BACULA_LOG_BEGIN_PRUNE_FILES \u00b6 Pattern : Begin pruning Files. NAGIOS_TYPE_CURRENT_SERVICE_STATE \u00b6 Pattern : CURRENT SERVICE STATE NAGIOS_TYPE_PASSIVE_SERVICE_CHECK \u00b6 Pattern : PASSIVE SERVICE CHECK NAGIOS_TYPE_TIMEPERIOD_TRANSITION \u00b6 Pattern : TIMEPERIOD TRANSITION HOSTPORT \u00b6 Pattern : %{IPORHOST}:%{POSINT} NAGIOS_TYPE_SERVICE_EVENT_HANDLER \u00b6 Pattern : SERVICE EVENT HANDLER NAGIOS_EC_SCHEDULE_HOST_DOWNTIME \u00b6 Pattern : SCHEDULE_HOST_DOWNTIME EXIM_FLAGS \u00b6 Pattern : (<=|[-=>*]>|[*]{2}|==) NAGIOS_TYPE_SERVICE_DOWNTIME_ALERT \u00b6 Pattern : SERVICE DOWNTIME ALERT EXIM_SUBJECT \u00b6 Pattern : (T=%{QS:exim_subject}) PATH \u00b6 Pattern : %{UNIXPATH}|%{WINPATH} NAGIOS_TYPE_SERVICE_FLAPPING_ALERT \u00b6 Pattern : SERVICE FLAPPING ALERT SSHD_CORRUPT_MAC \u00b6 Pattern : Corrupted MAC on input BACULA_LOG_NOPRUNE_JOBS \u00b6 Pattern : No Jobs found to prune. HTTPDUSER \u00b6 Pattern : %{EMAILADDRESS}|%{USER} BACULA_LOG_NOPRUNE_FILES \u00b6 Pattern : No Files found to prune. NAGIOS_EC_ENABLE_SVC_NOTIFICATIONS \u00b6 Pattern : ENABLE_SVC_NOTIFICATIONS BACULA_CAPACITY \u00b6 Pattern : %{INT}{1,3}(,%{INT}{3})* EXIM_PROTOCOL \u00b6 Pattern : (P=%{NOTSPACE:protocol}) URIPROTO \u00b6 Pattern : [A-Za-z]+(\\+[A-Za-z+]+)? PROG \u00b6 Pattern : [\\x21-\\x5a\\x5c\\x5e-\\x7e]+ NAGIOS_EC_ENABLE_HOST_NOTIFICATIONS \u00b6 Pattern : ENABLE_HOST_NOTIFICATIONS NAGIOS_EC_PROCESS_HOST_CHECK_RESULT \u00b6 Pattern : PROCESS_HOST_CHECK_RESULT BACULA_LOG_VSS \u00b6 Pattern : (Generate )?VSS (Writer)? NAGIOS_EC_DISABLE_SVC_NOTIFICATIONS \u00b6 Pattern : DISABLE_SVC_NOTIFICATIONS NAGIOS_EC_SCHEDULE_SERVICE_DOWNTIME \u00b6 Pattern : SCHEDULE_SERVICE_DOWNTIME MONGO_QUERY \u00b6 Pattern : \\{ \\{ .* \\} ntoreturn: \\} URIPATHPARAM \u00b6 Pattern : %{URIPATH}(?:%{URIPARAM})? NAGIOS_EC_DISABLE_HOST_NOTIFICATIONS \u00b6 Pattern : DISABLE_HOST_NOTIFICATIONS UNIXPATH \u00b6 Pattern : (/([\\w_%!$@:.,~-]+|\\\\.)*)+ KITCHEN \u00b6 Pattern : \\d{1,2}:\\d{2}(AM|PM|am|pm) NAGIOSTIME \u00b6 Pattern : \\[%{NUMBER:nagios_epoch}\\] EMAILLOCALPART \u00b6 Pattern : [a-zA-Z][a-zA-Z0-9_.+-=:]+ JAVATHREAD \u00b6 Pattern : (?:[A-Z]{2}-Processor[\\d]+) TIME \u00b6 Pattern : %{HOUR}:%{MINUTE}:%{SECOND} EXIM_MSG_SIZE \u00b6 Pattern : (S=%{NUMBER:exim_msg_size}) RUBY_LOGLEVEL \u00b6 Pattern : DEBUG|FATAL|ERROR|WARN|INFO BASE16NUM \u00b6 Pattern : [+-]?(?:0x)?(?:[0-9A-Fa-f]+) ISO8601_TIMEZONE \u00b6 Pattern : Z|[+-]%{HOUR}(?::?%{MINUTE}) REDISTIMESTAMP \u00b6 Pattern : %{MONTHDAY} %{MONTH} %{TIME} NAGIOS_EC_PROCESS_SERVICE_CHECK_RESULT \u00b6 Pattern : PROCESS_SERVICE_CHECK_RESULT SSHD_PACKET_CORRUPT \u00b6 Pattern : Disconnecting: Packet corrupt SYSLOG5424PRI \u00b6 Pattern : <%{NONNEGINT:syslog5424_pri}> EMAILADDRESS \u00b6 Pattern : %{EMAILLOCALPART}@%{HOSTNAME} MODSECRULEID \u00b6 Pattern : \\[id %{QUOTEDSTRING:ruleid}\\] SYSLOGTIMESTAMP \u00b6 Pattern : %{MONTH} +%{MONTHDAY} %{TIME} NAGIOS_EC_ENABLE_HOST_SVC_NOTIFICATIONS \u00b6 Pattern : ENABLE_HOST_SVC_NOTIFICATIONS NAGIOS_EC_DISABLE_HOST_SVC_NOTIFICATIONS \u00b6 Pattern : DISABLE_HOST_SVC_NOTIFICATIONS EXIM_HEADER_ID \u00b6 Pattern : (id=%{NOTSPACE:exim_header_id}) URIHOST \u00b6 Pattern : %{IPORHOST}(?::%{POSINT:port})? DATE \u00b6 Pattern : %{DATE_US}|%{DATE_EU}|%{DATE_X} SSHD_TUNN_TIMEOUT \u00b6 Pattern : Timeout, client not responding. MCOLLECTIVEAUDIT \u00b6 Pattern : %{TIMESTAMP_ISO8601:timestamp}: CISCOTAG \u00b6 Pattern : [A-Z0-9]+-%{INT}-(?:[A-Z0-9_]+) MODSECRULEREV \u00b6 Pattern : \\[rev %{QUOTEDSTRING:rulerev}\\] HAPROXYCAPTUREDREQUESTHEADERS \u00b6 Pattern : %{DATA:captured_request_headers} CISCO_INTERVAL \u00b6 Pattern : first hit|%{INT}-second interval DATE_X \u00b6 Pattern : %{YEAR}/%{MONTHNUM2}/%{MONTHDAY} SSHD_INIT \u00b6 Pattern : %{SSHD_LISTEN}|%{SSHD_TERMINATE} WINPATH \u00b6 Pattern : (?:[A-Za-z]+:|\\\\)(?:\\\\[^\\\\?*]*)+ HAPROXYCAPTUREDRESPONSEHEADERS \u00b6 Pattern : %{DATA:captured_response_headers} MODSECURI \u00b6 Pattern : \\[uri [\"']%{DATA:targeturi}[\"']\\] CISCO_DIRECTION \u00b6 Pattern : Inbound|inbound|Outbound|outbound MODSECRULEDATA \u00b6 Pattern : \\[data %{QUOTEDSTRING:ruledata}\\] MODSECRULELINE \u00b6 Pattern : \\[line %{QUOTEDSTRING:ruleline}\\] MODSECRULEFILE \u00b6 Pattern : \\[file %{QUOTEDSTRING:rulefile}\\] SECOND \u00b6 Pattern : (?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)? BACULA_LOG_CANCELLING \u00b6 Pattern : Cancelling duplicate JobId=%{INT}. MODSECRULEMSG \u00b6 Pattern : \\[msg %{QUOTEDSTRING:rulemessage}\\] SSHD_TUNN_ERR3 \u00b6 Pattern : error: bind: Address already in use BACULA_LOG_STARTRESTORE \u00b6 Pattern : Start Restore Job %{BACULA_JOB:job} SYSLOGLINE \u00b6 Pattern : %{SYSLOGBASE2} %{GREEDYDATA:message} COMMONMAC \u00b6 Pattern : (?:[A-Fa-f0-9]{2}:){5}[A-Fa-f0-9]{2} WINDOWSMAC \u00b6 Pattern : (?:[A-Fa-f0-9]{2}-){5}[A-Fa-f0-9]{2} SYSLOGPROG \u00b6 Pattern : %{PROG:program}(?:\\[%{POSINT:pid}\\])? JAVAMETHOD \u00b6 Pattern : (?:(<init>)|[a-zA-Z$_][a-zA-Z$_0-9]*) DATE_US \u00b6 Pattern : %{MONTHNUM}[/-]%{MONTHDAY}[/-]%{YEAR} CISCOMAC \u00b6 Pattern : (?:[A-Fa-f0-9]{4}\\.){2}[A-Fa-f0-9]{4} MODSECUID \u00b6 Pattern : \\[unique_id %{QUOTEDSTRING:uniqueid}\\] MAC \u00b6 Pattern : %{CISCOMAC}|%{WINDOWSMAC}|%{COMMONMAC} ELB_URIPATHPARAM \u00b6 Pattern : %{URIPATH:path}(?:%{URIPARAM:params})? BACULA_LOG_NOPRIOR \u00b6 Pattern : No prior Full backup Job record found. MODSECMATCHOFFSET \u00b6 Pattern : \\[offset %{QUOTEDSTRING:matchoffset}\\] BACULA_TIMESTAMP \u00b6 Pattern : %{MONTHDAY}-%{MONTH} %{HOUR}:%{MINUTE} MODSECHOSTNAME \u00b6 Pattern : \\[hostname ['\"]%{DATA:targethost}[\"']\\] TTY \u00b6 Pattern : /dev/(pts|tty([pq])?)(\\w+)?/?(?:[0-9]+) DATE_EU \u00b6 Pattern : %{MONTHDAY}[./-]%{MONTHNUM}[./-]%{YEAR} URIPATH \u00b6 Pattern : (?:/[A-Za-z0-9$.+!*'(){},~:;=@#%_\\-]*)+ HTTPD_ERRORLOG \u00b6 Pattern : %{HTTPD20_ERRORLOG}|%{HTTPD24_ERRORLOG} MONTHDAY \u00b6 Pattern : (?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9] BACULA_LOG_USEDEVICE \u00b6 Pattern : Using Device \\\"%{BACULA_DEVICE:device}\\\" RFC822Z \u00b6 Pattern : [0-3]\\d %{MONTH} %{YEAR} %{TIME} %{NUMTZ} MODSECRULESEVERITY \u00b6 Pattern : \\[severity [\"']%{WORD:ruleseverity}[\"']\\] ANSIC \u00b6 Pattern : %{DAY} %{MONTH} [_123]\\d %{TIME} %{YEAR}\" GENERICAPACHEERROR \u00b6 Pattern : %{APACHEERRORPREFIX} %{GREEDYDATA:message} SSHD_CONN_CLOSE \u00b6 Pattern : Connection closed by %{IP:sshd_client_ip}$ CISCOTIMESTAMP \u00b6 Pattern : %{MONTH} +%{MONTHDAY}(?: %{YEAR})? %{TIME} APACHEERRORTIME \u00b6 Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR} CISCOFW104004 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Switching to OK\\. HTTPDATE \u00b6 Pattern : %{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{INT} HTTPDERROR_DATE \u00b6 Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR} EXIM_QT \u00b6 Pattern : ((\\d+y)?(\\d+w)?(\\d+d)?(\\d+h)?(\\d+m)?(\\d+s)?) BACULA_LOG_NOJOBSTAT \u00b6 Pattern : Fatal error: No Job status returned from FD. NAGIOS_WARNING \u00b6 Pattern : Warning:%{SPACE}%{GREEDYDATA:nagios_message} EXIM_MSGID \u00b6 Pattern : [0-9A-Za-z]{6}-[0-9A-Za-z]{6}-[0-9A-Za-z]{2} BASE10NUM \u00b6 Pattern : [+-]?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+)) REDISLOG \u00b6 Pattern : \\[%{POSINT:pid}\\] %{REDISTIMESTAMP:time} \\*\\s URIPARAM \u00b6 Pattern : \\?[A-Za-z0-9$.+!*'|(){},~@#%&/=:;_?\\-\\[\\]<>]* COMBINEDAPACHELOG \u00b6 Pattern : %{COMMONAPACHELOG} %{QS:referrer} %{QS:agent} SYSLOGFACILITY \u00b6 Pattern : <%{NONNEGINT:facility}.%{NONNEGINT:priority}> RFC1123 \u00b6 Pattern : %{DAY}, [0-3]\\d %{MONTH} %{YEAR} %{TIME} %{TZ} UNIXDATE \u00b6 Pattern : %{DAY} %{MONTH} [_123]\\d %{TIME} %{TZ} %{YEAR} RFC850 \u00b6 Pattern : %{DAY}, [0-3]\\d-%{MONTH}-%{YEAR} %{TIME} %{TZ} SYSLOG5424LINE \u00b6 Pattern : %{SYSLOG5424BASE} +%{GREEDYDATA:syslog5424_msg} CISCOFW104003 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Switching to FAILED\\. RUBYDATE \u00b6 Pattern : %{DAY} %{MONTH} [0-3]\\d %{TIME} %{NUMTZ} %{YEAR} BACULA_LOG_NOOPEN \u00b6 Pattern : \\s+Cannot open %{DATA}: ERR=%{GREEDYDATA:berror} BACULA_LOG_STARTJOB \u00b6 Pattern : Start Backup JobId %{INT}, Job=%{BACULA_JOB:job} DATESTAMP_RFC822 \u00b6 Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{YEAR} %{TIME} %{TZ} DATESTAMP_OTHER \u00b6 Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{TZ} %{YEAR} RFC3339 \u00b6 Pattern : %{YEAR}-[01]\\d-[0-3]\\dT%{TIME}%{ISO8601_TIMEZONE} RFC1123Z \u00b6 Pattern : %{DAY}, [0-3]\\d %{MONTH} %{YEAR} %{TIME} %{NUMTZ} BACULA_LOG_NOSTAT \u00b6 Pattern : \\s+Could not stat %{DATA}: ERR=%{GREEDYDATA:berror} SSHD_TERMINATE \u00b6 Pattern : Received signal %{NUMBER:sshd_signal}; terminating. UUID \u00b6 Pattern : [A-Fa-f0-9]{8}-(?:[A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12} SSHD_LOGOUT_ERR \u00b6 Pattern : syslogin_perform_logout: logout\\(\\) returned an error RCONTROLLER \u00b6 Pattern : %{RAILS_CONSTROLLER:controller}#%{RAIL_ACTION:action} JAVACLASS \u00b6 Pattern : (?:[a-zA-Z$_][a-zA-Z$_0-9]*\\.)*[a-zA-Z$_][a-zA-Z$_0-9]* DATESTAMP_EVENTLOG \u00b6 Pattern : %{YEAR}%{MONTHNUM2}%{MONTHDAY}%{HOUR}%{MINUTE}%{SECOND} NGINXERRTIME \u00b6 Pattern : %{YEAR}/%{MONTHNUM2}/%{DAY2} %{HOUR}:%{MINUTE}:%{SECOND} BACULA_LOG_BEGIN_PRUNE_JOBS \u00b6 Pattern : Begin pruning Jobs older than %{INT} month %{INT} days . RFC3339NANO \u00b6 Pattern : %{YEAR}-[01]\\d-[0-3]\\dT%{TIME}\\.\\d{9}%{ISO8601_TIMEZONE} BACULA_LOG_MARKCANCEL \u00b6 Pattern : JobId %{INT}, Job %{BACULA_JOB:job} marked to be canceled. BACULA_LOG_NEW_VOLUME \u00b6 Pattern : Created new Volume \\\"%{BACULA_VOLUME:volume}\\\" in catalog. SSHD_TCPWRAP_FAIL5 \u00b6 Pattern : warning: can't get client address: Connection reset by peer EXIM_INTERFACE \u00b6 Pattern : (I=\\[%{IP:exim_interface}\\](:%{NUMBER:exim_interface_port})) BACULA_LOG_NOOPENDIR \u00b6 Pattern : \\s+Could not open directory %{DATA}: ERR=%{GREEDYDATA:berror} BACULA_LOG_CLIENT_RBJ \u00b6 Pattern : shell command: run ClientRunBeforeJob \\\"%{GREEDYDATA:runjob}\\\" SSHD_IDENT_FAIL \u00b6 Pattern : Did not receive identification string from %{IP:sshd_client_ip} DATESTAMP_RFC2822 \u00b6 Pattern : %{DAY}, %{MONTHDAY} %{MONTH} %{YEAR} %{TIME} %{ISO8601_TIMEZONE} BACULA_LOG_MAXSTART \u00b6 Pattern : Fatal error: Job canceled because max start delay time exceeded. QUOTEDSTRING \u00b6 Pattern : (\"(\\\\.|[^\\\\\"]+)+\")|\"\"|('(\\\\.|[^\\\\']+)+')|''|(`(\\\\.|[^\\\\`]+)+`)|`` REDISLOG2 \u00b6 Pattern : %{POSINT:pid}:M %{REDISTIMESTAMP:time} [*#] %{GREEDYDATA:message} BACULA_LOG_PRUNED_JOBS \u00b6 Pattern : Pruned %{INT} Jobs* for client %{BACULA_HOST:client} from catalog. RT_FLOW_EVENT \u00b6 Pattern : (RT_FLOW_SESSION_CREATE|RT_FLOW_SESSION_CLOSE|RT_FLOW_SESSION_DENY) BACULA_LOG_NOSUIT \u00b6 Pattern : No prior or suitable Full backup found in catalog. Doing FULL backup. CISCOFW302010 \u00b6 Pattern : %{INT:connection_count} in use, %{INT:connection_count_max} most used SSHD_INVAL_USER \u00b6 Pattern : Invalid user\\s*%{USERNAME:sshd_invalid_user}? from %{IP:sshd_client_ip} SSHD_SESSION_CLOSE \u00b6 Pattern : pam_unix\\(sshd:session\\): session closed for user %{USERNAME:sshd_user} MONGO_LOG \u00b6 Pattern : %{SYSLOGTIMESTAMP:timestamp} \\[%{WORD:component}\\] %{GREEDYDATA:message} BACULA_LOG_READYAPPEND \u00b6 Pattern : Ready to append to end of Volume \\\"%{BACULA_VOLUME:volume}\\\" size=%{INT} CRONLOG \u00b6 Pattern : %{SYSLOGBASE} \\(%{USER:user}\\) %{CRON_ACTION:action} \\(%{DATA:message}\\) BACULA_LOG_JOB \u00b6 Pattern : (Error: )?Bacula %{BACULA_HOST} %{BACULA_VERSION} \\(%{BACULA_VERSION}\\): SSHD_LISTEN \u00b6 Pattern : Server listening on %{IP:sshd_listen_ip} port %{NUMBER:sshd_listen_port}. URI \u00b6 Pattern : %{URIPROTO}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST})?(?:%{URIPATHPARAM})? RAILS3 \u00b6 Pattern : %{RAILS3HEAD}(?:%{RPROCESSING})?%{RAILS_CONTEXT:context}(?:%{RAILS3FOOT})? BASE16FLOAT \u00b6 Pattern : \\b[+-]?(?:0x)?(?:(?:[0-9A-Fa-f]+(?:\\.[0-9A-Fa-f]*)?)|(?:\\.[0-9A-Fa-f]+))\\b HAPROXYTIME \u00b6 Pattern : %{HOUR:haproxy_hour}:%{MINUTE:haproxy_minute}(?::%{SECOND:haproxy_second}) CISCOFW104001 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Switching to ACTIVE - %{GREEDYDATA:switch_reason} CATALINA_DATESTAMP \u00b6 Pattern : %{MONTH} %{MONTHDAY}, 20%{YEAR} %{HOUR}:?%{MINUTE}(?::?%{SECOND}) (?:AM|PM) CISCOFW105008 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Testing [Ii]nterface %{GREEDYDATA:interface_name} HOSTNAME \u00b6 Pattern : \\b[0-9A-Za-z][0-9A-Za-z-]{0,62}(?:\\.[0-9A-Za-z][0-9A-Za-z-]{0,62})*(\\.?|\\b) CISCOFW104002 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Switching to STANDBY - %{GREEDYDATA:switch_reason} BACULA_LOG_VOLUME_PREVWRITTEN \u00b6 Pattern : Volume \\\"%{BACULA_VOLUME:volume}\\\" previously written, moving to end of data. SSHD_BAD_VERSION \u00b6 Pattern : Bad protocol version identification '%{GREEDYDATA}' from %{IP:sshd_client_ip} BACULA_LOG_PRUNED_FILES \u00b6 Pattern : Pruned Files from %{INT} Jobs* for client %{BACULA_HOST:client} from catalog. SSHD_BADL_PREAUTH \u00b6 Pattern : Bad packet length %{NUMBER:sshd_packet_length}. \\[%{GREEDYDATA:sshd_privsep}\\] CATALINALOG \u00b6 Pattern : %{CATALINA_DATESTAMP:timestamp} %{JAVACLASS:class} %{JAVALOGMESSAGE:logmessage} RAILS_TIMESTAMP \u00b6 Pattern : %{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:%{MINUTE}:%{SECOND} %{ISO8601_TIMEZONE} SSHD_TUNN_ERR1 \u00b6 Pattern : error: connect_to %{IP:sshd_listen_ip} port %{NUMBER:sshd_listen_port}: failed. EXIM_DATE \u00b6 Pattern : %{YEAR:exim_year}-%{MONTHNUM:exim_month}-%{MONTHDAY:exim_day} %{TIME:exim_time} BACULA_LOG_DUPLICATE \u00b6 Pattern : Fatal error: JobId %{INT:duplicate} already running. Duplicate job not allowed. SSHD_REFUSE_CONN \u00b6 Pattern : refused connect from %{DATA:sshd_client_hostname} \\(%{IPORHOST:sshd_client_ip}\\) SSHD_TOOMANY_AUTH \u00b6 Pattern : Disconnecting: Too many authentication failures for %{USERNAME:sshd_invalid_user} BACULA_LOG_ALL_RECORDS_PRUNED \u00b6 Pattern : All records pruned from Volume \\\"%{BACULA_VOLUME:volume}\\\"; marking it \\\"Purged\\\" SSHD_DISR_PREAUTH \u00b6 Pattern : Disconnecting: %{GREEDYDATA:sshd_disconnect_status} \\[%{GREEDYDATA:sshd_privsep}\\] MCOLLECTIVE \u00b6 Pattern : ., \\[%{TIMESTAMP_ISO8601:timestamp} #%{POSINT:pid}\\]%{SPACE}%{LOGLEVEL:event_level} BACULA_LOG_DIFF_FS \u00b6 Pattern : \\s+%{UNIXPATH} is a different filesystem. Will not descend from %{UNIXPATH} into it. SSHD_TUNN_ERR2 \u00b6 Pattern : error: channel_setup_fwd_listener: cannot listen to port: %{NUMBER:sshd_listen_port} CISCOFW321001 \u00b6 Pattern : Resource '%{WORD:resource_name}' limit of %{POSINT:resource_limit} reached for system BACULA_LOG_NO_AUTH \u00b6 Pattern : Fatal error: Unable to authenticate with File daemon at %{HOSTNAME}. Possible causes: POSTGRESQL \u00b6 Pattern : %{DATESTAMP:timestamp} %{TZ} %{DATA:user_id} %{GREEDYDATA:connection_id} %{POSINT:pid} ELB_REQUEST_LINE \u00b6 Pattern : (?:%{WORD:verb} %{ELB_URI:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest}) SSHD_SESSION_OPEN \u00b6 Pattern : pam_unix\\(sshd:session\\): session opened for user %{USERNAME:sshd_user} by \\(uid=\\d+\\) TOMCAT_DATESTAMP \u00b6 Pattern : 20%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:?%{MINUTE}(?::?%{SECOND}) %{ISO8601_TIMEZONE} S3_REQUEST_LINE \u00b6 Pattern : (?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest}) RAILS3FOOT \u00b6 Pattern : Completed %{NUMBER:response}%{DATA} in %{NUMBER:totalms}ms %{RAILS3PROFILE}%{GREEDYDATA} CISCOFW105004 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Monitoring on [Ii]nterface %{GREEDYDATA:interface_name} normal CISCOFW105003 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Monitoring on [Ii]nterface %{GREEDYDATA:interface_name} waiting BACULA_LOG_JOBEND \u00b6 Pattern : Job write elapsed time = %{DATA:elapsed}, Transfer rate = %{NUMBER} (K|M|G)? Bytes/second TIMESTAMP_ISO8601 \u00b6 Pattern : %{YEAR}-%{MONTHNUM}-%{MONTHDAY}[T ]%{HOUR}:?%{MINUTE}(?::?%{SECOND})?%{ISO8601_TIMEZONE}? SYSLOGBASE \u00b6 Pattern : %{SYSLOGTIMESTAMP:timestamp} (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource} %{SYSLOGPROG}: SSHD_TUNN_ERR4 \u00b6 Pattern : error: channel_setup_fwd_listener_tcpip: cannot listen to port: %{NUMBER:sshd_listen_port} MODSECPREFIX \u00b6 Pattern : %{APACHEERRORPREFIX} ModSecurity: %{NOTSPACE:modsecseverity}\\. %{GREEDYDATA:modsecmessage} JAVASTACKTRACEPART \u00b6 Pattern : %{SPACE}at %{JAVACLASS:class}\\.%{JAVAMETHOD:method}\\(%{JAVAFILE:file}(?::%{NUMBER:line})?\\) EXIM_REMOTE_HOST \u00b6 Pattern : (H=(%{NOTSPACE:remote_hostname} )?(\\(%{NOTSPACE:remote_heloname}\\) )?\\[%{IP:remote_host}\\]) ELB_URI \u00b6 Pattern : %{URIPROTO:proto}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST:urihost})?(?:%{ELB_URIPATHPARAM})? DAY \u00b6 Pattern : Mon(?:day)?|Tue(?:sday)?|Wed(?:nesday)?|Thu(?:rsday)?|Fri(?:day)?|Sat(?:urday)?|Sun(?:day)? SSHD_TUNN \u00b6 Pattern : %{SSHD_TUNN_ERR1}|%{SSHD_TUNN_ERR2}|%{SSHD_TUNN_ERR3}|%{SSHD_TUNN_ERR4}|%{SSHD_TUNN_TIMEOUT} SSHD_SESSION_FAIL \u00b6 Pattern : pam_systemd\\(sshd:session\\): Failed to release session: %{GREEDYDATA:sshd_disconnect_status} BACULA_LOG_NOJOBS \u00b6 Pattern : There are no more Jobs associated with Volume \\\"%{BACULA_VOLUME:volume}\\\". Marking it purged. RPROCESSING \u00b6 Pattern : \\W*Processing by %{RCONTROLLER} as %{NOTSPACE:format}(?:\\W*Parameters: \\{\\%\\{DATA:params}}\\W*)? CISCOFW105009 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Testing on [Ii]nterface %{GREEDYDATA:interface_name} (?:Passed|Failed) SSHD_LOG \u00b6 Pattern : %{SSHD_INIT}|%{SSHD_NORMAL_LOG}|%{SSHD_PROBE_LOG}|%{SSHD_CORRUPTED}|%{SSHD_TUNN}|%{SSHD_PREAUTH} SSHD_DISC_PREAUTH \u00b6 Pattern : Disconnected from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|) SSHD_REST_PREAUTH \u00b6 Pattern : Connection reset by %{IP:sshd_client_ip} port %{NUMBER:sshd_port}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|) TOMCATLOG \u00b6 Pattern : %{TOMCAT_DATESTAMP:timestamp} \\| %{LOGLEVEL:level} \\| %{JAVACLASS:class} - %{JAVALOGMESSAGE:logmessage} SSHD_CLOS_PREAUTH \u00b6 Pattern : Connection closed by %{IP:sshd_client_ip} port %{NUMBER:sshd_port}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|) CISCO_TAGGED_SYSLOG \u00b6 Pattern : ^<%{POSINT:syslog_pri}>%{CISCOTIMESTAMP:timestamp}( %{SYSLOGHOST:sysloghost})? ?: %%{CISCOTAG:ciscotag}: SSHD_INVA_PREAUTH \u00b6 Pattern : input_userauth_request: invalid user %{USERNAME:sshd_invalid_user}?\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|) RAILS3HEAD \u00b6 Pattern : (?m)Started %{WORD:verb} \"%{URIPATHPARAM:request}\" for %{IPORHOST:clientip} at %{RAILS_TIMESTAMP:timestamp} CISCOFW105005 \u00b6 Pattern : \\((?:Primary|Secondary)\\) Lost Failover communications with mate on [Ii]nterface %{GREEDYDATA:interface_name} BACULA_LOG_NEW_LABEL \u00b6 Pattern : Labeled new Volume \\\"%{BACULA_VOLUME:volume}\\\" on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\). NAGIOS_EC_LINE_ENABLE_HOST_CHECK \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_HOST_CHECK:nagios_command};%{DATA:nagios_hostname} COWRIE_NEW_CO \u00b6 Pattern : New connection: %{IPV4:source_ip}:[0-9]+ \\(%{IPV4:dest_ip}:%{INT:dest_port}\\) \\[session: %{DATA:telnet_session}\\]$ CISCO_ACTION \u00b6 Pattern : Built|Teardown|Deny|Denied|denied|requested|permitted|denied by ACL|discarded|est-allowed|Dropping|created|deleted NAGIOS_EC_LINE_DISABLE_HOST_CHECK \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_HOST_CHECK:nagios_command};%{DATA:nagios_hostname} CISCOFW402117 \u00b6 Pattern : %{WORD:protocol}: Received a non-IPSec packet \\(protocol= %{WORD:orig_protocol}\\) from %{IP:src_ip} to %{IP:dst_ip} BACULA_LOG_WROTE_LABEL \u00b6 Pattern : Wrote label to prelabeled Volume \\\"%{BACULA_VOLUME:volume}\\\" on device \\\"%{BACULA_DEVICE}\\\" \\(%{BACULA_DEVICEPATH}\\) RAILS3PROFILE \u00b6 Pattern : (?:\\(Views: %{NUMBER:viewms}ms \\| ActiveRecord: %{NUMBER:activerecordms}ms|\\(ActiveRecord: %{NUMBER:activerecordms}ms)? CISCOFW500004 \u00b6 Pattern : %{CISCO_REASON:reason} for protocol=%{WORD:protocol}, from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} NAGIOS_TIMEPERIOD_TRANSITION \u00b6 Pattern : %{NAGIOS_TYPE_TIMEPERIOD_TRANSITION:nagios_type}: %{DATA:nagios_service};%{DATA:nagios_unknown1};%{DATA:nagios_unknown2} NAGIOS_PASSIVE_HOST_CHECK \u00b6 Pattern : %{NAGIOS_TYPE_PASSIVE_HOST_CHECK:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment} NAGIOS_HOST_DOWNTIME_ALERT \u00b6 Pattern : %{NAGIOS_TYPE_HOST_DOWNTIME_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment} NAGIOS_HOST_FLAPPING_ALERT \u00b6 Pattern : %{NAGIOS_TYPE_HOST_FLAPPING_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_message} HTTPD20_ERRORLOG \u00b6 Pattern : \\[%{HTTPDERROR_DATE:timestamp}\\] \\[%{LOGLEVEL:loglevel}\\] (?:\\[client %{IPORHOST:clientip}\\] ){0,1}%{GREEDYDATA:errormsg} NGINXERROR \u00b6 Pattern : %{NGINXERRTIME:time} \\[%{LOGLEVEL:loglevel}\\] %{NONNEGINT:pid}#%{NONNEGINT:tid}: (\\*%{NONNEGINT:cid} )?%{GREEDYDATA:message} MYSQL_AUTH_FAIL \u00b6 Pattern : %{TIMESTAMP_ISO8601:time} %{NUMBER} \\[Note\\] Access denied for user '%{DATA:user}'@'%{IP:source_ip}' \\(using password: YES\\) BACULA_LOG_MAX_CAPACITY \u00b6 Pattern : User defined maximum volume capacity %{BACULA_CAPACITY} exceeded on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\) NAGIOS_EC_LINE_ENABLE_HOST_NOTIFICATIONS \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_HOST_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname} HAPROXYDATE \u00b6 Pattern : %{MONTHDAY:haproxy_monthday}/%{MONTH:haproxy_month}/%{YEAR:haproxy_year}:%{HAPROXYTIME:haproxy_time}.%{INT:haproxy_milliseconds} CISCOFW106021 \u00b6 Pattern : %{CISCO_ACTION:action} %{WORD:protocol} reverse path check from %{IP:src_ip} to %{IP:dst_ip} on interface %{GREEDYDATA:interface} RUBY_LOGGER \u00b6 Pattern : [DFEWI], \\[%{TIMESTAMP_ISO8601:timestamp} #%{POSINT:pid}\\] *%{RUBY_LOGLEVEL:loglevel} -- +%{DATA:progname}: %{GREEDYDATA:message} NAGIOS_EC_LINE_DISABLE_HOST_NOTIFICATIONS \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_HOST_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname} CISCOFW110002 \u00b6 Pattern : %{CISCO_REASON:reason} for %{WORD:protocol} from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} NAGIOS_EC_LINE_ENABLE_HOST_SVC_NOTIFICATIONS \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_HOST_SVC_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname} NAGIOS_EC_LINE_DISABLE_HOST_SVC_NOTIFICATIONS \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_HOST_SVC_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname} SSHD_RMAP_FAIL \u00b6 Pattern : reverse mapping checking getaddrinfo for %{HOSTNAME:sshd_client_hostname} \\[%{IP:sshd_client_ip}\\] failed - POSSIBLE BREAK-IN ATTEMPT! HAPROXYHTTP \u00b6 Pattern : (?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) %{IPORHOST:syslog_server} %{SYSLOGPROG}: %{HAPROXYHTTPBASE} SSHD_USER_FAIL \u00b6 Pattern : Failed password for invalid user %{USERNAME:sshd_invalid_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol} SYSLOGBASE2 \u00b6 Pattern : (?:%{SYSLOGTIMESTAMP:timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource}+(?: %{SYSLOGPROG}:|) SSHD_NORMAL_LOG \u00b6 Pattern : %{SSHD_SUCCESS}|%{SSHD_DISCONNECT}|%{SSHD_CONN_CLOSE}|%{SSHD_SESSION_OPEN}|%{SSHD_SESSION_CLOSE}|%{SSHD_SESSION_FAIL}|%{SSHD_LOGOUT_ERR} SSHD_FAIL \u00b6 Pattern : Failed %{WORD:sshd_auth_type} for %{USERNAME:sshd_invalid_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol} NAGIOS_EC_LINE_ENABLE_SVC_CHECK \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_SVC_CHECK:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_service} NAGIOS_EC_LINE_DISABLE_SVC_CHECK \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_SVC_CHECK:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_service} CISCO_REASON \u00b6 Pattern : Duplicate TCP SYN|Failed to locate egress interface|Invalid transport field|No matching connection|DNS Response|DNS Query|(?:%{WORD}\\s*)* SSHD_CORRUPTED \u00b6 Pattern : %{SSHD_IDENT_FAIL}|%{SSHD_MAPB_FAIL}|%{SSHD_RMAP_FAIL}|%{SSHD_TOOMANY_AUTH}|%{SSHD_CORRUPT_MAC}|%{SSHD_PACKET_CORRUPT}|%{SSHD_BAD_VERSION} BACULA_LOG_NO_CONNECT \u00b6 Pattern : Warning: bsock.c:127 Could not connect to (Client: %{BACULA_HOST:client}|Storage daemon) on %{HOSTNAME}:%{POSINT}. ERR=%{GREEDYDATA:berror} SSHD_DISCONNECT \u00b6 Pattern : Received disconnect from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:%{NUMBER:sshd_disconnect_code}: %{GREEDYDATA:sshd_disconnect_status} SSHD_MAPB_FAIL \u00b6 Pattern : Address %{IP:sshd_client_ip} maps to %{HOSTNAME:sshd_client_hostname}, but this does not map back to the address - POSSIBLE BREAK-IN ATTEMPT! SSHD_TCPWRAP_FAIL2 \u00b6 Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: host name/address mismatch: %{IPORHOST:sshd_client_ip} != %{HOSTNAME:sshd_paranoid_hostname} MONGO3_LOG \u00b6 Pattern : %{TIMESTAMP_ISO8601:timestamp} %{MONGO3_SEVERITY:severity} %{MONGO3_COMPONENT:component}%{SPACE}(?:\\[%{DATA:context}\\])? %{GREEDYDATA:message} BACULA_LOG_FATAL_CONN \u00b6 Pattern : Fatal error: bsock.c:133 Unable to connect to (Client: %{BACULA_HOST:client}|Storage daemon) on %{HOSTNAME}:%{POSINT}. ERR=%{GREEDYDATA:berror} SSHD_TCPWRAP_FAIL4 \u00b6 Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: host name/name mismatch: reverse lookup results in non-FQDN %{HOSTNAME:sshd_paranoid_hostname} CISCOFW710001_710002_710003_710005_710006 \u00b6 Pattern : %{WORD:protocol} (?:request|access) %{CISCO_ACTION:action} from %{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port} NAGIOS_PASSIVE_SERVICE_CHECK \u00b6 Pattern : %{NAGIOS_TYPE_PASSIVE_SERVICE_CHECK:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment} NAGIOS_SERVICE_FLAPPING_ALERT \u00b6 Pattern : %{NAGIOS_TYPE_SERVICE_FLAPPING_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_message} NAGIOS_SERVICE_DOWNTIME_ALERT \u00b6 Pattern : %{NAGIOS_TYPE_SERVICE_DOWNTIME_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment} TCPDUMP_OUTPUT \u00b6 Pattern : %{GREEDYDATA:timestamp} IP %{IPORHOST:source_ip}\\.%{INT:source_port} > %{IPORHOST:dest_ip}\\.%{INT:dest_port}: Flags \\[%{GREEDYDATA:tcpflags}\\], seq SSHD_TCPWRAP_FAIL1 \u00b6 Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: can't verify hostname: getaddrinfo\\(%{DATA:sshd_paranoid_hostname}, %{DATA:sshd_sa_family}\\) failed SSHD_FAIL_PREAUTH \u00b6 Pattern : fatal: Unable to negotiate with %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:\\s*%{GREEDYDATA:sshd_disconnect_status}? \\[%{GREEDYDATA:sshd_privsep}\\] NAGIOS_EC_LINE_ENABLE_SVC_NOTIFICATIONS \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_SVC_NOTIFICATIONS:nagios_command};%{DATA:nagios_hostname};%{GREEDYDATA:nagios_service} SSHD_TCPWRAP_FAIL3 \u00b6 Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: host name/name mismatch: %{HOSTNAME:sshd_paranoid_hostname_1} != %{HOSTNAME:sshd_paranoid_hostname_2} NAGIOS_EC_LINE_DISABLE_SVC_NOTIFICATIONS \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_SVC_NOTIFICATIONS:nagios_command};%{DATA:nagios_hostname};%{GREEDYDATA:nagios_service} NAGIOS_HOST_EVENT_HANDLER \u00b6 Pattern : %{NAGIOS_TYPE_HOST_EVENT_HANDLER:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{DATA:nagios_event_handler_name} CISCOFW313001_313004_313008 \u00b6 Pattern : %{CISCO_ACTION:action} %{WORD:protocol} type=%{INT:icmp_type}, code=%{INT:icmp_code} from %{IP:src_ip} on interface %{DATA:interface}( to %{IP:dst_ip})? BACULA_LOG_END_VOLUME \u00b6 Pattern : End of medium on Volume \\\"%{BACULA_VOLUME:volume}\\\" Bytes=%{BACULA_CAPACITY} Blocks=%{BACULA_CAPACITY} at %{MONTHDAY}-%{MONTH}-%{YEAR} %{HOUR}:%{MINUTE}. SSHD_SUCCESS \u00b6 Pattern : Accepted %{WORD:sshd_auth_type} for %{USERNAME:sshd_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol}: %{GREEDYDATA:sshd_cipher} SMB_AUTH_FAIL \u00b6 Pattern : Auth:%{GREEDYDATA} user \\[%{DATA:smb_domain}\\]\\\\\\[%{DATA:user}\\]%{GREEDYDATA} status \\[NT_STATUS_NO_SUCH_USER\\]%{GREEDYDATA} remote host \\[ipv4:%{IP:ip_source} BACULA_LOG_NEW_MOUNT \u00b6 Pattern : New volume \\\"%{BACULA_VOLUME:volume}\\\" mounted on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\) at %{MONTHDAY}-%{MONTH}-%{YEAR} %{HOUR}:%{MINUTE}. NAGIOS_HOST_ALERT \u00b6 Pattern : %{NAGIOS_TYPE_HOST_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{NUMBER:nagios_attempt};%{GREEDYDATA:nagios_message} NAGIOS_HOST_NOTIFICATION \u00b6 Pattern : %{NAGIOS_TYPE_HOST_NOTIFICATION:nagios_type}: %{DATA:nagios_notifyname};%{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_contact};%{GREEDYDATA:nagios_message} SYSLOGPAMSESSION \u00b6 Pattern : %{SYSLOGBASE} %{GREEDYDATA:message}%{WORD:pam_module}\\(%{DATA:pam_caller}\\): session %{WORD:pam_session_state} for user %{USERNAME:username}(?: by %{GREEDYDATA:pam_by})? NAGIOS_CURRENT_HOST_STATE \u00b6 Pattern : %{NAGIOS_TYPE_CURRENT_HOST_STATE:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_statetype};%{DATA:nagios_statecode};%{GREEDYDATA:nagios_message} CISCOFW419002 \u00b6 Pattern : %{CISCO_REASON:reason} from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port} with different initial sequence number IPV4 \u00b6 Pattern : (?:(?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])) SSHD_FAI2_PREAUTH \u00b6 Pattern : fatal: %{GREEDYDATA:sshd_fatal_status}: Connection from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:\\s*%{GREEDYDATA:sshd_disconnect_status}? \\[%{GREEDYDATA:sshd_privsep}\\] APACHEERRORPREFIX \u00b6 Pattern : \\[%{APACHEERRORTIME:timestamp}\\] \\[%{NOTSPACE:apacheseverity}\\] (\\[pid %{INT}:tid %{INT}\\] )?\\[client %{IPORHOST:sourcehost}(:%{INT:source_port})?\\] (\\[client %{IPORHOST}\\])? NAGIOS_SERVICE_EVENT_HANDLER \u00b6 Pattern : %{NAGIOS_TYPE_SERVICE_EVENT_HANDLER:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{DATA:nagios_event_handler_name} NAGIOS_EC_LINE_PROCESS_HOST_CHECK_RESULT \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_PROCESS_HOST_CHECK_RESULT:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_check_result} SSHD_PROBE_LOG \u00b6 Pattern : %{SSHD_REFUSE_CONN}|%{SSHD_TCPWRAP_FAIL1}|%{SSHD_TCPWRAP_FAIL2}|%{SSHD_TCPWRAP_FAIL3}|%{SSHD_TCPWRAP_FAIL4}|%{SSHD_TCPWRAP_FAIL5}|%{SSHD_FAIL}|%{SSHD_USER_FAIL}|%{SSHD_INVAL_USER} NAXSI_EXLOG \u00b6 Pattern : ^NAXSI_EXLOG: ip=%{IPORHOST:naxsi_src_ip}&server=%{IPORHOST:naxsi_dst_ip}&uri=%{PATH:http_path}&id=%{INT:naxsi_id}&zone=%{WORD:naxsi_zone}&var_name=%{DATA:naxsi_var_name}&content= SSHD_RECE_PREAUTH \u00b6 Pattern : (?:error: |)Received disconnect from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:%{NUMBER:sshd_disconnect_code}: %{GREEDYDATA:sshd_disconnect_status}? \\[%{GREEDYDATA:sshd_privsep}\\] MONTH \u00b6 Pattern : \\bJan(?:uary|uar)?|Feb(?:ruary|ruar)?|M(?:a|\u00e4)?r(?:ch|z)?|Apr(?:il)?|Ma(?:y|i)?|Jun(?:e|i)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|O(?:c|k)?t(?:ober)?|Nov(?:ember)?|De(?:c|z)(?:ember)?\\b CISCOFW419001 \u00b6 Pattern : %{CISCO_ACTION:action} %{WORD:protocol} packet from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port}, reason: %{GREEDYDATA:reason} NAGIOS_SERVICE_ALERT \u00b6 Pattern : %{NAGIOS_TYPE_SERVICE_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{NUMBER:nagios_attempt};%{GREEDYDATA:nagios_message} CISCOFW106015 \u00b6 Pattern : %{CISCO_ACTION:action} %{WORD:protocol} \\(%{DATA:policy_id}\\) from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} flags %{DATA:tcp_flags} on interface %{GREEDYDATA:interface} CISCOFW602303_602304 \u00b6 Pattern : %{WORD:protocol}: An %{CISCO_DIRECTION:direction} %{GREEDYDATA:tunnel_type} SA \\(SPI= %{DATA:spi}\\) between %{IP:src_ip} and %{IP:dst_ip} \\(user= %{DATA:user}\\) has been %{CISCO_ACTION:action} NAGIOS_SERVICE_NOTIFICATION \u00b6 Pattern : %{NAGIOS_TYPE_SERVICE_NOTIFICATION:nagios_type}: %{DATA:nagios_notifyname};%{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_contact};%{GREEDYDATA:nagios_message} RT_FLOW3 \u00b6 Pattern : %{RT_FLOW_EVENT:event}: session denied %{IP:src-ip}/%{INT:src-port}->%{IP:dst-ip}/%{INT:dst-port} %{DATA:service} %{INT:protocol-id}\\(\\d\\) %{DATA:policy-name} %{DATA:from-zone} %{DATA:to-zone} .* NAGIOS_CURRENT_SERVICE_STATE \u00b6 Pattern : %{NAGIOS_TYPE_CURRENT_SERVICE_STATE:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_statetype};%{DATA:nagios_statecode};%{GREEDYDATA:nagios_message} CISCOFW713172 \u00b6 Pattern : Group = %{GREEDYDATA:group}, IP = %{IP:src_ip}, Automatic NAT Detection Status:\\s+Remote end\\s*%{DATA:is_remote_natted}\\s*behind a NAT device\\s+This\\s+end\\s*%{DATA:is_local_natted}\\s*behind a NAT device NAGIOS_EC_LINE_PROCESS_SERVICE_CHECK_RESULT \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_PROCESS_SERVICE_CHECK_RESULT:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_check_result} CISCOFW402119 \u00b6 Pattern : %{WORD:protocol}: Received an %{WORD:orig_protocol} packet \\(SPI= %{DATA:spi}, sequence number= %{DATA:seq_num}\\) from %{IP:src_ip} \\(user= %{DATA:user}\\) to %{IP:dst_ip} that failed anti-replay checking SSHD_PREAUTH \u00b6 Pattern : %{SSHD_DISC_PREAUTH}|%{SSHD_RECE_PREAUTH}|%{SSHD_MAXE_PREAUTH}|%{SSHD_DISR_PREAUTH}|%{SSHD_INVA_PREAUTH}|%{SSHD_REST_PREAUTH}|%{SSHD_FAIL_PREAUTH}|%{SSHD_CLOS_PREAUTH}|%{SSHD_FAI2_PREAUTH}|%{SSHD_BADL_PREAUTH} COMMONAPACHELOG \u00b6 Pattern : %{IPORHOST:clientip} %{HTTPDUSER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) SSHD_MAXE_PREAUTH \u00b6 Pattern : error: maximum authentication attempts exceeded for (?:invalid user |)%{USERNAME:sshd_invalid_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|) CISCOFW106001 \u00b6 Pattern : %{CISCO_DIRECTION:direction} %{WORD:protocol} connection %{CISCO_ACTION:action} from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} flags %{GREEDYDATA:tcp_flags} on interface %{GREEDYDATA:interface} LOGLEVEL \u00b6 Pattern : [Aa]lert|ALERT|[Tt]race|TRACE|[Dd]ebug|DEBUG|[Nn]otice|NOTICE|[Ii]nfo|INFO|[Ww]arn?(?:ing)?|WARN?(?:ING)?|[Ee]rr?(?:or)?|ERR?(?:OR)?|[Cc]rit?(?:ical)?|CRIT?(?:ICAL)?|[Ff]atal|FATAL|[Ss]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)? CISCOFW305011 \u00b6 Pattern : %{CISCO_ACTION:action} %{CISCO_XLATE_TYPE:xlate_type} %{WORD:protocol} translation from %{DATA:src_interface}:%{IP:src_ip}(/%{INT:src_port})?(\\(%{DATA:src_fwuser}\\))? to %{DATA:src_xlated_interface}:%{IP:src_xlated_ip}/%{DATA:src_xlated_port} MONGO_SLOWQUERY \u00b6 Pattern : %{WORD} %{MONGO_WORDDASH:database}\\.%{MONGO_WORDDASH:collection} %{WORD}: %{MONGO_QUERY:query} %{WORD}:%{NONNEGINT:ntoreturn} %{WORD}:%{NONNEGINT:ntoskip} %{WORD}:%{NONNEGINT:nscanned}.*nreturned:%{NONNEGINT:nreturned}..+ %{POSINT:duration}ms NAXSI_FMT \u00b6 Pattern : ^NAXSI_FMT: ip=%{IPORHOST:src_ip}&server=%{IPORHOST:target_ip}&uri=%{PATH:http_path}&learning=\\d&vers=%{DATA:naxsi_version}&total_processed=\\d+&total_blocked=\\d+&block=\\d+(&cscore\\d=%{WORD:score_label}&score\\d=%{INT:score})+&zone0=%{WORD:zone} CISCOFW106014 \u00b6 Pattern : %{CISCO_ACTION:action} %{CISCO_DIRECTION:direction} %{WORD:protocol} src %{DATA:src_interface}:%{IP:src_ip}(\\(%{DATA:src_fwuser}\\))? dst %{DATA:dst_interface}:%{IP:dst_ip}(\\(%{DATA:dst_fwuser}\\))? \\(type %{INT:icmp_type}, code %{INT:icmp_code}\\) NGINXACCESS \u00b6 Pattern : %{IPORHOST:remote_addr} - %{NGUSER:remote_user} \\[%{HTTPDATE:time_local}\\] \"%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}\" %{NUMBER:status} %{NUMBER:body_bytes_sent} \"%{NOTDQUOTE:http_referer}\" \"%{NOTDQUOTE:http_user_agent}\" EXIM_EXCLUDE_TERMS \u00b6 Pattern : (Message is frozen|(Start|End) queue run| Warning: | retry time not reached | no (IP address|host name) found for (IP address|host) | unexpected disconnection while reading SMTP command | no immediate delivery: |another process is handling this message) CISCOFW302020_302021 \u00b6 Pattern : %{CISCO_ACTION:action}(?: %{CISCO_DIRECTION:direction})? %{WORD:protocol} connection for faddr %{IP:dst_ip}/%{INT:icmp_seq_num}(?:\\(%{DATA:fwuser}\\))? gaddr %{IP:src_xlated_ip}/%{INT:icmp_code_xlated} laddr %{IP:src_ip}/%{INT:icmp_code}( \\(%{DATA:user}\\))? CISCOFW106006_106007_106010 \u00b6 Pattern : %{CISCO_ACTION:action} %{CISCO_DIRECTION:direction} %{WORD:protocol} (?:from|src) %{IP:src_ip}/%{INT:src_port}(\\(%{DATA:src_fwuser}\\))? (?:to|dst) %{IP:dst_ip}/%{INT:dst_port}(\\(%{DATA:dst_fwuser}\\))? (?:on interface %{DATA:interface}|due to %{CISCO_REASON:reason}) HTTPD24_ERRORLOG \u00b6 Pattern : \\[%{HTTPDERROR_DATE:timestamp}\\] \\[%{WORD:module}:%{LOGLEVEL:loglevel}\\] \\[pid %{POSINT:pid}:tid %{NUMBER:tid}\\]( \\(%{POSINT:proxy_errorcode}\\)%{DATA:proxy_errormessage}:)?( \\[client %{IPORHOST:client}:%{POSINT:clientport}\\])? %{DATA:errorcode}: %{GREEDYDATA:message} MODSECAPACHEERROR \u00b6 Pattern : %{MODSECPREFIX} %{MODSECRULEFILE} %{MODSECRULELINE} (?:%{MODSECMATCHOFFSET} )?(?:%{MODSECRULEID} )?(?:%{MODSECRULEREV} )?(?:%{MODSECRULEMSG} )?(?:%{MODSECRULEDATA} )?(?:%{MODSECRULESEVERITY} )?(?:%{MODSECRULEVERS} )?%{MODSECRULETAGS}%{MODSECHOSTNAME} %{MODSECURI} %{MODSECUID} NAGIOS_EC_LINE_SCHEDULE_HOST_DOWNTIME \u00b6 Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_SCHEDULE_HOST_DOWNTIME:nagios_command};%{DATA:nagios_hostname};%{NUMBER:nagios_start_time};%{NUMBER:nagios_end_time};%{NUMBER:nagios_fixed};%{NUMBER:nagios_trigger_id};%{NUMBER:nagios_duration};%{DATA:author};%{DATA:comment} SYSLOG5424BASE \u00b6 Pattern : %{SYSLOG5424PRI}%{NONNEGINT:syslog5424_ver} +(?:%{TIMESTAMP_ISO8601:syslog5424_ts}|-) +(?:%{HOSTNAME:syslog5424_host}|-) +(-|%{SYSLOG5424PRINTASCII:syslog5424_app}) +(-|%{SYSLOG5424PRINTASCII:syslog5424_proc}) +(-|%{SYSLOG5424PRINTASCII:syslog5424_msgid}) +(?:%{SYSLOG5424SD:syslog5424_sd}|-|) CISCOFW106100_2_3 \u00b6 Pattern : access-list %{NOTSPACE:policy_id} %{CISCO_ACTION:action} %{WORD:protocol} for user '%{DATA:src_fwuser}' %{DATA:src_interface}/%{IP:src_ip}\\(%{INT:src_port}\\) -> %{DATA:dst_interface}/%{IP:dst_ip}\\(%{INT:dst_port}\\) hit-cnt %{INT:hit_count} %{CISCO_INTERVAL:interval} \\[%{DATA:hashcode1}, %{DATA:hashcode2}\\] CISCOFW106100 \u00b6 Pattern : access-list %{NOTSPACE:policy_id} %{CISCO_ACTION:action} %{WORD:protocol} %{DATA:src_interface}/%{IP:src_ip}\\(%{INT:src_port}\\)(\\(%{DATA:src_fwuser}\\))? -> %{DATA:dst_interface}/%{IP:dst_ip}\\(%{INT:dst_port}\\)(\\(%{DATA:src_fwuser}\\))? hit-cnt %{INT:hit_count} %{CISCO_INTERVAL:interval} \\[%{DATA:hashcode1}, %{DATA:hashcode2}\\] RT_FLOW2 \u00b6 Pattern : %{RT_FLOW_EVENT:event}: session created %{IP:src-ip}/%{INT:src-port}->%{IP:dst-ip}/%{INT:dst-port} %{DATA:service} %{IP:nat-src-ip}/%{INT:nat-src-port}->%{IP:nat-dst-ip}/%{INT:nat-dst-port} %{DATA:src-nat-rule-name} %{DATA:dst-nat-rule-name} %{INT:protocol-id} %{DATA:policy-name} %{DATA:from-zone} %{DATA:to-zone} %{INT:session-id} .* CISCOFW733100 \u00b6 Pattern : \\[\\s*%{DATA:drop_type}\\s*\\] drop %{DATA:drop_rate_id} exceeded. Current burst rate is %{INT:drop_rate_current_burst} per second, max configured rate is %{INT:drop_rate_max_burst}; Current average rate is %{INT:drop_rate_current_avg} per second, max configured rate is %{INT:drop_rate_max_avg}; Cumulative total count is %{INT:drop_total_count} CISCOFW106023 \u00b6 Pattern : %{CISCO_ACTION:action}( protocol)? %{WORD:protocol} src %{DATA:src_interface}:%{DATA:src_ip}(/%{INT:src_port})?(\\(%{DATA:src_fwuser}\\))? dst %{DATA:dst_interface}:%{DATA:dst_ip}(/%{INT:dst_port})?(\\(%{DATA:dst_fwuser}\\))?( \\(type %{INT:icmp_type}, code %{INT:icmp_code}\\))? by access-group \"?%{DATA:policy_id}\"? \\[%{DATA:hashcode1}, %{DATA:hashcode2}\\] ELB_ACCESS_LOG \u00b6 Pattern : %{TIMESTAMP_ISO8601:timestamp} %{NOTSPACE:elb} %{IP:clientip}:%{INT:clientport:int} (?:(%{IP:backendip}:?:%{INT:backendport:int})|-) %{NUMBER:request_processing_time:float} %{NUMBER:backend_processing_time:float} %{NUMBER:response_processing_time:float} %{INT:response:int} %{INT:backend_response:int} %{INT:received_bytes:int} %{INT:bytes:int} \"%{ELB_REQUEST_LINE}\" MODSECRULETAGS \u00b6 Pattern : (?:\\[tag %{QUOTEDSTRING:ruletag0}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag1}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag2}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag3}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag4}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag5}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag6}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag7}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag8}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag9}\\] )?(?:\\[tag %{QUOTEDSTRING}\\] )* RT_FLOW1 \u00b6 Pattern : %{RT_FLOW_EVENT:event}: %{GREEDYDATA:close-reason}: %{IP:src-ip}/%{INT:src-port}->%{IP:dst-ip}/%{INT:dst-port} %{DATA:service} %{IP:nat-src-ip}/%{INT:nat-src-port}->%{IP:nat-dst-ip}/%{INT:nat-dst-port} %{DATA:src-nat-rule-name} %{DATA:dst-nat-rule-name} %{INT:protocol-id} %{DATA:policy-name} %{DATA:from-zone} %{DATA:to-zone} %{INT:session-id} \\d+\\(%{DATA:sent}\\) \\d+\\(%{DATA:received}\\) %{INT:elapsed-time} .* BRO_CONN \u00b6 Pattern : %{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:service}\\t%{NUMBER:duration}\\t%{NUMBER:orig_bytes}\\t%{NUMBER:resp_bytes}\\t%{GREEDYDATA:conn_state}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:missed_bytes}\\t%{GREEDYDATA:history}\\t%{GREEDYDATA:orig_pkts}\\t%{GREEDYDATA:orig_ip_bytes}\\t%{GREEDYDATA:resp_pkts}\\t%{GREEDYDATA:resp_ip_bytes}\\t%{GREEDYDATA:tunnel_parents} S3_ACCESS_LOG \u00b6 Pattern : %{WORD:owner} %{NOTSPACE:bucket} \\[%{HTTPDATE:timestamp}\\] %{IP:clientip} %{NOTSPACE:requester} %{NOTSPACE:request_id} %{NOTSPACE:operation} %{NOTSPACE:key} (?:\"%{S3_REQUEST_LINE}\"|-) (?:%{INT:response:int}|-) (?:-|%{NOTSPACE:error_code}) (?:%{INT:bytes:int}|-) (?:%{INT:object_size:int}|-) (?:%{INT:request_time_ms:int}|-) (?:%{INT:turnaround_time_ms:int}|-) (?:%{QS:referrer}|-) (?:\"?%{QS:agent}\"?|-) (?:-|%{NOTSPACE:version_id}) BRO_DNS \u00b6 Pattern : %{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{INT:trans_id}\\t%{GREEDYDATA:query}\\t%{GREEDYDATA:qclass}\\t%{GREEDYDATA:qclass_name}\\t%{GREEDYDATA:qtype}\\t%{GREEDYDATA:qtype_name}\\t%{GREEDYDATA:rcode}\\t%{GREEDYDATA:rcode_name}\\t%{GREEDYDATA:AA}\\t%{GREEDYDATA:TC}\\t%{GREEDYDATA:RD}\\t%{GREEDYDATA:RA}\\t%{GREEDYDATA:Z}\\t%{GREEDYDATA:answers}\\t%{GREEDYDATA:TTLs}\\t%{GREEDYDATA:rejected} CISCOFW302013_302014_302015_302016 \u00b6 Pattern : %{CISCO_ACTION:action}(?: %{CISCO_DIRECTION:direction})? %{WORD:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port}( \\(%{IP:src_mapped_ip}/%{INT:src_mapped_port}\\))?(\\(%{DATA:src_fwuser}\\))? to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port}( \\(%{IP:dst_mapped_ip}/%{INT:dst_mapped_port}\\))?(\\(%{DATA:dst_fwuser}\\))?( duration %{TIME:duration} bytes %{INT:bytes})?(?: %{CISCO_REASON:reason})?( \\(%{DATA:user}\\))? SHOREWALL \u00b6 Pattern : (%{SYSLOGTIMESTAMP:timestamp}) (%{WORD:nf_host}) kernel:.*Shorewall:(%{WORD:nf_action1})?:(%{WORD:nf_action2})?.*IN=(%{USERNAME:nf_in_interface})?.*(OUT= *MAC=(%{COMMONMAC:nf_dst_mac}):(%{COMMONMAC:nf_src_mac})?|OUT=%{USERNAME:nf_out_interface}).*SRC=(%{IPV4:nf_src_ip}).*DST=(%{IPV4:nf_dst_ip}).*LEN=(%{WORD:nf_len}).*?TOS=(%{WORD:nf_tos}).*?PREC=(%{WORD:nf_prec}).*?TTL=(%{INT:nf_ttl}).*?ID=(%{INT:nf_id}).*?PROTO=(%{WORD:nf_protocol}).*?SPT=(%{INT:nf_src_port}?.*DPT=%{INT:nf_dst_port}?.*) HAPROXYTCP \u00b6 Pattern : (?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) %{IPORHOST:syslog_server} %{SYSLOGPROG}: %{IP:client_ip}:%{INT:client_port} \\[%{HAPROXYDATE:accept_date}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{INT:time_queue}/%{INT:time_backend_connect}/%{NOTSPACE:time_duration} %{NOTSPACE:bytes_read} %{NOTSPACE:termination_state} %{INT:actconn}/%{INT:feconn}/%{INT:beconn}/%{INT:srvconn}/%{NOTSPACE:retries} %{INT:srv_queue}/%{INT:backend_queue} CISCOFW313005 \u00b6 Pattern : %{CISCO_REASON:reason} for %{WORD:protocol} error message: %{WORD:err_protocol} src %{DATA:err_src_interface}:%{IP:err_src_ip}(\\(%{DATA:err_src_fwuser}\\))? dst %{DATA:err_dst_interface}:%{IP:err_dst_ip}(\\(%{DATA:err_dst_fwuser}\\))? \\(type %{INT:err_icmp_type}, code %{INT:err_icmp_code}\\) on %{DATA:interface} interface\\. Original IP payload: %{WORD:protocol} src %{IP:orig_src_ip}/%{INT:orig_src_port}(\\(%{DATA:orig_src_fwuser}\\))? dst %{IP:orig_dst_ip}/%{INT:orig_dst_port}(\\(%{DATA:orig_dst_fwuser}\\))? BRO_FILES \u00b6 Pattern : %{NUMBER:ts}\\t%{NOTSPACE:fuid}\\t%{IP:tx_hosts}\\t%{IP:rx_hosts}\\t%{NOTSPACE:conn_uids}\\t%{GREEDYDATA:source}\\t%{GREEDYDATA:depth}\\t%{GREEDYDATA:analyzers}\\t%{GREEDYDATA:mime_type}\\t%{GREEDYDATA:filename}\\t%{GREEDYDATA:duration}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:is_orig}\\t%{GREEDYDATA:seen_bytes}\\t%{GREEDYDATA:total_bytes}\\t%{GREEDYDATA:missing_bytes}\\t%{GREEDYDATA:overflow_bytes}\\t%{GREEDYDATA:timedout}\\t%{GREEDYDATA:parent_fuid}\\t%{GREEDYDATA:md5}\\t%{GREEDYDATA:sha1}\\t%{GREEDYDATA:sha256}\\t%{GREEDYDATA:extracted} BRO_HTTP \u00b6 Pattern : %{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:method}\\t%{GREEDYDATA:domain}\\t%{GREEDYDATA:uri}\\t%{GREEDYDATA:referrer}\\t%{GREEDYDATA:user_agent}\\t%{NUMBER:request_body_len}\\t%{NUMBER:response_body_len}\\t%{GREEDYDATA:status_code}\\t%{GREEDYDATA:status_msg}\\t%{GREEDYDATA:info_code}\\t%{GREEDYDATA:info_msg}\\t%{GREEDYDATA:filename}\\t%{GREEDYDATA:bro_tags}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:proxied}\\t%{GREEDYDATA:orig_fuids}\\t%{GREEDYDATA:orig_mime_types}\\t%{GREEDYDATA:resp_fuids}\\t%{GREEDYDATA:resp_mime_types} NETSCREENSESSIONLOG \u00b6 Pattern : %{SYSLOGTIMESTAMP:date} %{IPORHOST:device} %{IPORHOST}: NetScreen device_id=%{WORD:device_id}%{DATA}: start_time=%{QUOTEDSTRING:start_time} duration=%{INT:duration} policy_id=%{INT:policy_id} service=%{DATA:service} proto=%{INT:proto} src zone=%{WORD:src_zone} dst zone=%{WORD:dst_zone} action=%{WORD:action} sent=%{INT:sent} rcvd=%{INT:rcvd} src=%{IPORHOST:src_ip} dst=%{IPORHOST:dst_ip} src_port=%{INT:src_port} dst_port=%{INT:dst_port} src-xlated ip=%{IPORHOST:src_xlated_ip} port=%{INT:src_xlated_port} dst-xlated ip=%{IPORHOST:dst_xlated_ip} port=%{INT:dst_xlated_port} session_id=%{INT:session_id} reason=%{GREEDYDATA:reason} HAPROXYHTTPBASE \u00b6 Pattern : %{IP:client_ip}:%{INT:client_port} \\[%{HAPROXYDATE:accept_date}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{INT:time_request}/%{INT:time_queue}/%{INT:time_backend_connect}/%{INT:time_backend_response}/%{NOTSPACE:time_duration} %{INT:http_status_code} %{NOTSPACE:bytes_read} %{DATA:captured_request_cookie} %{DATA:captured_response_cookie} %{NOTSPACE:termination_state} %{INT:actconn}/%{INT:feconn}/%{INT:beconn}/%{INT:srvconn}/%{NOTSPACE:retries} %{INT:srv_queue}/%{INT:backend_queue} (\\\\{\\%\\{HAPROXYCAPTUREDREQUESTHEADERS}\\})?( )?(\\\\{\\%\\{HAPROXYCAPTUREDRESPONSEHEADERS}\\})?( )?\"(<BADREQ>|(%{WORD:http_verb} (%{URIPROTO:http_proto}://)?(?:%{USER:http_user}(?::[^@]*)?@)?(?:%{URIHOST:http_host})?(?:%{URIPATHPARAM:http_request})?( HTTP/%{NUMBER:http_version})?))?\" BACULA_LOGLINE \u00b6 Pattern : %{BACULA_TIMESTAMP:bts} %{BACULA_HOST:hostname} JobId %{INT:jobid}: (%{BACULA_LOG_MAX_CAPACITY}|%{BACULA_LOG_END_VOLUME}|%{BACULA_LOG_NEW_VOLUME}|%{BACULA_LOG_NEW_LABEL}|%{BACULA_LOG_WROTE_LABEL}|%{BACULA_LOG_NEW_MOUNT}|%{BACULA_LOG_NOOPEN}|%{BACULA_LOG_NOOPENDIR}|%{BACULA_LOG_NOSTAT}|%{BACULA_LOG_NOJOBS}|%{BACULA_LOG_ALL_RECORDS_PRUNED}|%{BACULA_LOG_BEGIN_PRUNE_JOBS}|%{BACULA_LOG_BEGIN_PRUNE_FILES}|%{BACULA_LOG_PRUNED_JOBS}|%{BACULA_LOG_PRUNED_FILES}|%{BACULA_LOG_ENDPRUNE}|%{BACULA_LOG_STARTJOB}|%{BACULA_LOG_STARTRESTORE}|%{BACULA_LOG_USEDEVICE}|%{BACULA_LOG_DIFF_FS}|%{BACULA_LOG_JOBEND}|%{BACULA_LOG_NOPRUNE_JOBS}|%{BACULA_LOG_NOPRUNE_FILES}|%{BACULA_LOG_VOLUME_PREVWRITTEN}|%{BACULA_LOG_READYAPPEND}|%{BACULA_LOG_CANCELLING}|%{BACULA_LOG_MARKCANCEL}|%{BACULA_LOG_CLIENT_RBJ}|%{BACULA_LOG_VSS}|%{BACULA_LOG_MAXSTART}|%{BACULA_LOG_DUPLICATE}|%{BACULA_LOG_NOJOBSTAT}|%{BACULA_LOG_FATAL_CONN}|%{BACULA_LOG_NO_CONNECT}|%{BACULA_LOG_NO_AUTH}|%{BACULA_LOG_NOSUIT}|%{BACULA_LOG_JOB}|%{BACULA_LOG_NOPRIOR}) NAGIOSLOGLINE \u00b6 Pattern : %{NAGIOSTIME} (?:%{NAGIOS_WARNING}|%{NAGIOS_CURRENT_SERVICE_STATE}|%{NAGIOS_CURRENT_HOST_STATE}|%{NAGIOS_SERVICE_NOTIFICATION}|%{NAGIOS_HOST_NOTIFICATION}|%{NAGIOS_SERVICE_ALERT}|%{NAGIOS_HOST_ALERT}|%{NAGIOS_SERVICE_FLAPPING_ALERT}|%{NAGIOS_HOST_FLAPPING_ALERT}|%{NAGIOS_SERVICE_DOWNTIME_ALERT}|%{NAGIOS_HOST_DOWNTIME_ALERT}|%{NAGIOS_PASSIVE_SERVICE_CHECK}|%{NAGIOS_PASSIVE_HOST_CHECK}|%{NAGIOS_SERVICE_EVENT_HANDLER}|%{NAGIOS_HOST_EVENT_HANDLER}|%{NAGIOS_TIMEPERIOD_TRANSITION}|%{NAGIOS_EC_LINE_DISABLE_SVC_CHECK}|%{NAGIOS_EC_LINE_ENABLE_SVC_CHECK}|%{NAGIOS_EC_LINE_DISABLE_HOST_CHECK}|%{NAGIOS_EC_LINE_ENABLE_HOST_CHECK}|%{NAGIOS_EC_LINE_PROCESS_HOST_CHECK_RESULT}|%{NAGIOS_EC_LINE_PROCESS_SERVICE_CHECK_RESULT}|%{NAGIOS_EC_LINE_SCHEDULE_HOST_DOWNTIME}|%{NAGIOS_EC_LINE_DISABLE_HOST_SVC_NOTIFICATIONS}|%{NAGIOS_EC_LINE_ENABLE_HOST_SVC_NOTIFICATIONS}|%{NAGIOS_EC_LINE_DISABLE_HOST_NOTIFICATIONS}|%{NAGIOS_EC_LINE_ENABLE_HOST_NOTIFICATIONS}|%{NAGIOS_EC_LINE_DISABLE_SVC_NOTIFICATIONS}|%{NAGIOS_EC_LINE_ENABLE_SVC_NOTIFICATIONS}) IPV6 \u00b6 Pattern : ((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)? Documentation generation \u00b6 This documentation is generated by pkg/parser : GO_WANT_TEST_DOC=1 go test -run TestGeneratePatternsDoc","title":"Patterns references"},{"location":"references/patterns-documentation.html#patterns-documentation","text":"You will find here a generated documentation of all the patterns loaded by crowdsec. They are sorted by pattern length, and are meant to be used in parsers, in the form %{PATTERN_NAME}.","title":"Patterns documentation"},{"location":"references/patterns-documentation.html#mongo3_severity","text":"Pattern : \\w","title":"MONGO3_SEVERITY"},{"location":"references/patterns-documentation.html#greedydata","text":"Pattern : .*","title":"GREEDYDATA"},{"location":"references/patterns-documentation.html#data","text":"Pattern : .*?","title":"DATA"},{"location":"references/patterns-documentation.html#notspace","text":"Pattern : \\S+","title":"NOTSPACE"},{"location":"references/patterns-documentation.html#space","text":"Pattern : \\s*","title":"SPACE"},{"location":"references/patterns-documentation.html#rail_action","text":"Pattern : \\w+","title":"RAIL_ACTION"},{"location":"references/patterns-documentation.html#javalogmessage","text":"Pattern : (.*)","title":"JAVALOGMESSAGE"},{"location":"references/patterns-documentation.html#day2","text":"Pattern : \\d{2}","title":"DAY2"},{"location":"references/patterns-documentation.html#notdquote","text":"Pattern : [^\"]*","title":"NOTDQUOTE"},{"location":"references/patterns-documentation.html#rails_constroller","text":"Pattern : [^#]+","title":"RAILS_CONSTROLLER"},{"location":"references/patterns-documentation.html#ruuid","text":"Pattern : \\s{32}","title":"RUUID"},{"location":"references/patterns-documentation.html#syslog5424printascii","text":"Pattern : [!-~]+","title":"SYSLOG5424PRINTASCII"},{"location":"references/patterns-documentation.html#bacula_version","text":"Pattern : %{USER}","title":"BACULA_VERSION"},{"location":"references/patterns-documentation.html#word","text":"Pattern : \\b\\w+\\b","title":"WORD"},{"location":"references/patterns-documentation.html#bacula_job","text":"Pattern : %{USER}","title":"BACULA_JOB"},{"location":"references/patterns-documentation.html#cron_action","text":"Pattern : [A-Z ]+","title":"CRON_ACTION"},{"location":"references/patterns-documentation.html#bacula_volume","text":"Pattern : %{USER}","title":"BACULA_VOLUME"},{"location":"references/patterns-documentation.html#bacula_device","text":"Pattern : %{USER}","title":"BACULA_DEVICE"},{"location":"references/patterns-documentation.html#tz","text":"Pattern : [A-Z]{3}","title":"TZ"},{"location":"references/patterns-documentation.html#numtz","text":"Pattern : [+-]\\d{4}","title":"NUMTZ"},{"location":"references/patterns-documentation.html#mongo3_component","text":"Pattern : %{WORD}|-","title":"MONGO3_COMPONENT"},{"location":"references/patterns-documentation.html#mongo_worddash","text":"Pattern : \\b[\\w-]+\\b","title":"MONGO_WORDDASH"},{"location":"references/patterns-documentation.html#nagios_type_host_alert","text":"Pattern : HOST ALERT","title":"NAGIOS_TYPE_HOST_ALERT"},{"location":"references/patterns-documentation.html#nonnegint","text":"Pattern : \\b[0-9]+\\b","title":"NONNEGINT"},{"location":"references/patterns-documentation.html#minute","text":"Pattern : [0-5][0-9]","title":"MINUTE"},{"location":"references/patterns-documentation.html#bacula_devicepath","text":"Pattern : %{UNIXPATH}","title":"BACULA_DEVICEPATH"},{"location":"references/patterns-documentation.html#sysloghost","text":"Pattern : %{IPORHOST}","title":"SYSLOGHOST"},{"location":"references/patterns-documentation.html#redislog1","text":"Pattern : %{REDISLOG}","title":"REDISLOG1"},{"location":"references/patterns-documentation.html#user","text":"Pattern : %{USERNAME}","title":"USER"},{"location":"references/patterns-documentation.html#number","text":"Pattern : %{BASE10NUM}","title":"NUMBER"},{"location":"references/patterns-documentation.html#syslog5424sd","text":"Pattern : \\[%{DATA}\\]+","title":"SYSLOG5424SD"},{"location":"references/patterns-documentation.html#iso8601_second","text":"Pattern : %{SECOND}|60","title":"ISO8601_SECOND"},{"location":"references/patterns-documentation.html#nguser","text":"Pattern : %{NGUSERNAME}","title":"NGUSER"},{"location":"references/patterns-documentation.html#monthnum2","text":"Pattern : 0[1-9]|1[0-2]","title":"MONTHNUM2"},{"location":"references/patterns-documentation.html#bacula_host","text":"Pattern : [a-zA-Z0-9-]+","title":"BACULA_HOST"},{"location":"references/patterns-documentation.html#exim_pid","text":"Pattern : \\[%{POSINT}\\]","title":"EXIM_PID"},{"location":"references/patterns-documentation.html#nagios_type_service_alert","text":"Pattern : SERVICE ALERT","title":"NAGIOS_TYPE_SERVICE_ALERT"},{"location":"references/patterns-documentation.html#year","text":"Pattern : (?:\\d\\d){1,2}","title":"YEAR"},{"location":"references/patterns-documentation.html#monthnum","text":"Pattern : 0?[1-9]|1[0-2]","title":"MONTHNUM"},{"location":"references/patterns-documentation.html#cisco_xlate_type","text":"Pattern : static|dynamic","title":"CISCO_XLATE_TYPE"},{"location":"references/patterns-documentation.html#rails_context","text":"Pattern : (?:%{DATA}\\n)*","title":"RAILS_CONTEXT"},{"location":"references/patterns-documentation.html#bacula_log_endprune","text":"Pattern : End auto prune.","title":"BACULA_LOG_ENDPRUNE"},{"location":"references/patterns-documentation.html#posint","text":"Pattern : \\b[1-9][0-9]*\\b","title":"POSINT"},{"location":"references/patterns-documentation.html#int","text":"Pattern : [+-]?(?:[0-9]+)","title":"INT"},{"location":"references/patterns-documentation.html#username","text":"Pattern : [a-zA-Z0-9._-]+","title":"USERNAME"},{"location":"references/patterns-documentation.html#ip","text":"Pattern : %{IPV6}|%{IPV4}","title":"IP"},{"location":"references/patterns-documentation.html#qs","text":"Pattern : %{QUOTEDSTRING}","title":"QS"},{"location":"references/patterns-documentation.html#modsecrulevers","text":"Pattern : \\[ver \"[^\"]+\"\\]","title":"MODSECRULEVERS"},{"location":"references/patterns-documentation.html#nagios_type_external_command","text":"Pattern : EXTERNAL COMMAND","title":"NAGIOS_TYPE_EXTERNAL_COMMAND"},{"location":"references/patterns-documentation.html#nagios_ec_enable_svc_check","text":"Pattern : ENABLE_SVC_CHECK","title":"NAGIOS_EC_ENABLE_SVC_CHECK"},{"location":"references/patterns-documentation.html#iporhost","text":"Pattern : %{IP}|%{HOSTNAME}","title":"IPORHOST"},{"location":"references/patterns-documentation.html#nagios_ec_enable_host_check","text":"Pattern : ENABLE_HOST_CHECK","title":"NAGIOS_EC_ENABLE_HOST_CHECK"},{"location":"references/patterns-documentation.html#nagios_type_host_notification","text":"Pattern : HOST NOTIFICATION","title":"NAGIOS_TYPE_HOST_NOTIFICATION"},{"location":"references/patterns-documentation.html#nagios_ec_disable_svc_check","text":"Pattern : DISABLE_SVC_CHECK","title":"NAGIOS_EC_DISABLE_SVC_CHECK"},{"location":"references/patterns-documentation.html#nagios_type_passive_host_check","text":"Pattern : PASSIVE HOST CHECK","title":"NAGIOS_TYPE_PASSIVE_HOST_CHECK"},{"location":"references/patterns-documentation.html#nagios_type_host_event_handler","text":"Pattern : HOST EVENT HANDLER","title":"NAGIOS_TYPE_HOST_EVENT_HANDLER"},{"location":"references/patterns-documentation.html#hour","text":"Pattern : 2[0123]|[01]?[0-9]","title":"HOUR"},{"location":"references/patterns-documentation.html#datestamp","text":"Pattern : %{DATE}[- ]%{TIME}","title":"DATESTAMP"},{"location":"references/patterns-documentation.html#nagios_type_current_host_state","text":"Pattern : CURRENT HOST STATE","title":"NAGIOS_TYPE_CURRENT_HOST_STATE"},{"location":"references/patterns-documentation.html#nagios_ec_disable_host_check","text":"Pattern : DISABLE_HOST_CHECK","title":"NAGIOS_EC_DISABLE_HOST_CHECK"},{"location":"references/patterns-documentation.html#ngusername","text":"Pattern : [a-zA-Z\\.\\@\\-\\+_%]+","title":"NGUSERNAME"},{"location":"references/patterns-documentation.html#nagios_type_host_flapping_alert","text":"Pattern : HOST FLAPPING ALERT","title":"NAGIOS_TYPE_HOST_FLAPPING_ALERT"},{"location":"references/patterns-documentation.html#nagios_type_host_downtime_alert","text":"Pattern : HOST DOWNTIME ALERT","title":"NAGIOS_TYPE_HOST_DOWNTIME_ALERT"},{"location":"references/patterns-documentation.html#javafile","text":"Pattern : (?:[A-Za-z0-9_. -]+)","title":"JAVAFILE"},{"location":"references/patterns-documentation.html#nagios_type_service_notification","text":"Pattern : SERVICE NOTIFICATION","title":"NAGIOS_TYPE_SERVICE_NOTIFICATION"},{"location":"references/patterns-documentation.html#bacula_log_begin_prune_files","text":"Pattern : Begin pruning Files.","title":"BACULA_LOG_BEGIN_PRUNE_FILES"},{"location":"references/patterns-documentation.html#nagios_type_current_service_state","text":"Pattern : CURRENT SERVICE STATE","title":"NAGIOS_TYPE_CURRENT_SERVICE_STATE"},{"location":"references/patterns-documentation.html#nagios_type_passive_service_check","text":"Pattern : PASSIVE SERVICE CHECK","title":"NAGIOS_TYPE_PASSIVE_SERVICE_CHECK"},{"location":"references/patterns-documentation.html#nagios_type_timeperiod_transition","text":"Pattern : TIMEPERIOD TRANSITION","title":"NAGIOS_TYPE_TIMEPERIOD_TRANSITION"},{"location":"references/patterns-documentation.html#hostport","text":"Pattern : %{IPORHOST}:%{POSINT}","title":"HOSTPORT"},{"location":"references/patterns-documentation.html#nagios_type_service_event_handler","text":"Pattern : SERVICE EVENT HANDLER","title":"NAGIOS_TYPE_SERVICE_EVENT_HANDLER"},{"location":"references/patterns-documentation.html#nagios_ec_schedule_host_downtime","text":"Pattern : SCHEDULE_HOST_DOWNTIME","title":"NAGIOS_EC_SCHEDULE_HOST_DOWNTIME"},{"location":"references/patterns-documentation.html#exim_flags","text":"Pattern : (<=|[-=>*]>|[*]{2}|==)","title":"EXIM_FLAGS"},{"location":"references/patterns-documentation.html#nagios_type_service_downtime_alert","text":"Pattern : SERVICE DOWNTIME ALERT","title":"NAGIOS_TYPE_SERVICE_DOWNTIME_ALERT"},{"location":"references/patterns-documentation.html#exim_subject","text":"Pattern : (T=%{QS:exim_subject})","title":"EXIM_SUBJECT"},{"location":"references/patterns-documentation.html#path","text":"Pattern : %{UNIXPATH}|%{WINPATH}","title":"PATH"},{"location":"references/patterns-documentation.html#nagios_type_service_flapping_alert","text":"Pattern : SERVICE FLAPPING ALERT","title":"NAGIOS_TYPE_SERVICE_FLAPPING_ALERT"},{"location":"references/patterns-documentation.html#sshd_corrupt_mac","text":"Pattern : Corrupted MAC on input","title":"SSHD_CORRUPT_MAC"},{"location":"references/patterns-documentation.html#bacula_log_noprune_jobs","text":"Pattern : No Jobs found to prune.","title":"BACULA_LOG_NOPRUNE_JOBS"},{"location":"references/patterns-documentation.html#httpduser","text":"Pattern : %{EMAILADDRESS}|%{USER}","title":"HTTPDUSER"},{"location":"references/patterns-documentation.html#bacula_log_noprune_files","text":"Pattern : No Files found to prune.","title":"BACULA_LOG_NOPRUNE_FILES"},{"location":"references/patterns-documentation.html#nagios_ec_enable_svc_notifications","text":"Pattern : ENABLE_SVC_NOTIFICATIONS","title":"NAGIOS_EC_ENABLE_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#bacula_capacity","text":"Pattern : %{INT}{1,3}(,%{INT}{3})*","title":"BACULA_CAPACITY"},{"location":"references/patterns-documentation.html#exim_protocol","text":"Pattern : (P=%{NOTSPACE:protocol})","title":"EXIM_PROTOCOL"},{"location":"references/patterns-documentation.html#uriproto","text":"Pattern : [A-Za-z]+(\\+[A-Za-z+]+)?","title":"URIPROTO"},{"location":"references/patterns-documentation.html#prog","text":"Pattern : [\\x21-\\x5a\\x5c\\x5e-\\x7e]+","title":"PROG"},{"location":"references/patterns-documentation.html#nagios_ec_enable_host_notifications","text":"Pattern : ENABLE_HOST_NOTIFICATIONS","title":"NAGIOS_EC_ENABLE_HOST_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#nagios_ec_process_host_check_result","text":"Pattern : PROCESS_HOST_CHECK_RESULT","title":"NAGIOS_EC_PROCESS_HOST_CHECK_RESULT"},{"location":"references/patterns-documentation.html#bacula_log_vss","text":"Pattern : (Generate )?VSS (Writer)?","title":"BACULA_LOG_VSS"},{"location":"references/patterns-documentation.html#nagios_ec_disable_svc_notifications","text":"Pattern : DISABLE_SVC_NOTIFICATIONS","title":"NAGIOS_EC_DISABLE_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#nagios_ec_schedule_service_downtime","text":"Pattern : SCHEDULE_SERVICE_DOWNTIME","title":"NAGIOS_EC_SCHEDULE_SERVICE_DOWNTIME"},{"location":"references/patterns-documentation.html#mongo_query","text":"Pattern : \\{ \\{ .* \\} ntoreturn: \\}","title":"MONGO_QUERY"},{"location":"references/patterns-documentation.html#uripathparam","text":"Pattern : %{URIPATH}(?:%{URIPARAM})?","title":"URIPATHPARAM"},{"location":"references/patterns-documentation.html#nagios_ec_disable_host_notifications","text":"Pattern : DISABLE_HOST_NOTIFICATIONS","title":"NAGIOS_EC_DISABLE_HOST_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#unixpath","text":"Pattern : (/([\\w_%!$@:.,~-]+|\\\\.)*)+","title":"UNIXPATH"},{"location":"references/patterns-documentation.html#kitchen","text":"Pattern : \\d{1,2}:\\d{2}(AM|PM|am|pm)","title":"KITCHEN"},{"location":"references/patterns-documentation.html#nagiostime","text":"Pattern : \\[%{NUMBER:nagios_epoch}\\]","title":"NAGIOSTIME"},{"location":"references/patterns-documentation.html#emaillocalpart","text":"Pattern : [a-zA-Z][a-zA-Z0-9_.+-=:]+","title":"EMAILLOCALPART"},{"location":"references/patterns-documentation.html#javathread","text":"Pattern : (?:[A-Z]{2}-Processor[\\d]+)","title":"JAVATHREAD"},{"location":"references/patterns-documentation.html#time","text":"Pattern : %{HOUR}:%{MINUTE}:%{SECOND}","title":"TIME"},{"location":"references/patterns-documentation.html#exim_msg_size","text":"Pattern : (S=%{NUMBER:exim_msg_size})","title":"EXIM_MSG_SIZE"},{"location":"references/patterns-documentation.html#ruby_loglevel","text":"Pattern : DEBUG|FATAL|ERROR|WARN|INFO","title":"RUBY_LOGLEVEL"},{"location":"references/patterns-documentation.html#base16num","text":"Pattern : [+-]?(?:0x)?(?:[0-9A-Fa-f]+)","title":"BASE16NUM"},{"location":"references/patterns-documentation.html#iso8601_timezone","text":"Pattern : Z|[+-]%{HOUR}(?::?%{MINUTE})","title":"ISO8601_TIMEZONE"},{"location":"references/patterns-documentation.html#redistimestamp","text":"Pattern : %{MONTHDAY} %{MONTH} %{TIME}","title":"REDISTIMESTAMP"},{"location":"references/patterns-documentation.html#nagios_ec_process_service_check_result","text":"Pattern : PROCESS_SERVICE_CHECK_RESULT","title":"NAGIOS_EC_PROCESS_SERVICE_CHECK_RESULT"},{"location":"references/patterns-documentation.html#sshd_packet_corrupt","text":"Pattern : Disconnecting: Packet corrupt","title":"SSHD_PACKET_CORRUPT"},{"location":"references/patterns-documentation.html#syslog5424pri","text":"Pattern : <%{NONNEGINT:syslog5424_pri}>","title":"SYSLOG5424PRI"},{"location":"references/patterns-documentation.html#emailaddress","text":"Pattern : %{EMAILLOCALPART}@%{HOSTNAME}","title":"EMAILADDRESS"},{"location":"references/patterns-documentation.html#modsecruleid","text":"Pattern : \\[id %{QUOTEDSTRING:ruleid}\\]","title":"MODSECRULEID"},{"location":"references/patterns-documentation.html#syslogtimestamp","text":"Pattern : %{MONTH} +%{MONTHDAY} %{TIME}","title":"SYSLOGTIMESTAMP"},{"location":"references/patterns-documentation.html#nagios_ec_enable_host_svc_notifications","text":"Pattern : ENABLE_HOST_SVC_NOTIFICATIONS","title":"NAGIOS_EC_ENABLE_HOST_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#nagios_ec_disable_host_svc_notifications","text":"Pattern : DISABLE_HOST_SVC_NOTIFICATIONS","title":"NAGIOS_EC_DISABLE_HOST_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#exim_header_id","text":"Pattern : (id=%{NOTSPACE:exim_header_id})","title":"EXIM_HEADER_ID"},{"location":"references/patterns-documentation.html#urihost","text":"Pattern : %{IPORHOST}(?::%{POSINT:port})?","title":"URIHOST"},{"location":"references/patterns-documentation.html#date","text":"Pattern : %{DATE_US}|%{DATE_EU}|%{DATE_X}","title":"DATE"},{"location":"references/patterns-documentation.html#sshd_tunn_timeout","text":"Pattern : Timeout, client not responding.","title":"SSHD_TUNN_TIMEOUT"},{"location":"references/patterns-documentation.html#mcollectiveaudit","text":"Pattern : %{TIMESTAMP_ISO8601:timestamp}:","title":"MCOLLECTIVEAUDIT"},{"location":"references/patterns-documentation.html#ciscotag","text":"Pattern : [A-Z0-9]+-%{INT}-(?:[A-Z0-9_]+)","title":"CISCOTAG"},{"location":"references/patterns-documentation.html#modsecrulerev","text":"Pattern : \\[rev %{QUOTEDSTRING:rulerev}\\]","title":"MODSECRULEREV"},{"location":"references/patterns-documentation.html#haproxycapturedrequestheaders","text":"Pattern : %{DATA:captured_request_headers}","title":"HAPROXYCAPTUREDREQUESTHEADERS"},{"location":"references/patterns-documentation.html#cisco_interval","text":"Pattern : first hit|%{INT}-second interval","title":"CISCO_INTERVAL"},{"location":"references/patterns-documentation.html#date_x","text":"Pattern : %{YEAR}/%{MONTHNUM2}/%{MONTHDAY}","title":"DATE_X"},{"location":"references/patterns-documentation.html#sshd_init","text":"Pattern : %{SSHD_LISTEN}|%{SSHD_TERMINATE}","title":"SSHD_INIT"},{"location":"references/patterns-documentation.html#winpath","text":"Pattern : (?:[A-Za-z]+:|\\\\)(?:\\\\[^\\\\?*]*)+","title":"WINPATH"},{"location":"references/patterns-documentation.html#haproxycapturedresponseheaders","text":"Pattern : %{DATA:captured_response_headers}","title":"HAPROXYCAPTUREDRESPONSEHEADERS"},{"location":"references/patterns-documentation.html#modsecuri","text":"Pattern : \\[uri [\"']%{DATA:targeturi}[\"']\\]","title":"MODSECURI"},{"location":"references/patterns-documentation.html#cisco_direction","text":"Pattern : Inbound|inbound|Outbound|outbound","title":"CISCO_DIRECTION"},{"location":"references/patterns-documentation.html#modsecruledata","text":"Pattern : \\[data %{QUOTEDSTRING:ruledata}\\]","title":"MODSECRULEDATA"},{"location":"references/patterns-documentation.html#modsecruleline","text":"Pattern : \\[line %{QUOTEDSTRING:ruleline}\\]","title":"MODSECRULELINE"},{"location":"references/patterns-documentation.html#modsecrulefile","text":"Pattern : \\[file %{QUOTEDSTRING:rulefile}\\]","title":"MODSECRULEFILE"},{"location":"references/patterns-documentation.html#second","text":"Pattern : (?:[0-5]?[0-9]|60)(?:[:.,][0-9]+)?","title":"SECOND"},{"location":"references/patterns-documentation.html#bacula_log_cancelling","text":"Pattern : Cancelling duplicate JobId=%{INT}.","title":"BACULA_LOG_CANCELLING"},{"location":"references/patterns-documentation.html#modsecrulemsg","text":"Pattern : \\[msg %{QUOTEDSTRING:rulemessage}\\]","title":"MODSECRULEMSG"},{"location":"references/patterns-documentation.html#sshd_tunn_err3","text":"Pattern : error: bind: Address already in use","title":"SSHD_TUNN_ERR3"},{"location":"references/patterns-documentation.html#bacula_log_startrestore","text":"Pattern : Start Restore Job %{BACULA_JOB:job}","title":"BACULA_LOG_STARTRESTORE"},{"location":"references/patterns-documentation.html#syslogline","text":"Pattern : %{SYSLOGBASE2} %{GREEDYDATA:message}","title":"SYSLOGLINE"},{"location":"references/patterns-documentation.html#commonmac","text":"Pattern : (?:[A-Fa-f0-9]{2}:){5}[A-Fa-f0-9]{2}","title":"COMMONMAC"},{"location":"references/patterns-documentation.html#windowsmac","text":"Pattern : (?:[A-Fa-f0-9]{2}-){5}[A-Fa-f0-9]{2}","title":"WINDOWSMAC"},{"location":"references/patterns-documentation.html#syslogprog","text":"Pattern : %{PROG:program}(?:\\[%{POSINT:pid}\\])?","title":"SYSLOGPROG"},{"location":"references/patterns-documentation.html#javamethod","text":"Pattern : (?:(<init>)|[a-zA-Z$_][a-zA-Z$_0-9]*)","title":"JAVAMETHOD"},{"location":"references/patterns-documentation.html#date_us","text":"Pattern : %{MONTHNUM}[/-]%{MONTHDAY}[/-]%{YEAR}","title":"DATE_US"},{"location":"references/patterns-documentation.html#ciscomac","text":"Pattern : (?:[A-Fa-f0-9]{4}\\.){2}[A-Fa-f0-9]{4}","title":"CISCOMAC"},{"location":"references/patterns-documentation.html#modsecuid","text":"Pattern : \\[unique_id %{QUOTEDSTRING:uniqueid}\\]","title":"MODSECUID"},{"location":"references/patterns-documentation.html#mac","text":"Pattern : %{CISCOMAC}|%{WINDOWSMAC}|%{COMMONMAC}","title":"MAC"},{"location":"references/patterns-documentation.html#elb_uripathparam","text":"Pattern : %{URIPATH:path}(?:%{URIPARAM:params})?","title":"ELB_URIPATHPARAM"},{"location":"references/patterns-documentation.html#bacula_log_noprior","text":"Pattern : No prior Full backup Job record found.","title":"BACULA_LOG_NOPRIOR"},{"location":"references/patterns-documentation.html#modsecmatchoffset","text":"Pattern : \\[offset %{QUOTEDSTRING:matchoffset}\\]","title":"MODSECMATCHOFFSET"},{"location":"references/patterns-documentation.html#bacula_timestamp","text":"Pattern : %{MONTHDAY}-%{MONTH} %{HOUR}:%{MINUTE}","title":"BACULA_TIMESTAMP"},{"location":"references/patterns-documentation.html#modsechostname","text":"Pattern : \\[hostname ['\"]%{DATA:targethost}[\"']\\]","title":"MODSECHOSTNAME"},{"location":"references/patterns-documentation.html#tty","text":"Pattern : /dev/(pts|tty([pq])?)(\\w+)?/?(?:[0-9]+)","title":"TTY"},{"location":"references/patterns-documentation.html#date_eu","text":"Pattern : %{MONTHDAY}[./-]%{MONTHNUM}[./-]%{YEAR}","title":"DATE_EU"},{"location":"references/patterns-documentation.html#uripath","text":"Pattern : (?:/[A-Za-z0-9$.+!*'(){},~:;=@#%_\\-]*)+","title":"URIPATH"},{"location":"references/patterns-documentation.html#httpd_errorlog","text":"Pattern : %{HTTPD20_ERRORLOG}|%{HTTPD24_ERRORLOG}","title":"HTTPD_ERRORLOG"},{"location":"references/patterns-documentation.html#monthday","text":"Pattern : (?:0[1-9])|(?:[12][0-9])|(?:3[01])|[1-9]","title":"MONTHDAY"},{"location":"references/patterns-documentation.html#bacula_log_usedevice","text":"Pattern : Using Device \\\"%{BACULA_DEVICE:device}\\\"","title":"BACULA_LOG_USEDEVICE"},{"location":"references/patterns-documentation.html#rfc822z","text":"Pattern : [0-3]\\d %{MONTH} %{YEAR} %{TIME} %{NUMTZ}","title":"RFC822Z"},{"location":"references/patterns-documentation.html#modsecruleseverity","text":"Pattern : \\[severity [\"']%{WORD:ruleseverity}[\"']\\]","title":"MODSECRULESEVERITY"},{"location":"references/patterns-documentation.html#ansic","text":"Pattern : %{DAY} %{MONTH} [_123]\\d %{TIME} %{YEAR}\"","title":"ANSIC"},{"location":"references/patterns-documentation.html#genericapacheerror","text":"Pattern : %{APACHEERRORPREFIX} %{GREEDYDATA:message}","title":"GENERICAPACHEERROR"},{"location":"references/patterns-documentation.html#sshd_conn_close","text":"Pattern : Connection closed by %{IP:sshd_client_ip}$","title":"SSHD_CONN_CLOSE"},{"location":"references/patterns-documentation.html#ciscotimestamp","text":"Pattern : %{MONTH} +%{MONTHDAY}(?: %{YEAR})? %{TIME}","title":"CISCOTIMESTAMP"},{"location":"references/patterns-documentation.html#apacheerrortime","text":"Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}","title":"APACHEERRORTIME"},{"location":"references/patterns-documentation.html#ciscofw104004","text":"Pattern : \\((?:Primary|Secondary)\\) Switching to OK\\.","title":"CISCOFW104004"},{"location":"references/patterns-documentation.html#httpdate","text":"Pattern : %{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{INT}","title":"HTTPDATE"},{"location":"references/patterns-documentation.html#httpderror_date","text":"Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}","title":"HTTPDERROR_DATE"},{"location":"references/patterns-documentation.html#exim_qt","text":"Pattern : ((\\d+y)?(\\d+w)?(\\d+d)?(\\d+h)?(\\d+m)?(\\d+s)?)","title":"EXIM_QT"},{"location":"references/patterns-documentation.html#bacula_log_nojobstat","text":"Pattern : Fatal error: No Job status returned from FD.","title":"BACULA_LOG_NOJOBSTAT"},{"location":"references/patterns-documentation.html#nagios_warning","text":"Pattern : Warning:%{SPACE}%{GREEDYDATA:nagios_message}","title":"NAGIOS_WARNING"},{"location":"references/patterns-documentation.html#exim_msgid","text":"Pattern : [0-9A-Za-z]{6}-[0-9A-Za-z]{6}-[0-9A-Za-z]{2}","title":"EXIM_MSGID"},{"location":"references/patterns-documentation.html#base10num","text":"Pattern : [+-]?(?:(?:[0-9]+(?:\\.[0-9]+)?)|(?:\\.[0-9]+))","title":"BASE10NUM"},{"location":"references/patterns-documentation.html#redislog","text":"Pattern : \\[%{POSINT:pid}\\] %{REDISTIMESTAMP:time} \\*\\s","title":"REDISLOG"},{"location":"references/patterns-documentation.html#uriparam","text":"Pattern : \\?[A-Za-z0-9$.+!*'|(){},~@#%&/=:;_?\\-\\[\\]<>]*","title":"URIPARAM"},{"location":"references/patterns-documentation.html#combinedapachelog","text":"Pattern : %{COMMONAPACHELOG} %{QS:referrer} %{QS:agent}","title":"COMBINEDAPACHELOG"},{"location":"references/patterns-documentation.html#syslogfacility","text":"Pattern : <%{NONNEGINT:facility}.%{NONNEGINT:priority}>","title":"SYSLOGFACILITY"},{"location":"references/patterns-documentation.html#rfc1123","text":"Pattern : %{DAY}, [0-3]\\d %{MONTH} %{YEAR} %{TIME} %{TZ}","title":"RFC1123"},{"location":"references/patterns-documentation.html#unixdate","text":"Pattern : %{DAY} %{MONTH} [_123]\\d %{TIME} %{TZ} %{YEAR}","title":"UNIXDATE"},{"location":"references/patterns-documentation.html#rfc850","text":"Pattern : %{DAY}, [0-3]\\d-%{MONTH}-%{YEAR} %{TIME} %{TZ}","title":"RFC850"},{"location":"references/patterns-documentation.html#syslog5424line","text":"Pattern : %{SYSLOG5424BASE} +%{GREEDYDATA:syslog5424_msg}","title":"SYSLOG5424LINE"},{"location":"references/patterns-documentation.html#ciscofw104003","text":"Pattern : \\((?:Primary|Secondary)\\) Switching to FAILED\\.","title":"CISCOFW104003"},{"location":"references/patterns-documentation.html#rubydate","text":"Pattern : %{DAY} %{MONTH} [0-3]\\d %{TIME} %{NUMTZ} %{YEAR}","title":"RUBYDATE"},{"location":"references/patterns-documentation.html#bacula_log_noopen","text":"Pattern : \\s+Cannot open %{DATA}: ERR=%{GREEDYDATA:berror}","title":"BACULA_LOG_NOOPEN"},{"location":"references/patterns-documentation.html#bacula_log_startjob","text":"Pattern : Start Backup JobId %{INT}, Job=%{BACULA_JOB:job}","title":"BACULA_LOG_STARTJOB"},{"location":"references/patterns-documentation.html#datestamp_rfc822","text":"Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{YEAR} %{TIME} %{TZ}","title":"DATESTAMP_RFC822"},{"location":"references/patterns-documentation.html#datestamp_other","text":"Pattern : %{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{TZ} %{YEAR}","title":"DATESTAMP_OTHER"},{"location":"references/patterns-documentation.html#rfc3339","text":"Pattern : %{YEAR}-[01]\\d-[0-3]\\dT%{TIME}%{ISO8601_TIMEZONE}","title":"RFC3339"},{"location":"references/patterns-documentation.html#rfc1123z","text":"Pattern : %{DAY}, [0-3]\\d %{MONTH} %{YEAR} %{TIME} %{NUMTZ}","title":"RFC1123Z"},{"location":"references/patterns-documentation.html#bacula_log_nostat","text":"Pattern : \\s+Could not stat %{DATA}: ERR=%{GREEDYDATA:berror}","title":"BACULA_LOG_NOSTAT"},{"location":"references/patterns-documentation.html#sshd_terminate","text":"Pattern : Received signal %{NUMBER:sshd_signal}; terminating.","title":"SSHD_TERMINATE"},{"location":"references/patterns-documentation.html#uuid","text":"Pattern : [A-Fa-f0-9]{8}-(?:[A-Fa-f0-9]{4}-){3}[A-Fa-f0-9]{12}","title":"UUID"},{"location":"references/patterns-documentation.html#sshd_logout_err","text":"Pattern : syslogin_perform_logout: logout\\(\\) returned an error","title":"SSHD_LOGOUT_ERR"},{"location":"references/patterns-documentation.html#rcontroller","text":"Pattern : %{RAILS_CONSTROLLER:controller}#%{RAIL_ACTION:action}","title":"RCONTROLLER"},{"location":"references/patterns-documentation.html#javaclass","text":"Pattern : (?:[a-zA-Z$_][a-zA-Z$_0-9]*\\.)*[a-zA-Z$_][a-zA-Z$_0-9]*","title":"JAVACLASS"},{"location":"references/patterns-documentation.html#datestamp_eventlog","text":"Pattern : %{YEAR}%{MONTHNUM2}%{MONTHDAY}%{HOUR}%{MINUTE}%{SECOND}","title":"DATESTAMP_EVENTLOG"},{"location":"references/patterns-documentation.html#nginxerrtime","text":"Pattern : %{YEAR}/%{MONTHNUM2}/%{DAY2} %{HOUR}:%{MINUTE}:%{SECOND}","title":"NGINXERRTIME"},{"location":"references/patterns-documentation.html#bacula_log_begin_prune_jobs","text":"Pattern : Begin pruning Jobs older than %{INT} month %{INT} days .","title":"BACULA_LOG_BEGIN_PRUNE_JOBS"},{"location":"references/patterns-documentation.html#rfc3339nano","text":"Pattern : %{YEAR}-[01]\\d-[0-3]\\dT%{TIME}\\.\\d{9}%{ISO8601_TIMEZONE}","title":"RFC3339NANO"},{"location":"references/patterns-documentation.html#bacula_log_markcancel","text":"Pattern : JobId %{INT}, Job %{BACULA_JOB:job} marked to be canceled.","title":"BACULA_LOG_MARKCANCEL"},{"location":"references/patterns-documentation.html#bacula_log_new_volume","text":"Pattern : Created new Volume \\\"%{BACULA_VOLUME:volume}\\\" in catalog.","title":"BACULA_LOG_NEW_VOLUME"},{"location":"references/patterns-documentation.html#sshd_tcpwrap_fail5","text":"Pattern : warning: can't get client address: Connection reset by peer","title":"SSHD_TCPWRAP_FAIL5"},{"location":"references/patterns-documentation.html#exim_interface","text":"Pattern : (I=\\[%{IP:exim_interface}\\](:%{NUMBER:exim_interface_port}))","title":"EXIM_INTERFACE"},{"location":"references/patterns-documentation.html#bacula_log_noopendir","text":"Pattern : \\s+Could not open directory %{DATA}: ERR=%{GREEDYDATA:berror}","title":"BACULA_LOG_NOOPENDIR"},{"location":"references/patterns-documentation.html#bacula_log_client_rbj","text":"Pattern : shell command: run ClientRunBeforeJob \\\"%{GREEDYDATA:runjob}\\\"","title":"BACULA_LOG_CLIENT_RBJ"},{"location":"references/patterns-documentation.html#sshd_ident_fail","text":"Pattern : Did not receive identification string from %{IP:sshd_client_ip}","title":"SSHD_IDENT_FAIL"},{"location":"references/patterns-documentation.html#datestamp_rfc2822","text":"Pattern : %{DAY}, %{MONTHDAY} %{MONTH} %{YEAR} %{TIME} %{ISO8601_TIMEZONE}","title":"DATESTAMP_RFC2822"},{"location":"references/patterns-documentation.html#bacula_log_maxstart","text":"Pattern : Fatal error: Job canceled because max start delay time exceeded.","title":"BACULA_LOG_MAXSTART"},{"location":"references/patterns-documentation.html#quotedstring","text":"Pattern : (\"(\\\\.|[^\\\\\"]+)+\")|\"\"|('(\\\\.|[^\\\\']+)+')|''|(`(\\\\.|[^\\\\`]+)+`)|``","title":"QUOTEDSTRING"},{"location":"references/patterns-documentation.html#redislog2","text":"Pattern : %{POSINT:pid}:M %{REDISTIMESTAMP:time} [*#] %{GREEDYDATA:message}","title":"REDISLOG2"},{"location":"references/patterns-documentation.html#bacula_log_pruned_jobs","text":"Pattern : Pruned %{INT} Jobs* for client %{BACULA_HOST:client} from catalog.","title":"BACULA_LOG_PRUNED_JOBS"},{"location":"references/patterns-documentation.html#rt_flow_event","text":"Pattern : (RT_FLOW_SESSION_CREATE|RT_FLOW_SESSION_CLOSE|RT_FLOW_SESSION_DENY)","title":"RT_FLOW_EVENT"},{"location":"references/patterns-documentation.html#bacula_log_nosuit","text":"Pattern : No prior or suitable Full backup found in catalog. Doing FULL backup.","title":"BACULA_LOG_NOSUIT"},{"location":"references/patterns-documentation.html#ciscofw302010","text":"Pattern : %{INT:connection_count} in use, %{INT:connection_count_max} most used","title":"CISCOFW302010"},{"location":"references/patterns-documentation.html#sshd_inval_user","text":"Pattern : Invalid user\\s*%{USERNAME:sshd_invalid_user}? from %{IP:sshd_client_ip}","title":"SSHD_INVAL_USER"},{"location":"references/patterns-documentation.html#sshd_session_close","text":"Pattern : pam_unix\\(sshd:session\\): session closed for user %{USERNAME:sshd_user}","title":"SSHD_SESSION_CLOSE"},{"location":"references/patterns-documentation.html#mongo_log","text":"Pattern : %{SYSLOGTIMESTAMP:timestamp} \\[%{WORD:component}\\] %{GREEDYDATA:message}","title":"MONGO_LOG"},{"location":"references/patterns-documentation.html#bacula_log_readyappend","text":"Pattern : Ready to append to end of Volume \\\"%{BACULA_VOLUME:volume}\\\" size=%{INT}","title":"BACULA_LOG_READYAPPEND"},{"location":"references/patterns-documentation.html#cronlog","text":"Pattern : %{SYSLOGBASE} \\(%{USER:user}\\) %{CRON_ACTION:action} \\(%{DATA:message}\\)","title":"CRONLOG"},{"location":"references/patterns-documentation.html#bacula_log_job","text":"Pattern : (Error: )?Bacula %{BACULA_HOST} %{BACULA_VERSION} \\(%{BACULA_VERSION}\\):","title":"BACULA_LOG_JOB"},{"location":"references/patterns-documentation.html#sshd_listen","text":"Pattern : Server listening on %{IP:sshd_listen_ip} port %{NUMBER:sshd_listen_port}.","title":"SSHD_LISTEN"},{"location":"references/patterns-documentation.html#uri","text":"Pattern : %{URIPROTO}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST})?(?:%{URIPATHPARAM})?","title":"URI"},{"location":"references/patterns-documentation.html#rails3","text":"Pattern : %{RAILS3HEAD}(?:%{RPROCESSING})?%{RAILS_CONTEXT:context}(?:%{RAILS3FOOT})?","title":"RAILS3"},{"location":"references/patterns-documentation.html#base16float","text":"Pattern : \\b[+-]?(?:0x)?(?:(?:[0-9A-Fa-f]+(?:\\.[0-9A-Fa-f]*)?)|(?:\\.[0-9A-Fa-f]+))\\b","title":"BASE16FLOAT"},{"location":"references/patterns-documentation.html#haproxytime","text":"Pattern : %{HOUR:haproxy_hour}:%{MINUTE:haproxy_minute}(?::%{SECOND:haproxy_second})","title":"HAPROXYTIME"},{"location":"references/patterns-documentation.html#ciscofw104001","text":"Pattern : \\((?:Primary|Secondary)\\) Switching to ACTIVE - %{GREEDYDATA:switch_reason}","title":"CISCOFW104001"},{"location":"references/patterns-documentation.html#catalina_datestamp","text":"Pattern : %{MONTH} %{MONTHDAY}, 20%{YEAR} %{HOUR}:?%{MINUTE}(?::?%{SECOND}) (?:AM|PM)","title":"CATALINA_DATESTAMP"},{"location":"references/patterns-documentation.html#ciscofw105008","text":"Pattern : \\((?:Primary|Secondary)\\) Testing [Ii]nterface %{GREEDYDATA:interface_name}","title":"CISCOFW105008"},{"location":"references/patterns-documentation.html#hostname","text":"Pattern : \\b[0-9A-Za-z][0-9A-Za-z-]{0,62}(?:\\.[0-9A-Za-z][0-9A-Za-z-]{0,62})*(\\.?|\\b)","title":"HOSTNAME"},{"location":"references/patterns-documentation.html#ciscofw104002","text":"Pattern : \\((?:Primary|Secondary)\\) Switching to STANDBY - %{GREEDYDATA:switch_reason}","title":"CISCOFW104002"},{"location":"references/patterns-documentation.html#bacula_log_volume_prevwritten","text":"Pattern : Volume \\\"%{BACULA_VOLUME:volume}\\\" previously written, moving to end of data.","title":"BACULA_LOG_VOLUME_PREVWRITTEN"},{"location":"references/patterns-documentation.html#sshd_bad_version","text":"Pattern : Bad protocol version identification '%{GREEDYDATA}' from %{IP:sshd_client_ip}","title":"SSHD_BAD_VERSION"},{"location":"references/patterns-documentation.html#bacula_log_pruned_files","text":"Pattern : Pruned Files from %{INT} Jobs* for client %{BACULA_HOST:client} from catalog.","title":"BACULA_LOG_PRUNED_FILES"},{"location":"references/patterns-documentation.html#sshd_badl_preauth","text":"Pattern : Bad packet length %{NUMBER:sshd_packet_length}. \\[%{GREEDYDATA:sshd_privsep}\\]","title":"SSHD_BADL_PREAUTH"},{"location":"references/patterns-documentation.html#catalinalog","text":"Pattern : %{CATALINA_DATESTAMP:timestamp} %{JAVACLASS:class} %{JAVALOGMESSAGE:logmessage}","title":"CATALINALOG"},{"location":"references/patterns-documentation.html#rails_timestamp","text":"Pattern : %{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:%{MINUTE}:%{SECOND} %{ISO8601_TIMEZONE}","title":"RAILS_TIMESTAMP"},{"location":"references/patterns-documentation.html#sshd_tunn_err1","text":"Pattern : error: connect_to %{IP:sshd_listen_ip} port %{NUMBER:sshd_listen_port}: failed.","title":"SSHD_TUNN_ERR1"},{"location":"references/patterns-documentation.html#exim_date","text":"Pattern : %{YEAR:exim_year}-%{MONTHNUM:exim_month}-%{MONTHDAY:exim_day} %{TIME:exim_time}","title":"EXIM_DATE"},{"location":"references/patterns-documentation.html#bacula_log_duplicate","text":"Pattern : Fatal error: JobId %{INT:duplicate} already running. Duplicate job not allowed.","title":"BACULA_LOG_DUPLICATE"},{"location":"references/patterns-documentation.html#sshd_refuse_conn","text":"Pattern : refused connect from %{DATA:sshd_client_hostname} \\(%{IPORHOST:sshd_client_ip}\\)","title":"SSHD_REFUSE_CONN"},{"location":"references/patterns-documentation.html#sshd_toomany_auth","text":"Pattern : Disconnecting: Too many authentication failures for %{USERNAME:sshd_invalid_user}","title":"SSHD_TOOMANY_AUTH"},{"location":"references/patterns-documentation.html#bacula_log_all_records_pruned","text":"Pattern : All records pruned from Volume \\\"%{BACULA_VOLUME:volume}\\\"; marking it \\\"Purged\\\"","title":"BACULA_LOG_ALL_RECORDS_PRUNED"},{"location":"references/patterns-documentation.html#sshd_disr_preauth","text":"Pattern : Disconnecting: %{GREEDYDATA:sshd_disconnect_status} \\[%{GREEDYDATA:sshd_privsep}\\]","title":"SSHD_DISR_PREAUTH"},{"location":"references/patterns-documentation.html#mcollective","text":"Pattern : ., \\[%{TIMESTAMP_ISO8601:timestamp} #%{POSINT:pid}\\]%{SPACE}%{LOGLEVEL:event_level}","title":"MCOLLECTIVE"},{"location":"references/patterns-documentation.html#bacula_log_diff_fs","text":"Pattern : \\s+%{UNIXPATH} is a different filesystem. Will not descend from %{UNIXPATH} into it.","title":"BACULA_LOG_DIFF_FS"},{"location":"references/patterns-documentation.html#sshd_tunn_err2","text":"Pattern : error: channel_setup_fwd_listener: cannot listen to port: %{NUMBER:sshd_listen_port}","title":"SSHD_TUNN_ERR2"},{"location":"references/patterns-documentation.html#ciscofw321001","text":"Pattern : Resource '%{WORD:resource_name}' limit of %{POSINT:resource_limit} reached for system","title":"CISCOFW321001"},{"location":"references/patterns-documentation.html#bacula_log_no_auth","text":"Pattern : Fatal error: Unable to authenticate with File daemon at %{HOSTNAME}. Possible causes:","title":"BACULA_LOG_NO_AUTH"},{"location":"references/patterns-documentation.html#postgresql","text":"Pattern : %{DATESTAMP:timestamp} %{TZ} %{DATA:user_id} %{GREEDYDATA:connection_id} %{POSINT:pid}","title":"POSTGRESQL"},{"location":"references/patterns-documentation.html#elb_request_line","text":"Pattern : (?:%{WORD:verb} %{ELB_URI:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})","title":"ELB_REQUEST_LINE"},{"location":"references/patterns-documentation.html#sshd_session_open","text":"Pattern : pam_unix\\(sshd:session\\): session opened for user %{USERNAME:sshd_user} by \\(uid=\\d+\\)","title":"SSHD_SESSION_OPEN"},{"location":"references/patterns-documentation.html#tomcat_datestamp","text":"Pattern : 20%{YEAR}-%{MONTHNUM}-%{MONTHDAY} %{HOUR}:?%{MINUTE}(?::?%{SECOND}) %{ISO8601_TIMEZONE}","title":"TOMCAT_DATESTAMP"},{"location":"references/patterns-documentation.html#s3_request_line","text":"Pattern : (?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})","title":"S3_REQUEST_LINE"},{"location":"references/patterns-documentation.html#rails3foot","text":"Pattern : Completed %{NUMBER:response}%{DATA} in %{NUMBER:totalms}ms %{RAILS3PROFILE}%{GREEDYDATA}","title":"RAILS3FOOT"},{"location":"references/patterns-documentation.html#ciscofw105004","text":"Pattern : \\((?:Primary|Secondary)\\) Monitoring on [Ii]nterface %{GREEDYDATA:interface_name} normal","title":"CISCOFW105004"},{"location":"references/patterns-documentation.html#ciscofw105003","text":"Pattern : \\((?:Primary|Secondary)\\) Monitoring on [Ii]nterface %{GREEDYDATA:interface_name} waiting","title":"CISCOFW105003"},{"location":"references/patterns-documentation.html#bacula_log_jobend","text":"Pattern : Job write elapsed time = %{DATA:elapsed}, Transfer rate = %{NUMBER} (K|M|G)? Bytes/second","title":"BACULA_LOG_JOBEND"},{"location":"references/patterns-documentation.html#timestamp_iso8601","text":"Pattern : %{YEAR}-%{MONTHNUM}-%{MONTHDAY}[T ]%{HOUR}:?%{MINUTE}(?::?%{SECOND})?%{ISO8601_TIMEZONE}?","title":"TIMESTAMP_ISO8601"},{"location":"references/patterns-documentation.html#syslogbase","text":"Pattern : %{SYSLOGTIMESTAMP:timestamp} (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource} %{SYSLOGPROG}:","title":"SYSLOGBASE"},{"location":"references/patterns-documentation.html#sshd_tunn_err4","text":"Pattern : error: channel_setup_fwd_listener_tcpip: cannot listen to port: %{NUMBER:sshd_listen_port}","title":"SSHD_TUNN_ERR4"},{"location":"references/patterns-documentation.html#modsecprefix","text":"Pattern : %{APACHEERRORPREFIX} ModSecurity: %{NOTSPACE:modsecseverity}\\. %{GREEDYDATA:modsecmessage}","title":"MODSECPREFIX"},{"location":"references/patterns-documentation.html#javastacktracepart","text":"Pattern : %{SPACE}at %{JAVACLASS:class}\\.%{JAVAMETHOD:method}\\(%{JAVAFILE:file}(?::%{NUMBER:line})?\\)","title":"JAVASTACKTRACEPART"},{"location":"references/patterns-documentation.html#exim_remote_host","text":"Pattern : (H=(%{NOTSPACE:remote_hostname} )?(\\(%{NOTSPACE:remote_heloname}\\) )?\\[%{IP:remote_host}\\])","title":"EXIM_REMOTE_HOST"},{"location":"references/patterns-documentation.html#elb_uri","text":"Pattern : %{URIPROTO:proto}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST:urihost})?(?:%{ELB_URIPATHPARAM})?","title":"ELB_URI"},{"location":"references/patterns-documentation.html#day","text":"Pattern : Mon(?:day)?|Tue(?:sday)?|Wed(?:nesday)?|Thu(?:rsday)?|Fri(?:day)?|Sat(?:urday)?|Sun(?:day)?","title":"DAY"},{"location":"references/patterns-documentation.html#sshd_tunn","text":"Pattern : %{SSHD_TUNN_ERR1}|%{SSHD_TUNN_ERR2}|%{SSHD_TUNN_ERR3}|%{SSHD_TUNN_ERR4}|%{SSHD_TUNN_TIMEOUT}","title":"SSHD_TUNN"},{"location":"references/patterns-documentation.html#sshd_session_fail","text":"Pattern : pam_systemd\\(sshd:session\\): Failed to release session: %{GREEDYDATA:sshd_disconnect_status}","title":"SSHD_SESSION_FAIL"},{"location":"references/patterns-documentation.html#bacula_log_nojobs","text":"Pattern : There are no more Jobs associated with Volume \\\"%{BACULA_VOLUME:volume}\\\". Marking it purged.","title":"BACULA_LOG_NOJOBS"},{"location":"references/patterns-documentation.html#rprocessing","text":"Pattern : \\W*Processing by %{RCONTROLLER} as %{NOTSPACE:format}(?:\\W*Parameters: \\{\\%\\{DATA:params}}\\W*)?","title":"RPROCESSING"},{"location":"references/patterns-documentation.html#ciscofw105009","text":"Pattern : \\((?:Primary|Secondary)\\) Testing on [Ii]nterface %{GREEDYDATA:interface_name} (?:Passed|Failed)","title":"CISCOFW105009"},{"location":"references/patterns-documentation.html#sshd_log","text":"Pattern : %{SSHD_INIT}|%{SSHD_NORMAL_LOG}|%{SSHD_PROBE_LOG}|%{SSHD_CORRUPTED}|%{SSHD_TUNN}|%{SSHD_PREAUTH}","title":"SSHD_LOG"},{"location":"references/patterns-documentation.html#sshd_disc_preauth","text":"Pattern : Disconnected from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|)","title":"SSHD_DISC_PREAUTH"},{"location":"references/patterns-documentation.html#sshd_rest_preauth","text":"Pattern : Connection reset by %{IP:sshd_client_ip} port %{NUMBER:sshd_port}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|)","title":"SSHD_REST_PREAUTH"},{"location":"references/patterns-documentation.html#tomcatlog","text":"Pattern : %{TOMCAT_DATESTAMP:timestamp} \\| %{LOGLEVEL:level} \\| %{JAVACLASS:class} - %{JAVALOGMESSAGE:logmessage}","title":"TOMCATLOG"},{"location":"references/patterns-documentation.html#sshd_clos_preauth","text":"Pattern : Connection closed by %{IP:sshd_client_ip} port %{NUMBER:sshd_port}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|)","title":"SSHD_CLOS_PREAUTH"},{"location":"references/patterns-documentation.html#cisco_tagged_syslog","text":"Pattern : ^<%{POSINT:syslog_pri}>%{CISCOTIMESTAMP:timestamp}( %{SYSLOGHOST:sysloghost})? ?: %%{CISCOTAG:ciscotag}:","title":"CISCO_TAGGED_SYSLOG"},{"location":"references/patterns-documentation.html#sshd_inva_preauth","text":"Pattern : input_userauth_request: invalid user %{USERNAME:sshd_invalid_user}?\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|)","title":"SSHD_INVA_PREAUTH"},{"location":"references/patterns-documentation.html#rails3head","text":"Pattern : (?m)Started %{WORD:verb} \"%{URIPATHPARAM:request}\" for %{IPORHOST:clientip} at %{RAILS_TIMESTAMP:timestamp}","title":"RAILS3HEAD"},{"location":"references/patterns-documentation.html#ciscofw105005","text":"Pattern : \\((?:Primary|Secondary)\\) Lost Failover communications with mate on [Ii]nterface %{GREEDYDATA:interface_name}","title":"CISCOFW105005"},{"location":"references/patterns-documentation.html#bacula_log_new_label","text":"Pattern : Labeled new Volume \\\"%{BACULA_VOLUME:volume}\\\" on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\).","title":"BACULA_LOG_NEW_LABEL"},{"location":"references/patterns-documentation.html#nagios_ec_line_enable_host_check","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_HOST_CHECK:nagios_command};%{DATA:nagios_hostname}","title":"NAGIOS_EC_LINE_ENABLE_HOST_CHECK"},{"location":"references/patterns-documentation.html#cowrie_new_co","text":"Pattern : New connection: %{IPV4:source_ip}:[0-9]+ \\(%{IPV4:dest_ip}:%{INT:dest_port}\\) \\[session: %{DATA:telnet_session}\\]$","title":"COWRIE_NEW_CO"},{"location":"references/patterns-documentation.html#cisco_action","text":"Pattern : Built|Teardown|Deny|Denied|denied|requested|permitted|denied by ACL|discarded|est-allowed|Dropping|created|deleted","title":"CISCO_ACTION"},{"location":"references/patterns-documentation.html#nagios_ec_line_disable_host_check","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_HOST_CHECK:nagios_command};%{DATA:nagios_hostname}","title":"NAGIOS_EC_LINE_DISABLE_HOST_CHECK"},{"location":"references/patterns-documentation.html#ciscofw402117","text":"Pattern : %{WORD:protocol}: Received a non-IPSec packet \\(protocol= %{WORD:orig_protocol}\\) from %{IP:src_ip} to %{IP:dst_ip}","title":"CISCOFW402117"},{"location":"references/patterns-documentation.html#bacula_log_wrote_label","text":"Pattern : Wrote label to prelabeled Volume \\\"%{BACULA_VOLUME:volume}\\\" on device \\\"%{BACULA_DEVICE}\\\" \\(%{BACULA_DEVICEPATH}\\)","title":"BACULA_LOG_WROTE_LABEL"},{"location":"references/patterns-documentation.html#rails3profile","text":"Pattern : (?:\\(Views: %{NUMBER:viewms}ms \\| ActiveRecord: %{NUMBER:activerecordms}ms|\\(ActiveRecord: %{NUMBER:activerecordms}ms)?","title":"RAILS3PROFILE"},{"location":"references/patterns-documentation.html#ciscofw500004","text":"Pattern : %{CISCO_REASON:reason} for protocol=%{WORD:protocol}, from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port}","title":"CISCOFW500004"},{"location":"references/patterns-documentation.html#nagios_timeperiod_transition","text":"Pattern : %{NAGIOS_TYPE_TIMEPERIOD_TRANSITION:nagios_type}: %{DATA:nagios_service};%{DATA:nagios_unknown1};%{DATA:nagios_unknown2}","title":"NAGIOS_TIMEPERIOD_TRANSITION"},{"location":"references/patterns-documentation.html#nagios_passive_host_check","text":"Pattern : %{NAGIOS_TYPE_PASSIVE_HOST_CHECK:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment}","title":"NAGIOS_PASSIVE_HOST_CHECK"},{"location":"references/patterns-documentation.html#nagios_host_downtime_alert","text":"Pattern : %{NAGIOS_TYPE_HOST_DOWNTIME_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment}","title":"NAGIOS_HOST_DOWNTIME_ALERT"},{"location":"references/patterns-documentation.html#nagios_host_flapping_alert","text":"Pattern : %{NAGIOS_TYPE_HOST_FLAPPING_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_message}","title":"NAGIOS_HOST_FLAPPING_ALERT"},{"location":"references/patterns-documentation.html#httpd20_errorlog","text":"Pattern : \\[%{HTTPDERROR_DATE:timestamp}\\] \\[%{LOGLEVEL:loglevel}\\] (?:\\[client %{IPORHOST:clientip}\\] ){0,1}%{GREEDYDATA:errormsg}","title":"HTTPD20_ERRORLOG"},{"location":"references/patterns-documentation.html#nginxerror","text":"Pattern : %{NGINXERRTIME:time} \\[%{LOGLEVEL:loglevel}\\] %{NONNEGINT:pid}#%{NONNEGINT:tid}: (\\*%{NONNEGINT:cid} )?%{GREEDYDATA:message}","title":"NGINXERROR"},{"location":"references/patterns-documentation.html#mysql_auth_fail","text":"Pattern : %{TIMESTAMP_ISO8601:time} %{NUMBER} \\[Note\\] Access denied for user '%{DATA:user}'@'%{IP:source_ip}' \\(using password: YES\\)","title":"MYSQL_AUTH_FAIL"},{"location":"references/patterns-documentation.html#bacula_log_max_capacity","text":"Pattern : User defined maximum volume capacity %{BACULA_CAPACITY} exceeded on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\)","title":"BACULA_LOG_MAX_CAPACITY"},{"location":"references/patterns-documentation.html#nagios_ec_line_enable_host_notifications","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_HOST_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname}","title":"NAGIOS_EC_LINE_ENABLE_HOST_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#haproxydate","text":"Pattern : %{MONTHDAY:haproxy_monthday}/%{MONTH:haproxy_month}/%{YEAR:haproxy_year}:%{HAPROXYTIME:haproxy_time}.%{INT:haproxy_milliseconds}","title":"HAPROXYDATE"},{"location":"references/patterns-documentation.html#ciscofw106021","text":"Pattern : %{CISCO_ACTION:action} %{WORD:protocol} reverse path check from %{IP:src_ip} to %{IP:dst_ip} on interface %{GREEDYDATA:interface}","title":"CISCOFW106021"},{"location":"references/patterns-documentation.html#ruby_logger","text":"Pattern : [DFEWI], \\[%{TIMESTAMP_ISO8601:timestamp} #%{POSINT:pid}\\] *%{RUBY_LOGLEVEL:loglevel} -- +%{DATA:progname}: %{GREEDYDATA:message}","title":"RUBY_LOGGER"},{"location":"references/patterns-documentation.html#nagios_ec_line_disable_host_notifications","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_HOST_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname}","title":"NAGIOS_EC_LINE_DISABLE_HOST_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#ciscofw110002","text":"Pattern : %{CISCO_REASON:reason} for %{WORD:protocol} from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port}","title":"CISCOFW110002"},{"location":"references/patterns-documentation.html#nagios_ec_line_enable_host_svc_notifications","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_HOST_SVC_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname}","title":"NAGIOS_EC_LINE_ENABLE_HOST_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#nagios_ec_line_disable_host_svc_notifications","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_HOST_SVC_NOTIFICATIONS:nagios_command};%{GREEDYDATA:nagios_hostname}","title":"NAGIOS_EC_LINE_DISABLE_HOST_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#sshd_rmap_fail","text":"Pattern : reverse mapping checking getaddrinfo for %{HOSTNAME:sshd_client_hostname} \\[%{IP:sshd_client_ip}\\] failed - POSSIBLE BREAK-IN ATTEMPT!","title":"SSHD_RMAP_FAIL"},{"location":"references/patterns-documentation.html#haproxyhttp","text":"Pattern : (?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) %{IPORHOST:syslog_server} %{SYSLOGPROG}: %{HAPROXYHTTPBASE}","title":"HAPROXYHTTP"},{"location":"references/patterns-documentation.html#sshd_user_fail","text":"Pattern : Failed password for invalid user %{USERNAME:sshd_invalid_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol}","title":"SSHD_USER_FAIL"},{"location":"references/patterns-documentation.html#syslogbase2","text":"Pattern : (?:%{SYSLOGTIMESTAMP:timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) (?:%{SYSLOGFACILITY} )?%{SYSLOGHOST:logsource}+(?: %{SYSLOGPROG}:|)","title":"SYSLOGBASE2"},{"location":"references/patterns-documentation.html#sshd_normal_log","text":"Pattern : %{SSHD_SUCCESS}|%{SSHD_DISCONNECT}|%{SSHD_CONN_CLOSE}|%{SSHD_SESSION_OPEN}|%{SSHD_SESSION_CLOSE}|%{SSHD_SESSION_FAIL}|%{SSHD_LOGOUT_ERR}","title":"SSHD_NORMAL_LOG"},{"location":"references/patterns-documentation.html#sshd_fail","text":"Pattern : Failed %{WORD:sshd_auth_type} for %{USERNAME:sshd_invalid_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol}","title":"SSHD_FAIL"},{"location":"references/patterns-documentation.html#nagios_ec_line_enable_svc_check","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_SVC_CHECK:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_service}","title":"NAGIOS_EC_LINE_ENABLE_SVC_CHECK"},{"location":"references/patterns-documentation.html#nagios_ec_line_disable_svc_check","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_SVC_CHECK:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_service}","title":"NAGIOS_EC_LINE_DISABLE_SVC_CHECK"},{"location":"references/patterns-documentation.html#cisco_reason","text":"Pattern : Duplicate TCP SYN|Failed to locate egress interface|Invalid transport field|No matching connection|DNS Response|DNS Query|(?:%{WORD}\\s*)*","title":"CISCO_REASON"},{"location":"references/patterns-documentation.html#sshd_corrupted","text":"Pattern : %{SSHD_IDENT_FAIL}|%{SSHD_MAPB_FAIL}|%{SSHD_RMAP_FAIL}|%{SSHD_TOOMANY_AUTH}|%{SSHD_CORRUPT_MAC}|%{SSHD_PACKET_CORRUPT}|%{SSHD_BAD_VERSION}","title":"SSHD_CORRUPTED"},{"location":"references/patterns-documentation.html#bacula_log_no_connect","text":"Pattern : Warning: bsock.c:127 Could not connect to (Client: %{BACULA_HOST:client}|Storage daemon) on %{HOSTNAME}:%{POSINT}. ERR=%{GREEDYDATA:berror}","title":"BACULA_LOG_NO_CONNECT"},{"location":"references/patterns-documentation.html#sshd_disconnect","text":"Pattern : Received disconnect from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:%{NUMBER:sshd_disconnect_code}: %{GREEDYDATA:sshd_disconnect_status}","title":"SSHD_DISCONNECT"},{"location":"references/patterns-documentation.html#sshd_mapb_fail","text":"Pattern : Address %{IP:sshd_client_ip} maps to %{HOSTNAME:sshd_client_hostname}, but this does not map back to the address - POSSIBLE BREAK-IN ATTEMPT!","title":"SSHD_MAPB_FAIL"},{"location":"references/patterns-documentation.html#sshd_tcpwrap_fail2","text":"Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: host name/address mismatch: %{IPORHOST:sshd_client_ip} != %{HOSTNAME:sshd_paranoid_hostname}","title":"SSHD_TCPWRAP_FAIL2"},{"location":"references/patterns-documentation.html#mongo3_log","text":"Pattern : %{TIMESTAMP_ISO8601:timestamp} %{MONGO3_SEVERITY:severity} %{MONGO3_COMPONENT:component}%{SPACE}(?:\\[%{DATA:context}\\])? %{GREEDYDATA:message}","title":"MONGO3_LOG"},{"location":"references/patterns-documentation.html#bacula_log_fatal_conn","text":"Pattern : Fatal error: bsock.c:133 Unable to connect to (Client: %{BACULA_HOST:client}|Storage daemon) on %{HOSTNAME}:%{POSINT}. ERR=%{GREEDYDATA:berror}","title":"BACULA_LOG_FATAL_CONN"},{"location":"references/patterns-documentation.html#sshd_tcpwrap_fail4","text":"Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: host name/name mismatch: reverse lookup results in non-FQDN %{HOSTNAME:sshd_paranoid_hostname}","title":"SSHD_TCPWRAP_FAIL4"},{"location":"references/patterns-documentation.html#ciscofw710001_710002_710003_710005_710006","text":"Pattern : %{WORD:protocol} (?:request|access) %{CISCO_ACTION:action} from %{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port}","title":"CISCOFW710001_710002_710003_710005_710006"},{"location":"references/patterns-documentation.html#nagios_passive_service_check","text":"Pattern : %{NAGIOS_TYPE_PASSIVE_SERVICE_CHECK:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment}","title":"NAGIOS_PASSIVE_SERVICE_CHECK"},{"location":"references/patterns-documentation.html#nagios_service_flapping_alert","text":"Pattern : %{NAGIOS_TYPE_SERVICE_FLAPPING_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_message}","title":"NAGIOS_SERVICE_FLAPPING_ALERT"},{"location":"references/patterns-documentation.html#nagios_service_downtime_alert","text":"Pattern : %{NAGIOS_TYPE_SERVICE_DOWNTIME_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_comment}","title":"NAGIOS_SERVICE_DOWNTIME_ALERT"},{"location":"references/patterns-documentation.html#tcpdump_output","text":"Pattern : %{GREEDYDATA:timestamp} IP %{IPORHOST:source_ip}\\.%{INT:source_port} > %{IPORHOST:dest_ip}\\.%{INT:dest_port}: Flags \\[%{GREEDYDATA:tcpflags}\\], seq","title":"TCPDUMP_OUTPUT"},{"location":"references/patterns-documentation.html#sshd_tcpwrap_fail1","text":"Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: can't verify hostname: getaddrinfo\\(%{DATA:sshd_paranoid_hostname}, %{DATA:sshd_sa_family}\\) failed","title":"SSHD_TCPWRAP_FAIL1"},{"location":"references/patterns-documentation.html#sshd_fail_preauth","text":"Pattern : fatal: Unable to negotiate with %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:\\s*%{GREEDYDATA:sshd_disconnect_status}? \\[%{GREEDYDATA:sshd_privsep}\\]","title":"SSHD_FAIL_PREAUTH"},{"location":"references/patterns-documentation.html#nagios_ec_line_enable_svc_notifications","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_ENABLE_SVC_NOTIFICATIONS:nagios_command};%{DATA:nagios_hostname};%{GREEDYDATA:nagios_service}","title":"NAGIOS_EC_LINE_ENABLE_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#sshd_tcpwrap_fail3","text":"Pattern : warning: %{DATA:sshd_tcpd_file}, line %{NUMBER}: host name/name mismatch: %{HOSTNAME:sshd_paranoid_hostname_1} != %{HOSTNAME:sshd_paranoid_hostname_2}","title":"SSHD_TCPWRAP_FAIL3"},{"location":"references/patterns-documentation.html#nagios_ec_line_disable_svc_notifications","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_DISABLE_SVC_NOTIFICATIONS:nagios_command};%{DATA:nagios_hostname};%{GREEDYDATA:nagios_service}","title":"NAGIOS_EC_LINE_DISABLE_SVC_NOTIFICATIONS"},{"location":"references/patterns-documentation.html#nagios_host_event_handler","text":"Pattern : %{NAGIOS_TYPE_HOST_EVENT_HANDLER:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{DATA:nagios_event_handler_name}","title":"NAGIOS_HOST_EVENT_HANDLER"},{"location":"references/patterns-documentation.html#ciscofw313001_313004_313008","text":"Pattern : %{CISCO_ACTION:action} %{WORD:protocol} type=%{INT:icmp_type}, code=%{INT:icmp_code} from %{IP:src_ip} on interface %{DATA:interface}( to %{IP:dst_ip})?","title":"CISCOFW313001_313004_313008"},{"location":"references/patterns-documentation.html#bacula_log_end_volume","text":"Pattern : End of medium on Volume \\\"%{BACULA_VOLUME:volume}\\\" Bytes=%{BACULA_CAPACITY} Blocks=%{BACULA_CAPACITY} at %{MONTHDAY}-%{MONTH}-%{YEAR} %{HOUR}:%{MINUTE}.","title":"BACULA_LOG_END_VOLUME"},{"location":"references/patterns-documentation.html#sshd_success","text":"Pattern : Accepted %{WORD:sshd_auth_type} for %{USERNAME:sshd_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol}: %{GREEDYDATA:sshd_cipher}","title":"SSHD_SUCCESS"},{"location":"references/patterns-documentation.html#smb_auth_fail","text":"Pattern : Auth:%{GREEDYDATA} user \\[%{DATA:smb_domain}\\]\\\\\\[%{DATA:user}\\]%{GREEDYDATA} status \\[NT_STATUS_NO_SUCH_USER\\]%{GREEDYDATA} remote host \\[ipv4:%{IP:ip_source}","title":"SMB_AUTH_FAIL"},{"location":"references/patterns-documentation.html#bacula_log_new_mount","text":"Pattern : New volume \\\"%{BACULA_VOLUME:volume}\\\" mounted on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\) at %{MONTHDAY}-%{MONTH}-%{YEAR} %{HOUR}:%{MINUTE}.","title":"BACULA_LOG_NEW_MOUNT"},{"location":"references/patterns-documentation.html#nagios_host_alert","text":"Pattern : %{NAGIOS_TYPE_HOST_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{NUMBER:nagios_attempt};%{GREEDYDATA:nagios_message}","title":"NAGIOS_HOST_ALERT"},{"location":"references/patterns-documentation.html#nagios_host_notification","text":"Pattern : %{NAGIOS_TYPE_HOST_NOTIFICATION:nagios_type}: %{DATA:nagios_notifyname};%{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_contact};%{GREEDYDATA:nagios_message}","title":"NAGIOS_HOST_NOTIFICATION"},{"location":"references/patterns-documentation.html#syslogpamsession","text":"Pattern : %{SYSLOGBASE} %{GREEDYDATA:message}%{WORD:pam_module}\\(%{DATA:pam_caller}\\): session %{WORD:pam_session_state} for user %{USERNAME:username}(?: by %{GREEDYDATA:pam_by})?","title":"SYSLOGPAMSESSION"},{"location":"references/patterns-documentation.html#nagios_current_host_state","text":"Pattern : %{NAGIOS_TYPE_CURRENT_HOST_STATE:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_state};%{DATA:nagios_statetype};%{DATA:nagios_statecode};%{GREEDYDATA:nagios_message}","title":"NAGIOS_CURRENT_HOST_STATE"},{"location":"references/patterns-documentation.html#ciscofw419002","text":"Pattern : %{CISCO_REASON:reason} from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port} with different initial sequence number","title":"CISCOFW419002"},{"location":"references/patterns-documentation.html#ipv4","text":"Pattern : (?:(?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5])[.](?:[0-1]?[0-9]{1,2}|2[0-4][0-9]|25[0-5]))","title":"IPV4"},{"location":"references/patterns-documentation.html#sshd_fai2_preauth","text":"Pattern : fatal: %{GREEDYDATA:sshd_fatal_status}: Connection from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:\\s*%{GREEDYDATA:sshd_disconnect_status}? \\[%{GREEDYDATA:sshd_privsep}\\]","title":"SSHD_FAI2_PREAUTH"},{"location":"references/patterns-documentation.html#apacheerrorprefix","text":"Pattern : \\[%{APACHEERRORTIME:timestamp}\\] \\[%{NOTSPACE:apacheseverity}\\] (\\[pid %{INT}:tid %{INT}\\] )?\\[client %{IPORHOST:sourcehost}(:%{INT:source_port})?\\] (\\[client %{IPORHOST}\\])?","title":"APACHEERRORPREFIX"},{"location":"references/patterns-documentation.html#nagios_service_event_handler","text":"Pattern : %{NAGIOS_TYPE_SERVICE_EVENT_HANDLER:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{DATA:nagios_event_handler_name}","title":"NAGIOS_SERVICE_EVENT_HANDLER"},{"location":"references/patterns-documentation.html#nagios_ec_line_process_host_check_result","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_PROCESS_HOST_CHECK_RESULT:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_state};%{GREEDYDATA:nagios_check_result}","title":"NAGIOS_EC_LINE_PROCESS_HOST_CHECK_RESULT"},{"location":"references/patterns-documentation.html#sshd_probe_log","text":"Pattern : %{SSHD_REFUSE_CONN}|%{SSHD_TCPWRAP_FAIL1}|%{SSHD_TCPWRAP_FAIL2}|%{SSHD_TCPWRAP_FAIL3}|%{SSHD_TCPWRAP_FAIL4}|%{SSHD_TCPWRAP_FAIL5}|%{SSHD_FAIL}|%{SSHD_USER_FAIL}|%{SSHD_INVAL_USER}","title":"SSHD_PROBE_LOG"},{"location":"references/patterns-documentation.html#naxsi_exlog","text":"Pattern : ^NAXSI_EXLOG: ip=%{IPORHOST:naxsi_src_ip}&server=%{IPORHOST:naxsi_dst_ip}&uri=%{PATH:http_path}&id=%{INT:naxsi_id}&zone=%{WORD:naxsi_zone}&var_name=%{DATA:naxsi_var_name}&content=","title":"NAXSI_EXLOG"},{"location":"references/patterns-documentation.html#sshd_rece_preauth","text":"Pattern : (?:error: |)Received disconnect from %{IP:sshd_client_ip} port %{NUMBER:sshd_port}:%{NUMBER:sshd_disconnect_code}: %{GREEDYDATA:sshd_disconnect_status}? \\[%{GREEDYDATA:sshd_privsep}\\]","title":"SSHD_RECE_PREAUTH"},{"location":"references/patterns-documentation.html#month","text":"Pattern : \\bJan(?:uary|uar)?|Feb(?:ruary|ruar)?|M(?:a|\u00e4)?r(?:ch|z)?|Apr(?:il)?|Ma(?:y|i)?|Jun(?:e|i)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|O(?:c|k)?t(?:ober)?|Nov(?:ember)?|De(?:c|z)(?:ember)?\\b","title":"MONTH"},{"location":"references/patterns-documentation.html#ciscofw419001","text":"Pattern : %{CISCO_ACTION:action} %{WORD:protocol} packet from %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port} to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port}, reason: %{GREEDYDATA:reason}","title":"CISCOFW419001"},{"location":"references/patterns-documentation.html#nagios_service_alert","text":"Pattern : %{NAGIOS_TYPE_SERVICE_ALERT:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_statelevel};%{NUMBER:nagios_attempt};%{GREEDYDATA:nagios_message}","title":"NAGIOS_SERVICE_ALERT"},{"location":"references/patterns-documentation.html#ciscofw106015","text":"Pattern : %{CISCO_ACTION:action} %{WORD:protocol} \\(%{DATA:policy_id}\\) from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} flags %{DATA:tcp_flags} on interface %{GREEDYDATA:interface}","title":"CISCOFW106015"},{"location":"references/patterns-documentation.html#ciscofw602303_602304","text":"Pattern : %{WORD:protocol}: An %{CISCO_DIRECTION:direction} %{GREEDYDATA:tunnel_type} SA \\(SPI= %{DATA:spi}\\) between %{IP:src_ip} and %{IP:dst_ip} \\(user= %{DATA:user}\\) has been %{CISCO_ACTION:action}","title":"CISCOFW602303_602304"},{"location":"references/patterns-documentation.html#nagios_service_notification","text":"Pattern : %{NAGIOS_TYPE_SERVICE_NOTIFICATION:nagios_type}: %{DATA:nagios_notifyname};%{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_contact};%{GREEDYDATA:nagios_message}","title":"NAGIOS_SERVICE_NOTIFICATION"},{"location":"references/patterns-documentation.html#rt_flow3","text":"Pattern : %{RT_FLOW_EVENT:event}: session denied %{IP:src-ip}/%{INT:src-port}->%{IP:dst-ip}/%{INT:dst-port} %{DATA:service} %{INT:protocol-id}\\(\\d\\) %{DATA:policy-name} %{DATA:from-zone} %{DATA:to-zone} .*","title":"RT_FLOW3"},{"location":"references/patterns-documentation.html#nagios_current_service_state","text":"Pattern : %{NAGIOS_TYPE_CURRENT_SERVICE_STATE:nagios_type}: %{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{DATA:nagios_statetype};%{DATA:nagios_statecode};%{GREEDYDATA:nagios_message}","title":"NAGIOS_CURRENT_SERVICE_STATE"},{"location":"references/patterns-documentation.html#ciscofw713172","text":"Pattern : Group = %{GREEDYDATA:group}, IP = %{IP:src_ip}, Automatic NAT Detection Status:\\s+Remote end\\s*%{DATA:is_remote_natted}\\s*behind a NAT device\\s+This\\s+end\\s*%{DATA:is_local_natted}\\s*behind a NAT device","title":"CISCOFW713172"},{"location":"references/patterns-documentation.html#nagios_ec_line_process_service_check_result","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_PROCESS_SERVICE_CHECK_RESULT:nagios_command};%{DATA:nagios_hostname};%{DATA:nagios_service};%{DATA:nagios_state};%{GREEDYDATA:nagios_check_result}","title":"NAGIOS_EC_LINE_PROCESS_SERVICE_CHECK_RESULT"},{"location":"references/patterns-documentation.html#ciscofw402119","text":"Pattern : %{WORD:protocol}: Received an %{WORD:orig_protocol} packet \\(SPI= %{DATA:spi}, sequence number= %{DATA:seq_num}\\) from %{IP:src_ip} \\(user= %{DATA:user}\\) to %{IP:dst_ip} that failed anti-replay checking","title":"CISCOFW402119"},{"location":"references/patterns-documentation.html#sshd_preauth","text":"Pattern : %{SSHD_DISC_PREAUTH}|%{SSHD_RECE_PREAUTH}|%{SSHD_MAXE_PREAUTH}|%{SSHD_DISR_PREAUTH}|%{SSHD_INVA_PREAUTH}|%{SSHD_REST_PREAUTH}|%{SSHD_FAIL_PREAUTH}|%{SSHD_CLOS_PREAUTH}|%{SSHD_FAI2_PREAUTH}|%{SSHD_BADL_PREAUTH}","title":"SSHD_PREAUTH"},{"location":"references/patterns-documentation.html#commonapachelog","text":"Pattern : %{IPORHOST:clientip} %{HTTPDUSER:ident} %{USER:auth} \\[%{HTTPDATE:timestamp}\\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-)","title":"COMMONAPACHELOG"},{"location":"references/patterns-documentation.html#sshd_maxe_preauth","text":"Pattern : error: maximum authentication attempts exceeded for (?:invalid user |)%{USERNAME:sshd_invalid_user} from %{IP:sshd_client_ip} port %{NUMBER:sshd_port} %{WORD:sshd_protocol}\\s*(?:\\[%{GREEDYDATA:sshd_privsep}\\]|)","title":"SSHD_MAXE_PREAUTH"},{"location":"references/patterns-documentation.html#ciscofw106001","text":"Pattern : %{CISCO_DIRECTION:direction} %{WORD:protocol} connection %{CISCO_ACTION:action} from %{IP:src_ip}/%{INT:src_port} to %{IP:dst_ip}/%{INT:dst_port} flags %{GREEDYDATA:tcp_flags} on interface %{GREEDYDATA:interface}","title":"CISCOFW106001"},{"location":"references/patterns-documentation.html#loglevel","text":"Pattern : [Aa]lert|ALERT|[Tt]race|TRACE|[Dd]ebug|DEBUG|[Nn]otice|NOTICE|[Ii]nfo|INFO|[Ww]arn?(?:ing)?|WARN?(?:ING)?|[Ee]rr?(?:or)?|ERR?(?:OR)?|[Cc]rit?(?:ical)?|CRIT?(?:ICAL)?|[Ff]atal|FATAL|[Ss]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?","title":"LOGLEVEL"},{"location":"references/patterns-documentation.html#ciscofw305011","text":"Pattern : %{CISCO_ACTION:action} %{CISCO_XLATE_TYPE:xlate_type} %{WORD:protocol} translation from %{DATA:src_interface}:%{IP:src_ip}(/%{INT:src_port})?(\\(%{DATA:src_fwuser}\\))? to %{DATA:src_xlated_interface}:%{IP:src_xlated_ip}/%{DATA:src_xlated_port}","title":"CISCOFW305011"},{"location":"references/patterns-documentation.html#mongo_slowquery","text":"Pattern : %{WORD} %{MONGO_WORDDASH:database}\\.%{MONGO_WORDDASH:collection} %{WORD}: %{MONGO_QUERY:query} %{WORD}:%{NONNEGINT:ntoreturn} %{WORD}:%{NONNEGINT:ntoskip} %{WORD}:%{NONNEGINT:nscanned}.*nreturned:%{NONNEGINT:nreturned}..+ %{POSINT:duration}ms","title":"MONGO_SLOWQUERY"},{"location":"references/patterns-documentation.html#naxsi_fmt","text":"Pattern : ^NAXSI_FMT: ip=%{IPORHOST:src_ip}&server=%{IPORHOST:target_ip}&uri=%{PATH:http_path}&learning=\\d&vers=%{DATA:naxsi_version}&total_processed=\\d+&total_blocked=\\d+&block=\\d+(&cscore\\d=%{WORD:score_label}&score\\d=%{INT:score})+&zone0=%{WORD:zone}","title":"NAXSI_FMT"},{"location":"references/patterns-documentation.html#ciscofw106014","text":"Pattern : %{CISCO_ACTION:action} %{CISCO_DIRECTION:direction} %{WORD:protocol} src %{DATA:src_interface}:%{IP:src_ip}(\\(%{DATA:src_fwuser}\\))? dst %{DATA:dst_interface}:%{IP:dst_ip}(\\(%{DATA:dst_fwuser}\\))? \\(type %{INT:icmp_type}, code %{INT:icmp_code}\\)","title":"CISCOFW106014"},{"location":"references/patterns-documentation.html#nginxaccess","text":"Pattern : %{IPORHOST:remote_addr} - %{NGUSER:remote_user} \\[%{HTTPDATE:time_local}\\] \"%{WORD:method} %{URIPATHPARAM:request} HTTP/%{NUMBER:http_version}\" %{NUMBER:status} %{NUMBER:body_bytes_sent} \"%{NOTDQUOTE:http_referer}\" \"%{NOTDQUOTE:http_user_agent}\"","title":"NGINXACCESS"},{"location":"references/patterns-documentation.html#exim_exclude_terms","text":"Pattern : (Message is frozen|(Start|End) queue run| Warning: | retry time not reached | no (IP address|host name) found for (IP address|host) | unexpected disconnection while reading SMTP command | no immediate delivery: |another process is handling this message)","title":"EXIM_EXCLUDE_TERMS"},{"location":"references/patterns-documentation.html#ciscofw302020_302021","text":"Pattern : %{CISCO_ACTION:action}(?: %{CISCO_DIRECTION:direction})? %{WORD:protocol} connection for faddr %{IP:dst_ip}/%{INT:icmp_seq_num}(?:\\(%{DATA:fwuser}\\))? gaddr %{IP:src_xlated_ip}/%{INT:icmp_code_xlated} laddr %{IP:src_ip}/%{INT:icmp_code}( \\(%{DATA:user}\\))?","title":"CISCOFW302020_302021"},{"location":"references/patterns-documentation.html#ciscofw106006_106007_106010","text":"Pattern : %{CISCO_ACTION:action} %{CISCO_DIRECTION:direction} %{WORD:protocol} (?:from|src) %{IP:src_ip}/%{INT:src_port}(\\(%{DATA:src_fwuser}\\))? (?:to|dst) %{IP:dst_ip}/%{INT:dst_port}(\\(%{DATA:dst_fwuser}\\))? (?:on interface %{DATA:interface}|due to %{CISCO_REASON:reason})","title":"CISCOFW106006_106007_106010"},{"location":"references/patterns-documentation.html#httpd24_errorlog","text":"Pattern : \\[%{HTTPDERROR_DATE:timestamp}\\] \\[%{WORD:module}:%{LOGLEVEL:loglevel}\\] \\[pid %{POSINT:pid}:tid %{NUMBER:tid}\\]( \\(%{POSINT:proxy_errorcode}\\)%{DATA:proxy_errormessage}:)?( \\[client %{IPORHOST:client}:%{POSINT:clientport}\\])? %{DATA:errorcode}: %{GREEDYDATA:message}","title":"HTTPD24_ERRORLOG"},{"location":"references/patterns-documentation.html#modsecapacheerror","text":"Pattern : %{MODSECPREFIX} %{MODSECRULEFILE} %{MODSECRULELINE} (?:%{MODSECMATCHOFFSET} )?(?:%{MODSECRULEID} )?(?:%{MODSECRULEREV} )?(?:%{MODSECRULEMSG} )?(?:%{MODSECRULEDATA} )?(?:%{MODSECRULESEVERITY} )?(?:%{MODSECRULEVERS} )?%{MODSECRULETAGS}%{MODSECHOSTNAME} %{MODSECURI} %{MODSECUID}","title":"MODSECAPACHEERROR"},{"location":"references/patterns-documentation.html#nagios_ec_line_schedule_host_downtime","text":"Pattern : %{NAGIOS_TYPE_EXTERNAL_COMMAND:nagios_type}: %{NAGIOS_EC_SCHEDULE_HOST_DOWNTIME:nagios_command};%{DATA:nagios_hostname};%{NUMBER:nagios_start_time};%{NUMBER:nagios_end_time};%{NUMBER:nagios_fixed};%{NUMBER:nagios_trigger_id};%{NUMBER:nagios_duration};%{DATA:author};%{DATA:comment}","title":"NAGIOS_EC_LINE_SCHEDULE_HOST_DOWNTIME"},{"location":"references/patterns-documentation.html#syslog5424base","text":"Pattern : %{SYSLOG5424PRI}%{NONNEGINT:syslog5424_ver} +(?:%{TIMESTAMP_ISO8601:syslog5424_ts}|-) +(?:%{HOSTNAME:syslog5424_host}|-) +(-|%{SYSLOG5424PRINTASCII:syslog5424_app}) +(-|%{SYSLOG5424PRINTASCII:syslog5424_proc}) +(-|%{SYSLOG5424PRINTASCII:syslog5424_msgid}) +(?:%{SYSLOG5424SD:syslog5424_sd}|-|)","title":"SYSLOG5424BASE"},{"location":"references/patterns-documentation.html#ciscofw106100_2_3","text":"Pattern : access-list %{NOTSPACE:policy_id} %{CISCO_ACTION:action} %{WORD:protocol} for user '%{DATA:src_fwuser}' %{DATA:src_interface}/%{IP:src_ip}\\(%{INT:src_port}\\) -> %{DATA:dst_interface}/%{IP:dst_ip}\\(%{INT:dst_port}\\) hit-cnt %{INT:hit_count} %{CISCO_INTERVAL:interval} \\[%{DATA:hashcode1}, %{DATA:hashcode2}\\]","title":"CISCOFW106100_2_3"},{"location":"references/patterns-documentation.html#ciscofw106100","text":"Pattern : access-list %{NOTSPACE:policy_id} %{CISCO_ACTION:action} %{WORD:protocol} %{DATA:src_interface}/%{IP:src_ip}\\(%{INT:src_port}\\)(\\(%{DATA:src_fwuser}\\))? -> %{DATA:dst_interface}/%{IP:dst_ip}\\(%{INT:dst_port}\\)(\\(%{DATA:src_fwuser}\\))? hit-cnt %{INT:hit_count} %{CISCO_INTERVAL:interval} \\[%{DATA:hashcode1}, %{DATA:hashcode2}\\]","title":"CISCOFW106100"},{"location":"references/patterns-documentation.html#rt_flow2","text":"Pattern : %{RT_FLOW_EVENT:event}: session created %{IP:src-ip}/%{INT:src-port}->%{IP:dst-ip}/%{INT:dst-port} %{DATA:service} %{IP:nat-src-ip}/%{INT:nat-src-port}->%{IP:nat-dst-ip}/%{INT:nat-dst-port} %{DATA:src-nat-rule-name} %{DATA:dst-nat-rule-name} %{INT:protocol-id} %{DATA:policy-name} %{DATA:from-zone} %{DATA:to-zone} %{INT:session-id} .*","title":"RT_FLOW2"},{"location":"references/patterns-documentation.html#ciscofw733100","text":"Pattern : \\[\\s*%{DATA:drop_type}\\s*\\] drop %{DATA:drop_rate_id} exceeded. Current burst rate is %{INT:drop_rate_current_burst} per second, max configured rate is %{INT:drop_rate_max_burst}; Current average rate is %{INT:drop_rate_current_avg} per second, max configured rate is %{INT:drop_rate_max_avg}; Cumulative total count is %{INT:drop_total_count}","title":"CISCOFW733100"},{"location":"references/patterns-documentation.html#ciscofw106023","text":"Pattern : %{CISCO_ACTION:action}( protocol)? %{WORD:protocol} src %{DATA:src_interface}:%{DATA:src_ip}(/%{INT:src_port})?(\\(%{DATA:src_fwuser}\\))? dst %{DATA:dst_interface}:%{DATA:dst_ip}(/%{INT:dst_port})?(\\(%{DATA:dst_fwuser}\\))?( \\(type %{INT:icmp_type}, code %{INT:icmp_code}\\))? by access-group \"?%{DATA:policy_id}\"? \\[%{DATA:hashcode1}, %{DATA:hashcode2}\\]","title":"CISCOFW106023"},{"location":"references/patterns-documentation.html#elb_access_log","text":"Pattern : %{TIMESTAMP_ISO8601:timestamp} %{NOTSPACE:elb} %{IP:clientip}:%{INT:clientport:int} (?:(%{IP:backendip}:?:%{INT:backendport:int})|-) %{NUMBER:request_processing_time:float} %{NUMBER:backend_processing_time:float} %{NUMBER:response_processing_time:float} %{INT:response:int} %{INT:backend_response:int} %{INT:received_bytes:int} %{INT:bytes:int} \"%{ELB_REQUEST_LINE}\"","title":"ELB_ACCESS_LOG"},{"location":"references/patterns-documentation.html#modsecruletags","text":"Pattern : (?:\\[tag %{QUOTEDSTRING:ruletag0}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag1}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag2}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag3}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag4}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag5}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag6}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag7}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag8}\\] )?(?:\\[tag %{QUOTEDSTRING:ruletag9}\\] )?(?:\\[tag %{QUOTEDSTRING}\\] )*","title":"MODSECRULETAGS"},{"location":"references/patterns-documentation.html#rt_flow1","text":"Pattern : %{RT_FLOW_EVENT:event}: %{GREEDYDATA:close-reason}: %{IP:src-ip}/%{INT:src-port}->%{IP:dst-ip}/%{INT:dst-port} %{DATA:service} %{IP:nat-src-ip}/%{INT:nat-src-port}->%{IP:nat-dst-ip}/%{INT:nat-dst-port} %{DATA:src-nat-rule-name} %{DATA:dst-nat-rule-name} %{INT:protocol-id} %{DATA:policy-name} %{DATA:from-zone} %{DATA:to-zone} %{INT:session-id} \\d+\\(%{DATA:sent}\\) \\d+\\(%{DATA:received}\\) %{INT:elapsed-time} .*","title":"RT_FLOW1"},{"location":"references/patterns-documentation.html#bro_conn","text":"Pattern : %{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{GREEDYDATA:service}\\t%{NUMBER:duration}\\t%{NUMBER:orig_bytes}\\t%{NUMBER:resp_bytes}\\t%{GREEDYDATA:conn_state}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:missed_bytes}\\t%{GREEDYDATA:history}\\t%{GREEDYDATA:orig_pkts}\\t%{GREEDYDATA:orig_ip_bytes}\\t%{GREEDYDATA:resp_pkts}\\t%{GREEDYDATA:resp_ip_bytes}\\t%{GREEDYDATA:tunnel_parents}","title":"BRO_CONN"},{"location":"references/patterns-documentation.html#s3_access_log","text":"Pattern : %{WORD:owner} %{NOTSPACE:bucket} \\[%{HTTPDATE:timestamp}\\] %{IP:clientip} %{NOTSPACE:requester} %{NOTSPACE:request_id} %{NOTSPACE:operation} %{NOTSPACE:key} (?:\"%{S3_REQUEST_LINE}\"|-) (?:%{INT:response:int}|-) (?:-|%{NOTSPACE:error_code}) (?:%{INT:bytes:int}|-) (?:%{INT:object_size:int}|-) (?:%{INT:request_time_ms:int}|-) (?:%{INT:turnaround_time_ms:int}|-) (?:%{QS:referrer}|-) (?:\"?%{QS:agent}\"?|-) (?:-|%{NOTSPACE:version_id})","title":"S3_ACCESS_LOG"},{"location":"references/patterns-documentation.html#bro_dns","text":"Pattern : %{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{WORD:proto}\\t%{INT:trans_id}\\t%{GREEDYDATA:query}\\t%{GREEDYDATA:qclass}\\t%{GREEDYDATA:qclass_name}\\t%{GREEDYDATA:qtype}\\t%{GREEDYDATA:qtype_name}\\t%{GREEDYDATA:rcode}\\t%{GREEDYDATA:rcode_name}\\t%{GREEDYDATA:AA}\\t%{GREEDYDATA:TC}\\t%{GREEDYDATA:RD}\\t%{GREEDYDATA:RA}\\t%{GREEDYDATA:Z}\\t%{GREEDYDATA:answers}\\t%{GREEDYDATA:TTLs}\\t%{GREEDYDATA:rejected}","title":"BRO_DNS"},{"location":"references/patterns-documentation.html#ciscofw302013_302014_302015_302016","text":"Pattern : %{CISCO_ACTION:action}(?: %{CISCO_DIRECTION:direction})? %{WORD:protocol} connection %{INT:connection_id} for %{DATA:src_interface}:%{IP:src_ip}/%{INT:src_port}( \\(%{IP:src_mapped_ip}/%{INT:src_mapped_port}\\))?(\\(%{DATA:src_fwuser}\\))? to %{DATA:dst_interface}:%{IP:dst_ip}/%{INT:dst_port}( \\(%{IP:dst_mapped_ip}/%{INT:dst_mapped_port}\\))?(\\(%{DATA:dst_fwuser}\\))?( duration %{TIME:duration} bytes %{INT:bytes})?(?: %{CISCO_REASON:reason})?( \\(%{DATA:user}\\))?","title":"CISCOFW302013_302014_302015_302016"},{"location":"references/patterns-documentation.html#shorewall","text":"Pattern : (%{SYSLOGTIMESTAMP:timestamp}) (%{WORD:nf_host}) kernel:.*Shorewall:(%{WORD:nf_action1})?:(%{WORD:nf_action2})?.*IN=(%{USERNAME:nf_in_interface})?.*(OUT= *MAC=(%{COMMONMAC:nf_dst_mac}):(%{COMMONMAC:nf_src_mac})?|OUT=%{USERNAME:nf_out_interface}).*SRC=(%{IPV4:nf_src_ip}).*DST=(%{IPV4:nf_dst_ip}).*LEN=(%{WORD:nf_len}).*?TOS=(%{WORD:nf_tos}).*?PREC=(%{WORD:nf_prec}).*?TTL=(%{INT:nf_ttl}).*?ID=(%{INT:nf_id}).*?PROTO=(%{WORD:nf_protocol}).*?SPT=(%{INT:nf_src_port}?.*DPT=%{INT:nf_dst_port}?.*)","title":"SHOREWALL"},{"location":"references/patterns-documentation.html#haproxytcp","text":"Pattern : (?:%{SYSLOGTIMESTAMP:syslog_timestamp}|%{TIMESTAMP_ISO8601:timestamp8601}) %{IPORHOST:syslog_server} %{SYSLOGPROG}: %{IP:client_ip}:%{INT:client_port} \\[%{HAPROXYDATE:accept_date}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{INT:time_queue}/%{INT:time_backend_connect}/%{NOTSPACE:time_duration} %{NOTSPACE:bytes_read} %{NOTSPACE:termination_state} %{INT:actconn}/%{INT:feconn}/%{INT:beconn}/%{INT:srvconn}/%{NOTSPACE:retries} %{INT:srv_queue}/%{INT:backend_queue}","title":"HAPROXYTCP"},{"location":"references/patterns-documentation.html#ciscofw313005","text":"Pattern : %{CISCO_REASON:reason} for %{WORD:protocol} error message: %{WORD:err_protocol} src %{DATA:err_src_interface}:%{IP:err_src_ip}(\\(%{DATA:err_src_fwuser}\\))? dst %{DATA:err_dst_interface}:%{IP:err_dst_ip}(\\(%{DATA:err_dst_fwuser}\\))? \\(type %{INT:err_icmp_type}, code %{INT:err_icmp_code}\\) on %{DATA:interface} interface\\. Original IP payload: %{WORD:protocol} src %{IP:orig_src_ip}/%{INT:orig_src_port}(\\(%{DATA:orig_src_fwuser}\\))? dst %{IP:orig_dst_ip}/%{INT:orig_dst_port}(\\(%{DATA:orig_dst_fwuser}\\))?","title":"CISCOFW313005"},{"location":"references/patterns-documentation.html#bro_files","text":"Pattern : %{NUMBER:ts}\\t%{NOTSPACE:fuid}\\t%{IP:tx_hosts}\\t%{IP:rx_hosts}\\t%{NOTSPACE:conn_uids}\\t%{GREEDYDATA:source}\\t%{GREEDYDATA:depth}\\t%{GREEDYDATA:analyzers}\\t%{GREEDYDATA:mime_type}\\t%{GREEDYDATA:filename}\\t%{GREEDYDATA:duration}\\t%{GREEDYDATA:local_orig}\\t%{GREEDYDATA:is_orig}\\t%{GREEDYDATA:seen_bytes}\\t%{GREEDYDATA:total_bytes}\\t%{GREEDYDATA:missing_bytes}\\t%{GREEDYDATA:overflow_bytes}\\t%{GREEDYDATA:timedout}\\t%{GREEDYDATA:parent_fuid}\\t%{GREEDYDATA:md5}\\t%{GREEDYDATA:sha1}\\t%{GREEDYDATA:sha256}\\t%{GREEDYDATA:extracted}","title":"BRO_FILES"},{"location":"references/patterns-documentation.html#bro_http","text":"Pattern : %{NUMBER:ts}\\t%{NOTSPACE:uid}\\t%{IP:orig_h}\\t%{INT:orig_p}\\t%{IP:resp_h}\\t%{INT:resp_p}\\t%{INT:trans_depth}\\t%{GREEDYDATA:method}\\t%{GREEDYDATA:domain}\\t%{GREEDYDATA:uri}\\t%{GREEDYDATA:referrer}\\t%{GREEDYDATA:user_agent}\\t%{NUMBER:request_body_len}\\t%{NUMBER:response_body_len}\\t%{GREEDYDATA:status_code}\\t%{GREEDYDATA:status_msg}\\t%{GREEDYDATA:info_code}\\t%{GREEDYDATA:info_msg}\\t%{GREEDYDATA:filename}\\t%{GREEDYDATA:bro_tags}\\t%{GREEDYDATA:username}\\t%{GREEDYDATA:password}\\t%{GREEDYDATA:proxied}\\t%{GREEDYDATA:orig_fuids}\\t%{GREEDYDATA:orig_mime_types}\\t%{GREEDYDATA:resp_fuids}\\t%{GREEDYDATA:resp_mime_types}","title":"BRO_HTTP"},{"location":"references/patterns-documentation.html#netscreensessionlog","text":"Pattern : %{SYSLOGTIMESTAMP:date} %{IPORHOST:device} %{IPORHOST}: NetScreen device_id=%{WORD:device_id}%{DATA}: start_time=%{QUOTEDSTRING:start_time} duration=%{INT:duration} policy_id=%{INT:policy_id} service=%{DATA:service} proto=%{INT:proto} src zone=%{WORD:src_zone} dst zone=%{WORD:dst_zone} action=%{WORD:action} sent=%{INT:sent} rcvd=%{INT:rcvd} src=%{IPORHOST:src_ip} dst=%{IPORHOST:dst_ip} src_port=%{INT:src_port} dst_port=%{INT:dst_port} src-xlated ip=%{IPORHOST:src_xlated_ip} port=%{INT:src_xlated_port} dst-xlated ip=%{IPORHOST:dst_xlated_ip} port=%{INT:dst_xlated_port} session_id=%{INT:session_id} reason=%{GREEDYDATA:reason}","title":"NETSCREENSESSIONLOG"},{"location":"references/patterns-documentation.html#haproxyhttpbase","text":"Pattern : %{IP:client_ip}:%{INT:client_port} \\[%{HAPROXYDATE:accept_date}\\] %{NOTSPACE:frontend_name} %{NOTSPACE:backend_name}/%{NOTSPACE:server_name} %{INT:time_request}/%{INT:time_queue}/%{INT:time_backend_connect}/%{INT:time_backend_response}/%{NOTSPACE:time_duration} %{INT:http_status_code} %{NOTSPACE:bytes_read} %{DATA:captured_request_cookie} %{DATA:captured_response_cookie} %{NOTSPACE:termination_state} %{INT:actconn}/%{INT:feconn}/%{INT:beconn}/%{INT:srvconn}/%{NOTSPACE:retries} %{INT:srv_queue}/%{INT:backend_queue} (\\\\{\\%\\{HAPROXYCAPTUREDREQUESTHEADERS}\\})?( )?(\\\\{\\%\\{HAPROXYCAPTUREDRESPONSEHEADERS}\\})?( )?\"(<BADREQ>|(%{WORD:http_verb} (%{URIPROTO:http_proto}://)?(?:%{USER:http_user}(?::[^@]*)?@)?(?:%{URIHOST:http_host})?(?:%{URIPATHPARAM:http_request})?( HTTP/%{NUMBER:http_version})?))?\"","title":"HAPROXYHTTPBASE"},{"location":"references/patterns-documentation.html#bacula_logline","text":"Pattern : %{BACULA_TIMESTAMP:bts} %{BACULA_HOST:hostname} JobId %{INT:jobid}: (%{BACULA_LOG_MAX_CAPACITY}|%{BACULA_LOG_END_VOLUME}|%{BACULA_LOG_NEW_VOLUME}|%{BACULA_LOG_NEW_LABEL}|%{BACULA_LOG_WROTE_LABEL}|%{BACULA_LOG_NEW_MOUNT}|%{BACULA_LOG_NOOPEN}|%{BACULA_LOG_NOOPENDIR}|%{BACULA_LOG_NOSTAT}|%{BACULA_LOG_NOJOBS}|%{BACULA_LOG_ALL_RECORDS_PRUNED}|%{BACULA_LOG_BEGIN_PRUNE_JOBS}|%{BACULA_LOG_BEGIN_PRUNE_FILES}|%{BACULA_LOG_PRUNED_JOBS}|%{BACULA_LOG_PRUNED_FILES}|%{BACULA_LOG_ENDPRUNE}|%{BACULA_LOG_STARTJOB}|%{BACULA_LOG_STARTRESTORE}|%{BACULA_LOG_USEDEVICE}|%{BACULA_LOG_DIFF_FS}|%{BACULA_LOG_JOBEND}|%{BACULA_LOG_NOPRUNE_JOBS}|%{BACULA_LOG_NOPRUNE_FILES}|%{BACULA_LOG_VOLUME_PREVWRITTEN}|%{BACULA_LOG_READYAPPEND}|%{BACULA_LOG_CANCELLING}|%{BACULA_LOG_MARKCANCEL}|%{BACULA_LOG_CLIENT_RBJ}|%{BACULA_LOG_VSS}|%{BACULA_LOG_MAXSTART}|%{BACULA_LOG_DUPLICATE}|%{BACULA_LOG_NOJOBSTAT}|%{BACULA_LOG_FATAL_CONN}|%{BACULA_LOG_NO_CONNECT}|%{BACULA_LOG_NO_AUTH}|%{BACULA_LOG_NOSUIT}|%{BACULA_LOG_JOB}|%{BACULA_LOG_NOPRIOR})","title":"BACULA_LOGLINE"},{"location":"references/patterns-documentation.html#nagioslogline","text":"Pattern : %{NAGIOSTIME} (?:%{NAGIOS_WARNING}|%{NAGIOS_CURRENT_SERVICE_STATE}|%{NAGIOS_CURRENT_HOST_STATE}|%{NAGIOS_SERVICE_NOTIFICATION}|%{NAGIOS_HOST_NOTIFICATION}|%{NAGIOS_SERVICE_ALERT}|%{NAGIOS_HOST_ALERT}|%{NAGIOS_SERVICE_FLAPPING_ALERT}|%{NAGIOS_HOST_FLAPPING_ALERT}|%{NAGIOS_SERVICE_DOWNTIME_ALERT}|%{NAGIOS_HOST_DOWNTIME_ALERT}|%{NAGIOS_PASSIVE_SERVICE_CHECK}|%{NAGIOS_PASSIVE_HOST_CHECK}|%{NAGIOS_SERVICE_EVENT_HANDLER}|%{NAGIOS_HOST_EVENT_HANDLER}|%{NAGIOS_TIMEPERIOD_TRANSITION}|%{NAGIOS_EC_LINE_DISABLE_SVC_CHECK}|%{NAGIOS_EC_LINE_ENABLE_SVC_CHECK}|%{NAGIOS_EC_LINE_DISABLE_HOST_CHECK}|%{NAGIOS_EC_LINE_ENABLE_HOST_CHECK}|%{NAGIOS_EC_LINE_PROCESS_HOST_CHECK_RESULT}|%{NAGIOS_EC_LINE_PROCESS_SERVICE_CHECK_RESULT}|%{NAGIOS_EC_LINE_SCHEDULE_HOST_DOWNTIME}|%{NAGIOS_EC_LINE_DISABLE_HOST_SVC_NOTIFICATIONS}|%{NAGIOS_EC_LINE_ENABLE_HOST_SVC_NOTIFICATIONS}|%{NAGIOS_EC_LINE_DISABLE_HOST_NOTIFICATIONS}|%{NAGIOS_EC_LINE_ENABLE_HOST_NOTIFICATIONS}|%{NAGIOS_EC_LINE_DISABLE_SVC_NOTIFICATIONS}|%{NAGIOS_EC_LINE_ENABLE_SVC_NOTIFICATIONS})","title":"NAGIOSLOGLINE"},{"location":"references/patterns-documentation.html#ipv6","text":"Pattern : ((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?","title":"IPV6"},{"location":"references/patterns-documentation.html#documentation-generation","text":"This documentation is generated by pkg/parser : GO_WANT_TEST_DOC=1 go test -run TestGeneratePatternsDoc","title":"Documentation generation"},{"location":"references/postoverflows.html","text":"Post Overflows \u00b6 PostOverflows is secondary parsing phase that happens after a bucket overflowed. It behaves exactly like a Normal Parsing . However, instead of receiving event with logs, the parser receive events with alert representing the overflows. The configuration resides in /etc/crowdsec/postoverflows/ .","title":"PostOverlows format"},{"location":"references/postoverflows.html#post-overflows","text":"PostOverflows is secondary parsing phase that happens after a bucket overflowed. It behaves exactly like a Normal Parsing . However, instead of receiving event with logs, the parser receive events with alert representing the overflows. The configuration resides in /etc/crowdsec/postoverflows/ .","title":"Post Overflows"},{"location":"references/profiles.html","text":"Profiles configurations \u00b6 The profiles configuration ( /etc/crowdsec/profiles.yaml ) allow to configure what kind of remediation needs to be applied when a scenario is triggered : The configuration file is a yaml file that looks like : name : default_ip_remediation #debug: true filters : - Alert.Remediation == true && Alert.GetScope() == \"Ip\" decisions : - type : ban duration : 4h on_success : break Each YAML object in the file contains a list of models.Decision that contains : name \u00b6 name : foobar A label for the profile (used in logging) debug \u00b6 debug : true A boolean flag that provides contextual debug. filters \u00b6 filters : - Alert.Remediation == true && Alert.GetScope() == \"Session\" - Alert.Remediation == true && Alert.GetScope() == \"Ip\" If any filter of the list returns true , the profile is elligible and the decisions will be applied. decisions \u00b6 decisions : - type : captcha duration : 1h scope : custom_app1_captcha - type : ban duration : 2h If the profile applies, decisions objects will be created for each of the sources that triggered the scenario. It is a list of models.Decision objects. The following fields, when present, allows to alter the resulting decision : scope : defines the scope of the resulting decision duration : defines for how long will the decision be valid type : defines the type of the remediation that will be applied by available bouncers , for example ban , captcha value : define a hardcoded value for the decision (ie. 1.2.3.4 ) on_success \u00b6 on_success : break If the profile applies and on_success is set to break , decisions processing will stop here and it won't evaluate against following profiles. on_failure \u00b6 on_failure : break If the profile didn't apply and on_failure is set to break , decisions processing will stop here and it won't evaluate against following profiles.","title":"Profiles format"},{"location":"references/profiles.html#profiles-configurations","text":"The profiles configuration ( /etc/crowdsec/profiles.yaml ) allow to configure what kind of remediation needs to be applied when a scenario is triggered : The configuration file is a yaml file that looks like : name : default_ip_remediation #debug: true filters : - Alert.Remediation == true && Alert.GetScope() == \"Ip\" decisions : - type : ban duration : 4h on_success : break Each YAML object in the file contains a list of models.Decision that contains :","title":"Profiles configurations"},{"location":"references/profiles.html#name","text":"name : foobar A label for the profile (used in logging)","title":"name"},{"location":"references/profiles.html#debug","text":"debug : true A boolean flag that provides contextual debug.","title":"debug"},{"location":"references/profiles.html#filters","text":"filters : - Alert.Remediation == true && Alert.GetScope() == \"Session\" - Alert.Remediation == true && Alert.GetScope() == \"Ip\" If any filter of the list returns true , the profile is elligible and the decisions will be applied.","title":"filters"},{"location":"references/profiles.html#decisions","text":"decisions : - type : captcha duration : 1h scope : custom_app1_captcha - type : ban duration : 2h If the profile applies, decisions objects will be created for each of the sources that triggered the scenario. It is a list of models.Decision objects. The following fields, when present, allows to alter the resulting decision : scope : defines the scope of the resulting decision duration : defines for how long will the decision be valid type : defines the type of the remediation that will be applied by available bouncers , for example ban , captcha value : define a hardcoded value for the decision (ie. 1.2.3.4 )","title":"decisions"},{"location":"references/profiles.html#on_success","text":"on_success : break If the profile applies and on_success is set to break , decisions processing will stop here and it won't evaluate against following profiles.","title":"on_success"},{"location":"references/profiles.html#on_failure","text":"on_failure : break If the profile didn't apply and on_failure is set to break , decisions processing will stop here and it won't evaluate against following profiles.","title":"on_failure"},{"location":"references/scenarios.html","text":"Understanding scenarios \u00b6 Scenarios are YAML files that allow to detect and qualify a specific behavior, usually an attack. Scenarios receive event (s) and can produce alert (s) using the leaky bucket algorithm. As an event can be the representation of a log line, or an overflow, it allows scenarios to process both logs or overflows to allow inference. Scenarios can be of different types (leaky, trigger, counter), and are based on various factors, such as : the speed/frequency of the leaky bucket the capacity of the leaky bucket the characteristic(s) of eligible event (s) : \"log type XX with field YY set to ZZ\" various filters/directives that can alter the bucket's behavior, such as groupby , distinct or blackhole Behind the scenes, crowdsec-agent is going to create one or more buckets when events with matching characteristics arrive to the scenario. When any of these buckets overflows, the scenario has been triggered. Bucket partitioning : One scenario usually leads to many buckets creation, as each bucket is only tracking a specific subset of events. For example, if we are tracking brute-force, each \"offending peer\" get its own bucket. A way to detect a http scanner might be to track the number of distinct non-existing pages it's requesting, and the scenario might look like this : #the bucket type : leaky, trigger, counter type : leaky #name and description for humans name : crowdsecurity/http-scan-uniques_404 description : \"Detect multiple unique 404 from a single ip\" #a filter to know which events are eligible filter : \"evt.Meta.service == 'http' && evt.Meta.http_status in ['404', '403', '400']\" #how we are going to partition buckets groupby : \"evt.Meta.source_ip\" #we are only interested into counting UNIQUE/DISTINCT requested URLs distinct : \"evt.Meta.http_path\" #we specify the bucket capacity and leak speed capacity : 5 leakspeed : \"10s\" #this will prevent the same bucket from overflowing more often than every 5 minutes blackhole : 5m #some labels to give context to the overflow labels : service : http type : scan #yes we want to ban people triggering this remediation : true Scenario concepts \u00b6 TimeMachine \u00b6 crowdsec-agent can be used not only to process live logs, but as well to process \"cold\" logs (think forensics). For this to be able to work, the date/time from the log must have been properly parsed for the scenario temporal aspect to be able to work properly. This relies on the date-parse enrichment . For this to work the field evt.StrTime must have been filled with a string that represents the date & time. the date-parse enrichment support a large variety of formats. Scenario directives \u00b6 type \u00b6 type : leaky|trigger|counter Defines the type of the bucket. Currently three types are supported : leaky : a leaky bucket that must be configured with a capacity and a leakspeed trigger : a bucket that overflows as soon as an event is poured (it's like a leaky bucket is a capacity of 0) counter : a bucket that only overflows every duration . It's especially useful to count things. name & description \u00b6 name : my_author_name/my_scenario_name description : A scenario that detect XXXX behavior Mandatory name and description for said scenario. The name must be unique (and will define the scenario's name in the hub), and the description must be a quick sentence describing what it detects. filter \u00b6 filter : expression filter must be a valid expr expression that will be evaluated against the event . If filter evaluation returns true or is absent, event will be pour in the bucket. If filter returns false or a non-boolean, the event will be skip for this bucket. Here is the expr documentation . Examples : evt.Meta.log_type == 'telnet_new_session' evt.Meta.log_type in ['http_access-log', 'http_error-log'] && evt.Parsed.static_ressource == 'false' evt.Meta.log_type == 'ssh_failed-auth' duration \u00b6 duration : 45s duration : 10m (applicable to counter buckets only) A duration after which the bucket will overflow. The format must be compatible with golang ParseDuration format Examples : type : counter name : crowdsecurity/ban-reports-ssh_bf_report description : \"Count unique ips performing ssh bruteforce\" filter : \"evt.Overflow.Scenario == 'ssh_bruteforce'\" distinct : \"evt.Overflow.Source_ip\" capacity : -1 duration : 10m labels : service : ssh groupby \u00b6 groupby : evt.Meta.source_ip an expr that must return a string. This string will be used as to partition the buckets. Examples : Here, each source_ip will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip ... Here, each unique combo of source_ip + target_username will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip + '--' + evt.Parsed.target_username ... distinct \u00b6 distinct : evt.Meta.http_path an expr that must return a string. The event will be poured only if the string is not already present in the bucket. Examples : This will ensure that events that keep triggering the same .Meta.http_path will be poured only once. type : leaky ... distinct : \"evt.Meta.http_path\" ... In the logs, you can see it like this (for example from the iptables-logs portscan detection) : DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ok buck.. DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ko, discard event buck.. The first event has been poured (value 7681 ) was not yet present in the events, while the second time, the event got discarded because the value was already present in the bucket. capacity \u00b6 capacity : 5 (Applies only to leaky buckets) A positive integer representing the bucket capacity. If there are more than capacity item in the bucket, it will overflow. cache_size \u00b6 cache_size : 10 A positive integer representing the number of events we hold in the bucket. All events are still accounted for the bucket, it only prevents the bucket event history to grow larger than cache_size . When the bucket reachs cache_size events, then events are discarded on an first-in first-out basis. leakspeed \u00b6 leakspeed : \"10s\" (Applies only to leaky buckets) A duration that represent how often an event will be leaking from the bucket. Must be compatible with golang ParseDuration format . Example: Here the bucket will leak one item every 10 seconds, and can hold up to 5 items before overflowing. type : leaky ... leakspeed : \"10s\" capacity : 5 ... labels \u00b6 labels : service : ssh type : bruteforce remediation : true Labels is a list of label: values that provide context to an overflow. The labels are (currently) not stored in the database, nor they are sent to the API. Special labels : The remediation label, if set to true indicate the the originating IP should be ban. The scope label, can be set to ip or range when remediation is set to true, and indicate to which scope should the decision apply. If you set a scenario with remediation to true and scope to range and the range of the IP could have been determined by the GeoIP library, the whole range to which the IP belongs will be banned. Example : The IP that triggered the overflow ( .Meta.source_ip ) will be banned. type : leaky ... labels : service : ssh type : bruteforce remediation : true The range to which the offending IP belong ( .Meta.source_ip ) will be banned. type : leaky ... labels : type : distributed_attack remediation : true scope : range blackhole \u00b6 blackhole : 10m A duration for which a bucket will be \"silenced\" after overflowing. This is intended to limit / avoid spam of buckets that might be very rapidly triggered. The blackhole only applies to the individual bucket rather than the whole scenario. Must be compatible with golang ParseDuration format . Example : The same source_ip won't be able to trigger this overflow more than once every 10 minutes. The potential overflows in the meanwhile will be discarded (but will still appear in logs as being blackholed). type : trigger ... blackhole : 10m groupby : evt.Meta.source_ip debug \u00b6 debug : true|false default: false If set to to true , enabled scenario level debugging. It is meant to help understanding scenario behavior by providing contextual logging : debug of filters and expression results DEBU[31-07-2020 16:34:58] eval(evt.Meta.log_type in [\"http_access-log\", \"http_error-log\"] && any(File(\"bad_user_agents.txt\"), {evt.Parsed.http_user_agent contains #})) = TRUE cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] eval variables: cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Meta.log_type = 'http_access-log' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Parsed.http_user_agent = 'Mozilla/5.00 (Nikto/2.1.5) (Evasions:None) (Test:002810)' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent reprocess \u00b6 reprocess : true|false default: false If set to true , the resulting overflow will be sent again in the scenario/parsing pipeline. It is useful when you want to have further scenarios that will rely on past-overflows to take decisions. cache_size \u00b6 cache_size : 5 By default, a bucket holds capacity events \"in memory\". However, for a number of cases, you don't want this, as it might lead to excessive memory consumption. By setting cache_size to a positive integer, we can control the maximum in-memory cache size of the bucket, without changing its capacity and such. This is especially useful when using counter buckets on long duration that might end up counting (and this storing in memory) an important number of events. overflow_filter \u00b6 overflow_filter : any(queue.Queue, { .Enriched.IsInEU == \"true\" }) overflow_filter is an expr that is run when the bucket overflows. If this expression is present and returns false, the overflow will be discarded. data \u00b6 data : - source_url : https://URL/TO/FILE dest_file : LOCAL_FILENAME [ type : (regexp|string) ] data allows user to specify an external source of data. This section is only relevant when cscli is used to install scenario from hub, as ill download the source_url and store it to dest_file . When the scenario is not installed from the hub, crowdsec-agent won't download the URL, but the file must exist for the scenario to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string format \u00b6 format : 2.0 crowdsec-agent has a notion of format support for parsers & scenarios for compatibility management. Running cscli version will show you such compatibility matrix : $ sudo cscli version 2020 /11/05 09 :35:05 version: v0.3.6-183e34c966c475e0d2cdb3c60d0b7426499aa573 2020 /11/05 09 :35:05 Codename: beta 2020 /11/05 09 :35:05 BuildDate: 2020 -11-04_17:56:46 2020 /11/05 09 :35:05 GoVersion: 1 .13 2020 /11/05 09 :35:05 Constraint_parser: > = 1 .0, < 2 .0 2020 /11/05 09 :35:05 Constraint_scenario: > = 1 .0, < 3 .0 2020 /11/05 09 :35:05 Constraint_api: v1 2020 /11/05 09 :35:05 Constraint_acquis: > = 1 .0, < 2 .0 Scope \u00b6 scope : type : Range expression : evt.Parsed.mySourceRange While most scenarios might focus on Ips, crowdsec-agent and bouncers can work with any scope. The scope directive allows you to override the default scope : type is a string representing the scope name expression is an expr expression that will be evaluated to fetch the value let's imagine a scenario such as : # ssh bruteforce type : leaky name : crowdsecurity/ssh-enforce-mfa description : \"Enforce mfa on users that have been bruteforced\" filter : \"evt.Meta.log_type == 'ssh_failed-auth'\" leakspeed : \"10s\" capacity : 5 groupby : evt.Meta.source_ip blackhole : 1m labels : service : ssh type : bruteforce remediation : true scope : type : username expression : evt.Meta.target_user and a profile such as : name : enforce_mfa filters : - 'Alert.Remediation == true && Alert.GetScope() == \"username\"' decisions : - type : enforce_mfa scope : \"username\" duration : 1h on_success : continue the resulting overflow will be : $ ./cscli -c dev.yaml decisions list +----+----------+---------------+-------------------------------+-------------+---------+----+--------+------------------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +----+----------+---------------+-------------------------------+-------------+---------+----+--------+------------------+ | 2 | crowdsec | username:rura | crowdsecurity/ssh-enforce-mfa | enforce_mfa | | | 6 | 59m46.121840343s |","title":"Scenarios format"},{"location":"references/scenarios.html#understanding-scenarios","text":"Scenarios are YAML files that allow to detect and qualify a specific behavior, usually an attack. Scenarios receive event (s) and can produce alert (s) using the leaky bucket algorithm. As an event can be the representation of a log line, or an overflow, it allows scenarios to process both logs or overflows to allow inference. Scenarios can be of different types (leaky, trigger, counter), and are based on various factors, such as : the speed/frequency of the leaky bucket the capacity of the leaky bucket the characteristic(s) of eligible event (s) : \"log type XX with field YY set to ZZ\" various filters/directives that can alter the bucket's behavior, such as groupby , distinct or blackhole Behind the scenes, crowdsec-agent is going to create one or more buckets when events with matching characteristics arrive to the scenario. When any of these buckets overflows, the scenario has been triggered. Bucket partitioning : One scenario usually leads to many buckets creation, as each bucket is only tracking a specific subset of events. For example, if we are tracking brute-force, each \"offending peer\" get its own bucket. A way to detect a http scanner might be to track the number of distinct non-existing pages it's requesting, and the scenario might look like this : #the bucket type : leaky, trigger, counter type : leaky #name and description for humans name : crowdsecurity/http-scan-uniques_404 description : \"Detect multiple unique 404 from a single ip\" #a filter to know which events are eligible filter : \"evt.Meta.service == 'http' && evt.Meta.http_status in ['404', '403', '400']\" #how we are going to partition buckets groupby : \"evt.Meta.source_ip\" #we are only interested into counting UNIQUE/DISTINCT requested URLs distinct : \"evt.Meta.http_path\" #we specify the bucket capacity and leak speed capacity : 5 leakspeed : \"10s\" #this will prevent the same bucket from overflowing more often than every 5 minutes blackhole : 5m #some labels to give context to the overflow labels : service : http type : scan #yes we want to ban people triggering this remediation : true","title":"Understanding scenarios"},{"location":"references/scenarios.html#scenario-concepts","text":"","title":"Scenario concepts"},{"location":"references/scenarios.html#timemachine","text":"crowdsec-agent can be used not only to process live logs, but as well to process \"cold\" logs (think forensics). For this to be able to work, the date/time from the log must have been properly parsed for the scenario temporal aspect to be able to work properly. This relies on the date-parse enrichment . For this to work the field evt.StrTime must have been filled with a string that represents the date & time. the date-parse enrichment support a large variety of formats.","title":"TimeMachine"},{"location":"references/scenarios.html#scenario-directives","text":"","title":"Scenario directives"},{"location":"references/scenarios.html#type","text":"type : leaky|trigger|counter Defines the type of the bucket. Currently three types are supported : leaky : a leaky bucket that must be configured with a capacity and a leakspeed trigger : a bucket that overflows as soon as an event is poured (it's like a leaky bucket is a capacity of 0) counter : a bucket that only overflows every duration . It's especially useful to count things.","title":"type"},{"location":"references/scenarios.html#name-description","text":"name : my_author_name/my_scenario_name description : A scenario that detect XXXX behavior Mandatory name and description for said scenario. The name must be unique (and will define the scenario's name in the hub), and the description must be a quick sentence describing what it detects.","title":"name &amp; description"},{"location":"references/scenarios.html#filter","text":"filter : expression filter must be a valid expr expression that will be evaluated against the event . If filter evaluation returns true or is absent, event will be pour in the bucket. If filter returns false or a non-boolean, the event will be skip for this bucket. Here is the expr documentation . Examples : evt.Meta.log_type == 'telnet_new_session' evt.Meta.log_type in ['http_access-log', 'http_error-log'] && evt.Parsed.static_ressource == 'false' evt.Meta.log_type == 'ssh_failed-auth'","title":"filter"},{"location":"references/scenarios.html#duration","text":"duration : 45s duration : 10m (applicable to counter buckets only) A duration after which the bucket will overflow. The format must be compatible with golang ParseDuration format Examples : type : counter name : crowdsecurity/ban-reports-ssh_bf_report description : \"Count unique ips performing ssh bruteforce\" filter : \"evt.Overflow.Scenario == 'ssh_bruteforce'\" distinct : \"evt.Overflow.Source_ip\" capacity : -1 duration : 10m labels : service : ssh","title":"duration"},{"location":"references/scenarios.html#groupby","text":"groupby : evt.Meta.source_ip an expr that must return a string. This string will be used as to partition the buckets. Examples : Here, each source_ip will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip ... Here, each unique combo of source_ip + target_username will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip + '--' + evt.Parsed.target_username ...","title":"groupby"},{"location":"references/scenarios.html#distinct","text":"distinct : evt.Meta.http_path an expr that must return a string. The event will be poured only if the string is not already present in the bucket. Examples : This will ensure that events that keep triggering the same .Meta.http_path will be poured only once. type : leaky ... distinct : \"evt.Meta.http_path\" ... In the logs, you can see it like this (for example from the iptables-logs portscan detection) : DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ok buck.. DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ko, discard event buck.. The first event has been poured (value 7681 ) was not yet present in the events, while the second time, the event got discarded because the value was already present in the bucket.","title":"distinct"},{"location":"references/scenarios.html#capacity","text":"capacity : 5 (Applies only to leaky buckets) A positive integer representing the bucket capacity. If there are more than capacity item in the bucket, it will overflow.","title":"capacity"},{"location":"references/scenarios.html#cache_size","text":"cache_size : 10 A positive integer representing the number of events we hold in the bucket. All events are still accounted for the bucket, it only prevents the bucket event history to grow larger than cache_size . When the bucket reachs cache_size events, then events are discarded on an first-in first-out basis.","title":"cache_size"},{"location":"references/scenarios.html#leakspeed","text":"leakspeed : \"10s\" (Applies only to leaky buckets) A duration that represent how often an event will be leaking from the bucket. Must be compatible with golang ParseDuration format . Example: Here the bucket will leak one item every 10 seconds, and can hold up to 5 items before overflowing. type : leaky ... leakspeed : \"10s\" capacity : 5 ...","title":"leakspeed"},{"location":"references/scenarios.html#labels","text":"labels : service : ssh type : bruteforce remediation : true Labels is a list of label: values that provide context to an overflow. The labels are (currently) not stored in the database, nor they are sent to the API. Special labels : The remediation label, if set to true indicate the the originating IP should be ban. The scope label, can be set to ip or range when remediation is set to true, and indicate to which scope should the decision apply. If you set a scenario with remediation to true and scope to range and the range of the IP could have been determined by the GeoIP library, the whole range to which the IP belongs will be banned. Example : The IP that triggered the overflow ( .Meta.source_ip ) will be banned. type : leaky ... labels : service : ssh type : bruteforce remediation : true The range to which the offending IP belong ( .Meta.source_ip ) will be banned. type : leaky ... labels : type : distributed_attack remediation : true scope : range","title":"labels"},{"location":"references/scenarios.html#blackhole","text":"blackhole : 10m A duration for which a bucket will be \"silenced\" after overflowing. This is intended to limit / avoid spam of buckets that might be very rapidly triggered. The blackhole only applies to the individual bucket rather than the whole scenario. Must be compatible with golang ParseDuration format . Example : The same source_ip won't be able to trigger this overflow more than once every 10 minutes. The potential overflows in the meanwhile will be discarded (but will still appear in logs as being blackholed). type : trigger ... blackhole : 10m groupby : evt.Meta.source_ip","title":"blackhole"},{"location":"references/scenarios.html#debug","text":"debug : true|false default: false If set to to true , enabled scenario level debugging. It is meant to help understanding scenario behavior by providing contextual logging : debug of filters and expression results DEBU[31-07-2020 16:34:58] eval(evt.Meta.log_type in [\"http_access-log\", \"http_error-log\"] && any(File(\"bad_user_agents.txt\"), {evt.Parsed.http_user_agent contains #})) = TRUE cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] eval variables: cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Meta.log_type = 'http_access-log' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Parsed.http_user_agent = 'Mozilla/5.00 (Nikto/2.1.5) (Evasions:None) (Test:002810)' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent","title":"debug"},{"location":"references/scenarios.html#reprocess","text":"reprocess : true|false default: false If set to true , the resulting overflow will be sent again in the scenario/parsing pipeline. It is useful when you want to have further scenarios that will rely on past-overflows to take decisions.","title":"reprocess"},{"location":"references/scenarios.html#cache_size_1","text":"cache_size : 5 By default, a bucket holds capacity events \"in memory\". However, for a number of cases, you don't want this, as it might lead to excessive memory consumption. By setting cache_size to a positive integer, we can control the maximum in-memory cache size of the bucket, without changing its capacity and such. This is especially useful when using counter buckets on long duration that might end up counting (and this storing in memory) an important number of events.","title":"cache_size"},{"location":"references/scenarios.html#overflow_filter","text":"overflow_filter : any(queue.Queue, { .Enriched.IsInEU == \"true\" }) overflow_filter is an expr that is run when the bucket overflows. If this expression is present and returns false, the overflow will be discarded.","title":"overflow_filter"},{"location":"references/scenarios.html#data","text":"data : - source_url : https://URL/TO/FILE dest_file : LOCAL_FILENAME [ type : (regexp|string) ] data allows user to specify an external source of data. This section is only relevant when cscli is used to install scenario from hub, as ill download the source_url and store it to dest_file . When the scenario is not installed from the hub, crowdsec-agent won't download the URL, but the file must exist for the scenario to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string","title":"data"},{"location":"references/scenarios.html#format","text":"format : 2.0 crowdsec-agent has a notion of format support for parsers & scenarios for compatibility management. Running cscli version will show you such compatibility matrix : $ sudo cscli version 2020 /11/05 09 :35:05 version: v0.3.6-183e34c966c475e0d2cdb3c60d0b7426499aa573 2020 /11/05 09 :35:05 Codename: beta 2020 /11/05 09 :35:05 BuildDate: 2020 -11-04_17:56:46 2020 /11/05 09 :35:05 GoVersion: 1 .13 2020 /11/05 09 :35:05 Constraint_parser: > = 1 .0, < 2 .0 2020 /11/05 09 :35:05 Constraint_scenario: > = 1 .0, < 3 .0 2020 /11/05 09 :35:05 Constraint_api: v1 2020 /11/05 09 :35:05 Constraint_acquis: > = 1 .0, < 2 .0","title":"format"},{"location":"references/scenarios.html#scope","text":"scope : type : Range expression : evt.Parsed.mySourceRange While most scenarios might focus on Ips, crowdsec-agent and bouncers can work with any scope. The scope directive allows you to override the default scope : type is a string representing the scope name expression is an expr expression that will be evaluated to fetch the value let's imagine a scenario such as : # ssh bruteforce type : leaky name : crowdsecurity/ssh-enforce-mfa description : \"Enforce mfa on users that have been bruteforced\" filter : \"evt.Meta.log_type == 'ssh_failed-auth'\" leakspeed : \"10s\" capacity : 5 groupby : evt.Meta.source_ip blackhole : 1m labels : service : ssh type : bruteforce remediation : true scope : type : username expression : evt.Meta.target_user and a profile such as : name : enforce_mfa filters : - 'Alert.Remediation == true && Alert.GetScope() == \"username\"' decisions : - type : enforce_mfa scope : \"username\" duration : 1h on_success : continue the resulting overflow will be : $ ./cscli -c dev.yaml decisions list +----+----------+---------------+-------------------------------+-------------+---------+----+--------+------------------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +----+----------+---------------+-------------------------------+-------------+---------+----+--------+------------------+ | 2 | crowdsec | username:rura | crowdsecurity/ssh-enforce-mfa | enforce_mfa | | | 6 | 59m46.121840343s |","title":"Scope"},{"location":"references/simulation.html","text":"Simulation \u00b6 Simulation config is in /etc/crowdsec/simulation.yaml and looks like : #if simulation is set to 'true' here, *all* scenarios will be in simulation unless in exclusion list simulation : false #exclusion to the policy - here, the scenarios that are in simulation mode exclusions : - crowdsecurity/ssh-bf","title":"Simulation configuration"},{"location":"references/simulation.html#simulation","text":"Simulation config is in /etc/crowdsec/simulation.yaml and looks like : #if simulation is set to 'true' here, *all* scenarios will be in simulation unless in exclusion list simulation : false #exclusion to the policy - here, the scenarios that are in simulation mode exclusions : - crowdsecurity/ssh-bf","title":"Simulation"},{"location":"references/stages.html","text":"Stages \u00b6 Parsers are organized into \"stages\" (named using a \"sXX- \" convention) to allow pipelines and branching in parsing. Each parser belongs to a stage, and can trigger next stage when successful. At the time of writing, the parsers are organized around 3 stages : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) The number and structure of stages can be altered by the user, the directory structure and their alphabetical order dictates in which order stages and parsers are processed. Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Default stages \u00b6 The preliminary stage ( s00-raw ) is mostly the one that will parse the structure of the log. This is where syslog-logs are parsed for example. Such a parser will parse the syslog header to detect the program source. The main stage ( s01-parse ) is the one that will parse actual applications logs and output parsed data and static assigned values. There is one parser for each type of software. To parse the logs, regexp or GROK pattern are used. If the parser is configured to go to the next_stage , then it will be process by the enrichment stage. The enrichment ( s02-enrich ) stage is the one that will enrich the normalized log (we call it an event now that it is normalized) in order to get more information for the heuristic process. This stage can be composed of grok patterns and so on, but as well of plugins that can be writen by the community (geiop enrichment, rdns ...) for example geoip-enrich . Custom stage \u00b6 It is possible to write custom stage. If you want some specific parsing or enrichment to be done after the s02-enrich stage, it is possible by creating a new folder s03-<custom_stage> (and so on). The configuration that will be created in this folder will process the logs configured to go to next_stage in the s02-enrich stage.","title":"Stages format"},{"location":"references/stages.html#stages","text":"Parsers are organized into \"stages\" (named using a \"sXX- \" convention) to allow pipelines and branching in parsing. Each parser belongs to a stage, and can trigger next stage when successful. At the time of writing, the parsers are organized around 3 stages : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) The number and structure of stages can be altered by the user, the directory structure and their alphabetical order dictates in which order stages and parsers are processed. Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios.","title":"Stages"},{"location":"references/stages.html#default-stages","text":"The preliminary stage ( s00-raw ) is mostly the one that will parse the structure of the log. This is where syslog-logs are parsed for example. Such a parser will parse the syslog header to detect the program source. The main stage ( s01-parse ) is the one that will parse actual applications logs and output parsed data and static assigned values. There is one parser for each type of software. To parse the logs, regexp or GROK pattern are used. If the parser is configured to go to the next_stage , then it will be process by the enrichment stage. The enrichment ( s02-enrich ) stage is the one that will enrich the normalized log (we call it an event now that it is normalized) in order to get more information for the heuristic process. This stage can be composed of grok patterns and so on, but as well of plugins that can be writen by the community (geiop enrichment, rdns ...) for example geoip-enrich .","title":"Default stages"},{"location":"references/stages.html#custom-stage","text":"It is possible to write custom stage. If you want some specific parsing or enrichment to be done after the s02-enrich stage, it is possible by creating a new folder s03-<custom_stage> (and so on). The configuration that will be created in this folder will process the logs configured to go to next_stage in the s02-enrich stage.","title":"Custom stage"},{"location":"user_guide/bouncer_machine_management.html","text":"Bouncers & Machines management \u00b6 Crowdsec is composed of different components that communicate via a local API. To access this API, the various components (crowdsec agent, cscli and bouncers) need to be authenticated. Info This documentation should be relevant mostly for administrators that would like to setup distributed architectures. Single machine setup users can likely skip this part. There are two kind of access to the local api : machines : it's a login/password authentication used by cscli and crowdsec-agent, this one allows to post, get and delete decisions and alerts. bouncers : it's a token authentication used by bouncers to query the decisions, and only allows to perform get on decisions and alerts. Bouncers authentication \u00b6 Warning The cscli bouncers command interacts directly with the database (bouncers add and delete are not implemented in the API), and thus it must have the correct database configuration. $ sudo cscli bouncers list You can view the registered bouncers with list , as well as add or delete them : $ sudo cscli bouncers add mybouncersname Api key for 'mybouncersname' : 23 ........b5a0c Please keep this key since will not be able to retrive it! $ sudo cscli bouncers delete mybouncersname The API KEY must be kept and given to the bouncers . cscli bouncers example $ sudo cscli bouncers add mybouncersname Api key for 'mybouncersname' : 23 ........b5a0c Please keep this key since will not be able to retrive it! $ sudo cscli bouncers list ----------------------------------------------------------------------------- NAME IP ADDRESS VALID LAST API PULL TYPE VERSION ----------------------------------------------------------------------------- mybouncersname \u2714\ufe0f 2020 -11-01T11:45:05+01:00 ----------------------------------------------------------------------------- $ sudo cscli bouncers add jlkqweq Api key for 'jlkqweq' : a7........efdc9c Please keep this key since will not be able to retrive it! $ sudo cscli bouncers delete mybouncersname $ sudo cscli bouncers list ---------------------------------------------------------------------- NAME IP ADDRESS VALID LAST API PULL TYPE VERSION ---------------------------------------------------------------------- jlkqweq \u2714\ufe0f 2020 -11-01T11:49:32+01:00 ---------------------------------------------------------------------- Machines authentication \u00b6 Warning The cscli machines command interacts directly with the database (machines add and delete are not implemented in the API), and thus it must have the correct database configuration. $ cscli machines list You can view the registered machines with list , as well as add or delete them : $ sudo cscli machines add mytestmachine -a INFO [ 0004 ] Machine 'mytestmachine' created successfully INFO [ 0004 ] API credentials dumped to '/etc/crowdsec/local_api_credentials.yaml' $ sudo cscli machines delete 82929df7ee394b73b81252fe3b4e5020 cscli machines example $ sudo cscli machines list ---------------------------------------------------------------------------------------------------------------------------------- NAME IP ADDRESS LAST UPDATE STATUS VERSION ---------------------------------------------------------------------------------------------------------------------------------- 82929df7ee394b73b81252fe3b4e5020 127 .0.0.1 2020 -10-31T14:06:32+01:00 \u2714\ufe0f v0.3.6-3d6ce33908409f2a830af6551a7f5e37f2a4728f ---------------------------------------------------------------------------------------------------------------------------------- $ sudo cscli machines add -m mytestmachine -a INFO [ 0004 ] Machine 'mytestmachine' created successfully INFO [ 0004 ] API credentials dumped to '/etc/crowdsec/local_api_credentials.yaml' $ sudo cscli machines list ---------------------------------------------------------------------------------------------------------------------------------- NAME IP ADDRESS LAST UPDATE STATUS VERSION ---------------------------------------------------------------------------------------------------------------------------------- 82929df7ee394b73b81252fe3b4e5020 127 .0.0.1 2020 -10-31T14:06:32+01:00 \u2714\ufe0f v0.3.6-3d6ce33908409f2a830af6551a7f5e37f2a4728f mytestmachine 127 .0.0.1 2020 -11-01T11:37:19+01:00 \u2714\ufe0f v0.3.6-6a18458badf8ae5fed8d5f1bb96fc7a59c96163c ---------------------------------------------------------------------------------------------------------------------------------- $ sudo cscli machines delete -m 82929df7ee394b73b81252fe3b4e5020 $ sudo cscli machines list --------------------------------------------------------------------------------------------------------- NAME IP ADDRESS LAST UPDATE STATUS VERSION --------------------------------------------------------------------------------------------------------- mytestmachine 127 .0.0.1 2020 -11-01T11:37:19+01:00 \u2714\ufe0f v0.3.6-6a18458badf8ae5fed8d5f1bb96fc7a59c96163c ---------------------------------------------------------------------------------------------------------","title":"Bouncers & machines management"},{"location":"user_guide/bouncer_machine_management.html#bouncers-machines-management","text":"Crowdsec is composed of different components that communicate via a local API. To access this API, the various components (crowdsec agent, cscli and bouncers) need to be authenticated. Info This documentation should be relevant mostly for administrators that would like to setup distributed architectures. Single machine setup users can likely skip this part. There are two kind of access to the local api : machines : it's a login/password authentication used by cscli and crowdsec-agent, this one allows to post, get and delete decisions and alerts. bouncers : it's a token authentication used by bouncers to query the decisions, and only allows to perform get on decisions and alerts.","title":"Bouncers &amp; Machines management"},{"location":"user_guide/bouncer_machine_management.html#bouncers-authentication","text":"Warning The cscli bouncers command interacts directly with the database (bouncers add and delete are not implemented in the API), and thus it must have the correct database configuration. $ sudo cscli bouncers list You can view the registered bouncers with list , as well as add or delete them : $ sudo cscli bouncers add mybouncersname Api key for 'mybouncersname' : 23 ........b5a0c Please keep this key since will not be able to retrive it! $ sudo cscli bouncers delete mybouncersname The API KEY must be kept and given to the bouncers . cscli bouncers example $ sudo cscli bouncers add mybouncersname Api key for 'mybouncersname' : 23 ........b5a0c Please keep this key since will not be able to retrive it! $ sudo cscli bouncers list ----------------------------------------------------------------------------- NAME IP ADDRESS VALID LAST API PULL TYPE VERSION ----------------------------------------------------------------------------- mybouncersname \u2714\ufe0f 2020 -11-01T11:45:05+01:00 ----------------------------------------------------------------------------- $ sudo cscli bouncers add jlkqweq Api key for 'jlkqweq' : a7........efdc9c Please keep this key since will not be able to retrive it! $ sudo cscli bouncers delete mybouncersname $ sudo cscli bouncers list ---------------------------------------------------------------------- NAME IP ADDRESS VALID LAST API PULL TYPE VERSION ---------------------------------------------------------------------- jlkqweq \u2714\ufe0f 2020 -11-01T11:49:32+01:00 ----------------------------------------------------------------------","title":"Bouncers authentication"},{"location":"user_guide/bouncer_machine_management.html#machines-authentication","text":"Warning The cscli machines command interacts directly with the database (machines add and delete are not implemented in the API), and thus it must have the correct database configuration. $ cscli machines list You can view the registered machines with list , as well as add or delete them : $ sudo cscli machines add mytestmachine -a INFO [ 0004 ] Machine 'mytestmachine' created successfully INFO [ 0004 ] API credentials dumped to '/etc/crowdsec/local_api_credentials.yaml' $ sudo cscli machines delete 82929df7ee394b73b81252fe3b4e5020 cscli machines example $ sudo cscli machines list ---------------------------------------------------------------------------------------------------------------------------------- NAME IP ADDRESS LAST UPDATE STATUS VERSION ---------------------------------------------------------------------------------------------------------------------------------- 82929df7ee394b73b81252fe3b4e5020 127 .0.0.1 2020 -10-31T14:06:32+01:00 \u2714\ufe0f v0.3.6-3d6ce33908409f2a830af6551a7f5e37f2a4728f ---------------------------------------------------------------------------------------------------------------------------------- $ sudo cscli machines add -m mytestmachine -a INFO [ 0004 ] Machine 'mytestmachine' created successfully INFO [ 0004 ] API credentials dumped to '/etc/crowdsec/local_api_credentials.yaml' $ sudo cscli machines list ---------------------------------------------------------------------------------------------------------------------------------- NAME IP ADDRESS LAST UPDATE STATUS VERSION ---------------------------------------------------------------------------------------------------------------------------------- 82929df7ee394b73b81252fe3b4e5020 127 .0.0.1 2020 -10-31T14:06:32+01:00 \u2714\ufe0f v0.3.6-3d6ce33908409f2a830af6551a7f5e37f2a4728f mytestmachine 127 .0.0.1 2020 -11-01T11:37:19+01:00 \u2714\ufe0f v0.3.6-6a18458badf8ae5fed8d5f1bb96fc7a59c96163c ---------------------------------------------------------------------------------------------------------------------------------- $ sudo cscli machines delete -m 82929df7ee394b73b81252fe3b4e5020 $ sudo cscli machines list --------------------------------------------------------------------------------------------------------- NAME IP ADDRESS LAST UPDATE STATUS VERSION --------------------------------------------------------------------------------------------------------- mytestmachine 127 .0.0.1 2020 -11-01T11:37:19+01:00 \u2714\ufe0f v0.3.6-6a18458badf8ae5fed8d5f1bb96fc7a59c96163c ---------------------------------------------------------------------------------------------------------","title":"Machines authentication"},{"location":"user_guide/cscli.html","text":"Overview \u00b6 cscli is the utility that will help you to manage crowdsec-agent. This tool has the following functionalities: manage decisions and alerts : This is how you monitor ongoing remediation and detections manage configurations such as collections , parsers , scenarios : This is how you install/update 's detection capabilities and manage whitelists interact with the hub to find new configurations or update existing ones manage local api (LAPI) bouncers and machines : This allows you to manage LAPI credentials, this is how you make and bouncers comunicate observe crowdsec via metrics or the dashboard : This is how you gain real-time observability manage simulation configurations, allowing you to disable/modify remediation triggered by specific scenarios Take a look at the dedicated documentation Tips You can enable cscli auto completion in bash or zsh . You can find cscli completion documentation here . Configuration \u00b6 cscli shares the configuration file of crowdsec-agent, usually in /etc/crowdsec/config.yaml","title":"CLI"},{"location":"user_guide/cscli.html#overview","text":"cscli is the utility that will help you to manage crowdsec-agent. This tool has the following functionalities: manage decisions and alerts : This is how you monitor ongoing remediation and detections manage configurations such as collections , parsers , scenarios : This is how you install/update 's detection capabilities and manage whitelists interact with the hub to find new configurations or update existing ones manage local api (LAPI) bouncers and machines : This allows you to manage LAPI credentials, this is how you make and bouncers comunicate observe crowdsec via metrics or the dashboard : This is how you gain real-time observability manage simulation configurations, allowing you to disable/modify remediation triggered by specific scenarios Take a look at the dedicated documentation Tips You can enable cscli auto completion in bash or zsh . You can find cscli completion documentation here .","title":"Overview"},{"location":"user_guide/cscli.html#configuration","text":"cscli shares the configuration file of crowdsec-agent, usually in /etc/crowdsec/config.yaml","title":"Configuration"},{"location":"user_guide/database.html","text":"Databases \u00b6 By default, the crowdsec Local API use SQLite as backend storage. But in case you expect a lot of traffic on your local API, you should use MySQL or PostgreSQL . For SQLite , there is nothing to do to make it work with crowdsec. But for MySQL and PostgreSQL , you have to create the database and the user. Please refer to ent. supported database . At the time of writting : MySQL 5.6.35 , 5.7.26 and 8 MariaDB 10.2 and latest PostgreSQL 10 , 11 and 12 SQLite Gremlin Warning When switching an existing instance of crowdsec to a new database backend, you need to register your machine(s) (ie. cscli machines add -a ) and bouncer(s) to the new database, as data is not migrated. MySQL \u00b6 Connect to your MySQL server and run the following commands: mysql> CREATE DATABASE crowdsec; mysql> CREATE USER 'crowdsec'@'%' IDENTIFIED BY '<password>'; mysql> GRANT ALL PRIVILEGES ON crowdsec.* TO 'crowdsec'@'%'; mysql> FLUSH PRIVILEGES; Then edit /etc/crowdsec/config.yaml to update the db_config part. You can now start/restart crowdsec. PostgreSQL \u00b6 Connect to your PostgreSQL server and run the following commands: postgres=# CREATE DATABASE crowdsec; postgres=# CREATE USER crowdsec WITH PASSWORD '<password>'; postgres=# GRANT ALL PRIVILEGES ON DATABASE crowdsec TO crowdsec; Then edit /etc/crowdsec/config.yaml to update the db_config part. You can now start/restart crowdsec.","title":"Databases"},{"location":"user_guide/database.html#databases","text":"By default, the crowdsec Local API use SQLite as backend storage. But in case you expect a lot of traffic on your local API, you should use MySQL or PostgreSQL . For SQLite , there is nothing to do to make it work with crowdsec. But for MySQL and PostgreSQL , you have to create the database and the user. Please refer to ent. supported database . At the time of writting : MySQL 5.6.35 , 5.7.26 and 8 MariaDB 10.2 and latest PostgreSQL 10 , 11 and 12 SQLite Gremlin Warning When switching an existing instance of crowdsec to a new database backend, you need to register your machine(s) (ie. cscli machines add -a ) and bouncer(s) to the new database, as data is not migrated.","title":"Databases"},{"location":"user_guide/database.html#mysql","text":"Connect to your MySQL server and run the following commands: mysql> CREATE DATABASE crowdsec; mysql> CREATE USER 'crowdsec'@'%' IDENTIFIED BY '<password>'; mysql> GRANT ALL PRIVILEGES ON crowdsec.* TO 'crowdsec'@'%'; mysql> FLUSH PRIVILEGES; Then edit /etc/crowdsec/config.yaml to update the db_config part. You can now start/restart crowdsec.","title":"MySQL"},{"location":"user_guide/database.html#postgresql","text":"Connect to your PostgreSQL server and run the following commands: postgres=# CREATE DATABASE crowdsec; postgres=# CREATE USER crowdsec WITH PASSWORD '<password>'; postgres=# GRANT ALL PRIVILEGES ON DATABASE crowdsec TO crowdsec; Then edit /etc/crowdsec/config.yaml to update the db_config part. You can now start/restart crowdsec.","title":"PostgreSQL"},{"location":"user_guide/debugging_configs.html","text":"Debugging Scenarios and Parsers \u00b6 General Advice \u00b6 When trying to debug a parser or a scenario : Work on \"cold logs\" (with the -dsn and -type options) rather than live ones Use the /etc/crowdsec/user.yaml configuration files to have logs on stdout Using user-mode configuration \u00b6 crowdsec -c /etc/crowdsec/user.yaml -dsn file://mylogs.log.gz -type syslog INFO [ 05 -08-2020 16 :15:47 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :15:47 ] Loading grok library ... WARN [ 05 -08-2020 16 :16:12 ] 182 .x.x.x triggered a 4h0m0s ip ban remediation for [ crowdsecurity/http-probing ] bucket_id = misty-moon event_time = \"2019-01-01 22:58:32 +0100 CET\" scenario = crowdsecurity/http-probing source_ip = 182 .x.x.x ... /etc/crowdsec/user.yaml disables demonization and push logs to stdout/stderr -type must respect expected log type (ie. nginx syslog etc.) -dsn must point to a valid log source (file, gz logs, cloudwatch or such) When processing logs like this, crowdsec-agent runs in \"time machine\" mode, and relies on the timestamps in the logs to evaluate scenarios. You will most likely need the crowdsecurity/dateparse-enrich parser for this. Testing configurations on live system \u00b6 If you're playing around with parser/scenarios on a live system, you can use the -t (lint) option of Crowdsec-agent to check your configurations validity before restarting/reloading services : $ emacs /etc/crowdsec/scenarios/ssh-bf.yaml ... $ crowdsec -c /etc/crowdsec/user.yaml -t INFO [ 06 -08-2020 13 :36:04 ] Crowdsec v0.3.0-rc3-4cffef42732944d4b81b3e62a03d4040ad74f185 ... ERRO [ 06 -08-2020 13 :36:05 ] Bad yaml in /etc/crowdsec/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory FATA [ 06 -08-2020 13 :36:05 ] Failed to load scenarios: Scenario loading failed : bad yaml in /etc/crowdsec/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory Using this, you won't have to kill your running service before you know the scenarios/parsers are at least syntactically correct. Using debug \u00b6 Both scenarios and parsers support a debug: true|false option which produce useful debug. Debug parsing output (expand) DEBU [ 05 -08-2020 15 :25:36 ] eval ( evt.Parsed.program == 'nginx' ) = TRUE id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] eval variables: id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.Parsed.program = 'nginx' id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event entering node id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'request' ] = '/data.php' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_user_agent' ] = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_referer' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_addr' ] = '123.x.x.x' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_user' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'time_local' ] = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'method' ] = 'POST' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'body_bytes_sent' ] = '162' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_version' ] = '1.1' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'status' ] = '404' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Meta [ log_type ] = 'http_access-log' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.StrTime = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event leaving node : ok id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] child is success, OnSuccess = next_stage, skip id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse Debug scenario output (expand) DEBU [ 05 -08-2020 16 :02:26 ] eval ( evt.Meta.service == 'http' && evt.Meta.http_status in [ '404' , '403' , '400' ] && evt.Parsed.static_ressource == 'false' ) = TRUE cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] eval variables: cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.service = 'http' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.http_status = '404' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Parsed.static_ressource = 'false' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing Test environments \u00b6 From a crowdsec-agent release archive , you can deploy a test (non-root) environment that is very suitable to write/debug/test parsers and scenarios. Environment is deployed using ./test_env.sh script from tgz directory, and creates a test environment in ./tests : $ cd crowdsec-v0.3.0/ $ ./test_env.sh ... [ 08 /05/2020:04:19:18 PM ][ INFO ] Setting up configurations INFO [ 0000 ] Wrote new 75065 bytes index to config/crowdsec-cli/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK ... INFO [ 0007 ] Enabled collections : crowdsecurity/linux INFO [ 0007 ] Enabled crowdsecurity/linux [ 08 /05/2020:04:19:26 PM ][ INFO ] Environment is ready in /home/bui/github/crowdsec/crowdsec/crowdsec-v0.3.0/tests $ cd tests $ ./cscli -c dev.yaml list ... INFO [ 0000 ] PARSERS: ------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------- crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 config/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .3 config/parsers/s00-raw/syslog-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .2 config/parsers/s01-parse/sshd-logs.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 config/parsers/s02-enrich/dateparse-enrich.yaml ------------------------------------------------------------------------------------------------------- ... $ ./crowdsec -c dev.yaml -dsn file://sshd.log -type syslog INFO [ 05 -08-2020 16 :23:32 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :23:32 ] Loading grok library ...","title":"Debugging"},{"location":"user_guide/debugging_configs.html#debugging-scenarios-and-parsers","text":"","title":"Debugging Scenarios and Parsers"},{"location":"user_guide/debugging_configs.html#general-advice","text":"When trying to debug a parser or a scenario : Work on \"cold logs\" (with the -dsn and -type options) rather than live ones Use the /etc/crowdsec/user.yaml configuration files to have logs on stdout","title":"General Advice"},{"location":"user_guide/debugging_configs.html#using-user-mode-configuration","text":"crowdsec -c /etc/crowdsec/user.yaml -dsn file://mylogs.log.gz -type syslog INFO [ 05 -08-2020 16 :15:47 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :15:47 ] Loading grok library ... WARN [ 05 -08-2020 16 :16:12 ] 182 .x.x.x triggered a 4h0m0s ip ban remediation for [ crowdsecurity/http-probing ] bucket_id = misty-moon event_time = \"2019-01-01 22:58:32 +0100 CET\" scenario = crowdsecurity/http-probing source_ip = 182 .x.x.x ... /etc/crowdsec/user.yaml disables demonization and push logs to stdout/stderr -type must respect expected log type (ie. nginx syslog etc.) -dsn must point to a valid log source (file, gz logs, cloudwatch or such) When processing logs like this, crowdsec-agent runs in \"time machine\" mode, and relies on the timestamps in the logs to evaluate scenarios. You will most likely need the crowdsecurity/dateparse-enrich parser for this.","title":"Using user-mode configuration"},{"location":"user_guide/debugging_configs.html#testing-configurations-on-live-system","text":"If you're playing around with parser/scenarios on a live system, you can use the -t (lint) option of Crowdsec-agent to check your configurations validity before restarting/reloading services : $ emacs /etc/crowdsec/scenarios/ssh-bf.yaml ... $ crowdsec -c /etc/crowdsec/user.yaml -t INFO [ 06 -08-2020 13 :36:04 ] Crowdsec v0.3.0-rc3-4cffef42732944d4b81b3e62a03d4040ad74f185 ... ERRO [ 06 -08-2020 13 :36:05 ] Bad yaml in /etc/crowdsec/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory FATA [ 06 -08-2020 13 :36:05 ] Failed to load scenarios: Scenario loading failed : bad yaml in /etc/crowdsec/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory Using this, you won't have to kill your running service before you know the scenarios/parsers are at least syntactically correct.","title":"Testing configurations on live system"},{"location":"user_guide/debugging_configs.html#using-debug","text":"Both scenarios and parsers support a debug: true|false option which produce useful debug. Debug parsing output (expand) DEBU [ 05 -08-2020 15 :25:36 ] eval ( evt.Parsed.program == 'nginx' ) = TRUE id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] eval variables: id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.Parsed.program = 'nginx' id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event entering node id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'request' ] = '/data.php' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_user_agent' ] = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_referer' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_addr' ] = '123.x.x.x' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_user' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'time_local' ] = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'method' ] = 'POST' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'body_bytes_sent' ] = '162' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_version' ] = '1.1' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'status' ] = '404' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Meta [ log_type ] = 'http_access-log' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.StrTime = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event leaving node : ok id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] child is success, OnSuccess = next_stage, skip id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse Debug scenario output (expand) DEBU [ 05 -08-2020 16 :02:26 ] eval ( evt.Meta.service == 'http' && evt.Meta.http_status in [ '404' , '403' , '400' ] && evt.Parsed.static_ressource == 'false' ) = TRUE cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] eval variables: cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.service = 'http' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.http_status = '404' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Parsed.static_ressource = 'false' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing","title":"Using debug"},{"location":"user_guide/debugging_configs.html#test-environments","text":"From a crowdsec-agent release archive , you can deploy a test (non-root) environment that is very suitable to write/debug/test parsers and scenarios. Environment is deployed using ./test_env.sh script from tgz directory, and creates a test environment in ./tests : $ cd crowdsec-v0.3.0/ $ ./test_env.sh ... [ 08 /05/2020:04:19:18 PM ][ INFO ] Setting up configurations INFO [ 0000 ] Wrote new 75065 bytes index to config/crowdsec-cli/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK ... INFO [ 0007 ] Enabled collections : crowdsecurity/linux INFO [ 0007 ] Enabled crowdsecurity/linux [ 08 /05/2020:04:19:26 PM ][ INFO ] Environment is ready in /home/bui/github/crowdsec/crowdsec/crowdsec-v0.3.0/tests $ cd tests $ ./cscli -c dev.yaml list ... INFO [ 0000 ] PARSERS: ------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------- crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 config/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .3 config/parsers/s00-raw/syslog-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .2 config/parsers/s01-parse/sshd-logs.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 config/parsers/s02-enrich/dateparse-enrich.yaml ------------------------------------------------------------------------------------------------------- ... $ ./crowdsec -c dev.yaml -dsn file://sshd.log -type syslog INFO [ 05 -08-2020 16 :23:32 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :23:32 ] Loading grok library ...","title":"Test environments"},{"location":"user_guide/decision_management.html","text":"Info Please see your local sudo cscli help decisions for up-to-date documentation. List active decisions \u00b6 sudo cscli decisions list example $ sudo cscli decisions list +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | 802 | cscli | Ip:1.2.3.5 | manual 'ban' from | ban | | | 1 | 3h50m58.10039043s | 802 | | | | | 'b76cc7b1bbdc489e93909d2043031de8' | | | | | | | | 801 | crowdsec | Ip:1.2.3.4 | crowdsecurity/ssh-bf | ban | | | 6 | 3h59m45.100387557s | 801 | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ SOURCE : the source of the decisions: crowdsec : decision from crowdsec agent cscli : decision from cscli (manual decision) api : decision from crowdsec API SCOPE:VALUE is the target of the decisions : \"scope\" : the scope of the decisions ( ip , range , user ...) \"value\" : the value to apply on the decisions ( , , ...) REASON is the scenario that was triggered (or human-supplied reason) ACTION is the type of the decision ( ban , captcha ...) COUNTRY and AS are provided by GeoIP enrichment if present EVENTS number of event that triggered this decison EXPIRATION is the time left on remediation ALERT ID is the ID of the corresponding alert Check command usage for additional filtering and output control flags. Add a decision \u00b6 default duration : 4h default type : ban Add a decision (ban) on IP 1.2.3.4 for 24 hours, with reason 'web bruteforce' sudo cscli decisions add --ip 1 .2.3.4 --duration 24h --reason \"web bruteforce\" Add a decision (ban) on range 1.2.3.0/24 for 4 hours, with reason 'web bruteforce' sudo cscli decisions add --range 1 .2.3.0/24 --reason \"web bruteforce\" Add a decision (captcha) on ip 1.2.3.4 for 4hours (default duration), with reason 'web bruteforce' sudo cscli decisions add --ip 1 .2.3.4 --reason \"web bruteforce\" --type captcha Delete a decision \u00b6 delete the decision on IP 1.2.3.4 sudo cscli decisions delete --ip 1 .2.3.4 delete the decision on range 1.2.3.0/24 sudo cscli decisions delete --range 1 .2.3.0/24 Warning Please note that cscli decisions list will show you only the latest alert per given ip/scope. However, several decisions targeting the same IP can exist. If you want to be sure to clear all decisions for a given ip/scope, use cscli decisions delete -i x.x.x.x Delete all existing bans \u00b6 Flush all the existing bans sudo cscli decisions delete --all Warning This will as well remove any existing ban","title":"Decisions management"},{"location":"user_guide/decision_management.html#list-active-decisions","text":"sudo cscli decisions list example $ sudo cscli decisions list +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | ALERT ID | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ | 802 | cscli | Ip:1.2.3.5 | manual 'ban' from | ban | | | 1 | 3h50m58.10039043s | 802 | | | | | 'b76cc7b1bbdc489e93909d2043031de8' | | | | | | | | 801 | crowdsec | Ip:1.2.3.4 | crowdsecurity/ssh-bf | ban | | | 6 | 3h59m45.100387557s | 801 | +-----+-----------+-------------+------------------------------------+--------+---------+----+--------+--------------------+----------+ SOURCE : the source of the decisions: crowdsec : decision from crowdsec agent cscli : decision from cscli (manual decision) api : decision from crowdsec API SCOPE:VALUE is the target of the decisions : \"scope\" : the scope of the decisions ( ip , range , user ...) \"value\" : the value to apply on the decisions ( , , ...) REASON is the scenario that was triggered (or human-supplied reason) ACTION is the type of the decision ( ban , captcha ...) COUNTRY and AS are provided by GeoIP enrichment if present EVENTS number of event that triggered this decison EXPIRATION is the time left on remediation ALERT ID is the ID of the corresponding alert Check command usage for additional filtering and output control flags.","title":"List active decisions"},{"location":"user_guide/decision_management.html#add-a-decision","text":"default duration : 4h default type : ban Add a decision (ban) on IP 1.2.3.4 for 24 hours, with reason 'web bruteforce' sudo cscli decisions add --ip 1 .2.3.4 --duration 24h --reason \"web bruteforce\" Add a decision (ban) on range 1.2.3.0/24 for 4 hours, with reason 'web bruteforce' sudo cscli decisions add --range 1 .2.3.0/24 --reason \"web bruteforce\" Add a decision (captcha) on ip 1.2.3.4 for 4hours (default duration), with reason 'web bruteforce' sudo cscli decisions add --ip 1 .2.3.4 --reason \"web bruteforce\" --type captcha","title":"Add a decision"},{"location":"user_guide/decision_management.html#delete-a-decision","text":"delete the decision on IP 1.2.3.4 sudo cscli decisions delete --ip 1 .2.3.4 delete the decision on range 1.2.3.0/24 sudo cscli decisions delete --range 1 .2.3.0/24 Warning Please note that cscli decisions list will show you only the latest alert per given ip/scope. However, several decisions targeting the same IP can exist. If you want to be sure to clear all decisions for a given ip/scope, use cscli decisions delete -i x.x.x.x","title":"Delete a decision"},{"location":"user_guide/decision_management.html#delete-all-existing-bans","text":"Flush all the existing bans sudo cscli decisions delete --all Warning This will as well remove any existing ban","title":"Delete all existing bans"},{"location":"user_guide/forensic_mode.html","text":"Forensic mode \u00b6 While crowdsec-agent can be used to monitor \"live\" logs, it can as well be used on cold logs. It is a great way to test scenario, detect false positives & false negatives or simply generate reporting on a past time period. When doing so, crowdsec-agent will read the logs, extract timestamps from those, so that the scenarios/buckets can be evaluated with the log's timestamps. The resulting overflows will be pushed to the API as any other alert, but the timestamp will be the timestamps of the logs, properly allowing you to view the alerts in their original time line. you can run : sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///path/to/your/log/file.log -type log_file_type Where -dsn points to the log file you want to process, and the -type is similar to what you would put in your acquisition's label field, for example : sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///var/log/nginx/2019.log -type nginx sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///var/log/sshd-2019.log -type syslog sudo crowdsec -c /etc/crowdsec/user.yaml -dns \"journalctl://filters=_SYSTEMD_UNIT=ssh.service --since yesterday\" -type syslog When running crowdsec in forensic mode, the alerts will be displayed to stdout, and as well pushed to database : $ sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///var/log/nginx/nginx-2019.log.1 -type nginx ... INFO [ 13 -11-2020 13 :05:23 ] Ip 123 .206.50.249 performed 'crowdsecurity/http-probing' ( 11 events over 6s ) at 2019 -01-01 01 :37:32 +0100 CET INFO [ 13 -11-2020 13 :05:23 ] Ip 123 .206.50.249 performed 'crowdsecurity/http-backdoors-attempts' ( 2 events over 1s ) at 2019 -01-01 01 :37:33 +0100 CET INFO [ 13 -11-2020 13 :05:24 ] ( 14baeedafc1e44c08b806fc0c1cd92c4/crowdsec ) crowdsecurity/http-probing by ip 123 .206.50.249 ( CN ) : 1h ban on Ip 123 .206.50.249 INFO [ 13 -11-2020 13 :05:24 ] ( 14baeedafc1e44c08b806fc0c1cd92c4/crowdsec ) crowdsecurity/http-backdoors-attempts by ip 123 .206.50.249 ( CN ) : 1h ban on Ip 123 .206.50.249 ... And as these alerts are as well pushed to database, it mean you can view them in metabase, or using cscli ! Warning To work in forensic mode, crowdsec-agent relies on crowdsecurity/dateparse-enrich to parse date formats. See dedicated hub page for supported formats. Injecting alerts into existing database \u00b6 If you already have a running crowdsec/Local API running and want to inject events into existing database, you can run crowdsec directly : sudo crowdsec -dsn file://logs/nginx/access.log -type nginx --no-api Crowdsec will process logs/nginx/access.log and push alerts to the Local API configured in your default configuration file ( /etc/crowdsec/config.yaml , see api.client.credentials_path ) Injection alerts into new database - no local instance running \u00b6 If you don't have a service currently running, you can run crowdsec directly : sudo crowdsec -dsn file://logs/nginx/access.log -type nginx Crowdsec will start a Local API and process logs/nginx/access.log . Injection alerts into new database - while local instance is running \u00b6 If you have a local instance running and you don't want to pollute your existing database, we are going to configure a separate instance of Local API & database. Let's copy the existing configuration to edit it : $ sudo cp /etc/crowdsec/config.yaml ./forensic.yaml $ emacs ./forensic.yaml In our file, let's edit the local API & database config to ensure we're not going to pollute existing data : $ emacs ./forensic.yaml ... db_config: type: sqlite # we edit the db_path to point to a different SQLite database db_path: /var/lib/crowdsec/data/crowdsec_alt.db # let's comment out the auto-flush (database garbage collection) #flush: # max_items: 5000 # max_age: 7d ... api: client: # we edit credentials_path to point to a local file credentials_path: /tmp/local_api_credentials.yaml server: # we edit the listen_uri so that it doesn't try to listen on the same port as the existing Local API listen_uri: 127 .0.0.1:8081 With the following edits, we ensure that : The SQLite database path will be different : it avoids conflicts if you already had one running locally Edit the local api credentials path : we're going to register our machine to the ephemeral Local API Edit the listen uri of the local api : it avoids conflicts for listen port in case you already had one running locally Comment out the flush section : it ensure the database garbage collector won't run and delete your old events you're injecting ;) Let's create the new database and register a machine to it : $ touch /tmp/local_api_credentials.yaml $ cscli -c forensic.yaml machines add --auto INFO [ 0000 ] Machine '...' created successfully INFO [ 0000 ] API credentials dumped to '/tmp/local_api_credentials.yaml' $ cat /tmp/local_api_credentials.yaml url: http://127.0.0.1:8081 login: ... password: ... Now we can start the new Local API and crowdsec : $ crowdsec -c ./forensic.yaml -dsn file://github/crowdsec/OLDS/LOGS/nginx/10k_ACCESS_LOGS.log -type nginx ... INFO [ 15 -11-2020 10 :09:20 ] Ip x.x.x.x performed 'crowdsecurity/http-bad-user-agent' ( 2 events over 0s ) at 2017 -10-21 13 :58:38 +0200 CEST INFO [ 15 -11-2020 10 :09:20 ] Ip y.y.y.y performed 'crowdsecurity/http-probing' ( 11 events over 0s ) at 2017 -10-23 12 :00:34 +0200 CEST ... And we can even fire a dedicated dashboard to view the data : $ cscli -c forensic.yaml dashboard setup INFO [ 0000 ] /var/lib/crowdsec/data/metabase.db exists, skip. INFO [ 0000 ] Pulling docker image metabase/metabase:v0.37.0.2 ... INFO [ 0001 ] creating container '/crowdsec-metabase' INFO [ 0002 ] waiting for metabase to be up ( can take up to a minute ) ......... INFO [ 0040 ] Metabase is ready URL : 'http://127.0.0.1:3000' username : 'crowdsec@crowdsec.net' password : ... Injection alerts into new database - dev env \u00b6 From a fresh release : $ tar xvzf crowdsec-release.tgz $ cd crowdsec-v1.0.0-rc $ ./test_env.sh $ cd tests Install the needed collection(s) : $ ./cscli -c dev.yaml collections install crowdsecurity/nginx And we can process logs : $ ./crowdsec -c dev.yaml -dsn file://github/crowdsec/OLDS/LOGS/nginx/10k_ACCESS_LOGS.log -type nginx INFO [ 0000 ] single file mode : log_media = stdout daemonize = true INFO [ 15 -11-2020 11 :18:27 ] Crowdsec v1.0.0-rc-0ecb142dfffc89b019b6d9044cb7cc5569d12c70 INFO [ 15 -11-2020 11 :18:38 ] Ip x.x.x.x performed 'crowdsecurity/http-sensitive-files' ( 5 events over 4s ) at 2017 -10-23 12 :35:54 +0200 CEST INFO [ 15 -11-2020 11 :18:39 ] ( test/crowdsec ) crowdsecurity/http-probing by ip x.x.x.x ( DE ) : 1h ban on Ip x.x.x.x And we can then query the local api (while letting the crowdsec-agent running) : $ ./cscli -c dev.yaml alerts list +----+--------------------+---------------------------------------+---------+--------------+-----------+--------------------------------+ | ID | VALUE | REASON | COUNTRY | AS | DECISIONS | CREATED AT | +----+--------------------+---------------------------------------+---------+--------------+-----------+--------------------------------+ | 28 | Ip:x.x.x.x | crowdsecurity/http-crawl-non_statics | DE | Linode, LLC | ban:1 | 2017 -10-23 12 :36:48 +0200 | | | | | | | | +0200 | | 27 | Ip:x.x.x.x | crowdsecurity/http-sensitive-files | DE | Linode, LLC | ban:1 | 2017 -10-23 12 :35:50 +0200 | | | | | | | | +0200 | Or even start a dashboard to view data : $ sudo ./cscli dashboard setup ... INFO [ 0002 ] waiting for metabase to be up ( can take up to a minute ) ........","title":"Crowdsec forensic mode"},{"location":"user_guide/forensic_mode.html#forensic-mode","text":"While crowdsec-agent can be used to monitor \"live\" logs, it can as well be used on cold logs. It is a great way to test scenario, detect false positives & false negatives or simply generate reporting on a past time period. When doing so, crowdsec-agent will read the logs, extract timestamps from those, so that the scenarios/buckets can be evaluated with the log's timestamps. The resulting overflows will be pushed to the API as any other alert, but the timestamp will be the timestamps of the logs, properly allowing you to view the alerts in their original time line. you can run : sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///path/to/your/log/file.log -type log_file_type Where -dsn points to the log file you want to process, and the -type is similar to what you would put in your acquisition's label field, for example : sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///var/log/nginx/2019.log -type nginx sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///var/log/sshd-2019.log -type syslog sudo crowdsec -c /etc/crowdsec/user.yaml -dns \"journalctl://filters=_SYSTEMD_UNIT=ssh.service --since yesterday\" -type syslog When running crowdsec in forensic mode, the alerts will be displayed to stdout, and as well pushed to database : $ sudo crowdsec -c /etc/crowdsec/user.yaml -dsn file:///var/log/nginx/nginx-2019.log.1 -type nginx ... INFO [ 13 -11-2020 13 :05:23 ] Ip 123 .206.50.249 performed 'crowdsecurity/http-probing' ( 11 events over 6s ) at 2019 -01-01 01 :37:32 +0100 CET INFO [ 13 -11-2020 13 :05:23 ] Ip 123 .206.50.249 performed 'crowdsecurity/http-backdoors-attempts' ( 2 events over 1s ) at 2019 -01-01 01 :37:33 +0100 CET INFO [ 13 -11-2020 13 :05:24 ] ( 14baeedafc1e44c08b806fc0c1cd92c4/crowdsec ) crowdsecurity/http-probing by ip 123 .206.50.249 ( CN ) : 1h ban on Ip 123 .206.50.249 INFO [ 13 -11-2020 13 :05:24 ] ( 14baeedafc1e44c08b806fc0c1cd92c4/crowdsec ) crowdsecurity/http-backdoors-attempts by ip 123 .206.50.249 ( CN ) : 1h ban on Ip 123 .206.50.249 ... And as these alerts are as well pushed to database, it mean you can view them in metabase, or using cscli ! Warning To work in forensic mode, crowdsec-agent relies on crowdsecurity/dateparse-enrich to parse date formats. See dedicated hub page for supported formats.","title":"Forensic mode"},{"location":"user_guide/forensic_mode.html#injecting-alerts-into-existing-database","text":"If you already have a running crowdsec/Local API running and want to inject events into existing database, you can run crowdsec directly : sudo crowdsec -dsn file://logs/nginx/access.log -type nginx --no-api Crowdsec will process logs/nginx/access.log and push alerts to the Local API configured in your default configuration file ( /etc/crowdsec/config.yaml , see api.client.credentials_path )","title":"Injecting alerts into existing database"},{"location":"user_guide/forensic_mode.html#injection-alerts-into-new-database-no-local-instance-running","text":"If you don't have a service currently running, you can run crowdsec directly : sudo crowdsec -dsn file://logs/nginx/access.log -type nginx Crowdsec will start a Local API and process logs/nginx/access.log .","title":"Injection alerts into new database - no local instance running"},{"location":"user_guide/forensic_mode.html#injection-alerts-into-new-database-while-local-instance-is-running","text":"If you have a local instance running and you don't want to pollute your existing database, we are going to configure a separate instance of Local API & database. Let's copy the existing configuration to edit it : $ sudo cp /etc/crowdsec/config.yaml ./forensic.yaml $ emacs ./forensic.yaml In our file, let's edit the local API & database config to ensure we're not going to pollute existing data : $ emacs ./forensic.yaml ... db_config: type: sqlite # we edit the db_path to point to a different SQLite database db_path: /var/lib/crowdsec/data/crowdsec_alt.db # let's comment out the auto-flush (database garbage collection) #flush: # max_items: 5000 # max_age: 7d ... api: client: # we edit credentials_path to point to a local file credentials_path: /tmp/local_api_credentials.yaml server: # we edit the listen_uri so that it doesn't try to listen on the same port as the existing Local API listen_uri: 127 .0.0.1:8081 With the following edits, we ensure that : The SQLite database path will be different : it avoids conflicts if you already had one running locally Edit the local api credentials path : we're going to register our machine to the ephemeral Local API Edit the listen uri of the local api : it avoids conflicts for listen port in case you already had one running locally Comment out the flush section : it ensure the database garbage collector won't run and delete your old events you're injecting ;) Let's create the new database and register a machine to it : $ touch /tmp/local_api_credentials.yaml $ cscli -c forensic.yaml machines add --auto INFO [ 0000 ] Machine '...' created successfully INFO [ 0000 ] API credentials dumped to '/tmp/local_api_credentials.yaml' $ cat /tmp/local_api_credentials.yaml url: http://127.0.0.1:8081 login: ... password: ... Now we can start the new Local API and crowdsec : $ crowdsec -c ./forensic.yaml -dsn file://github/crowdsec/OLDS/LOGS/nginx/10k_ACCESS_LOGS.log -type nginx ... INFO [ 15 -11-2020 10 :09:20 ] Ip x.x.x.x performed 'crowdsecurity/http-bad-user-agent' ( 2 events over 0s ) at 2017 -10-21 13 :58:38 +0200 CEST INFO [ 15 -11-2020 10 :09:20 ] Ip y.y.y.y performed 'crowdsecurity/http-probing' ( 11 events over 0s ) at 2017 -10-23 12 :00:34 +0200 CEST ... And we can even fire a dedicated dashboard to view the data : $ cscli -c forensic.yaml dashboard setup INFO [ 0000 ] /var/lib/crowdsec/data/metabase.db exists, skip. INFO [ 0000 ] Pulling docker image metabase/metabase:v0.37.0.2 ... INFO [ 0001 ] creating container '/crowdsec-metabase' INFO [ 0002 ] waiting for metabase to be up ( can take up to a minute ) ......... INFO [ 0040 ] Metabase is ready URL : 'http://127.0.0.1:3000' username : 'crowdsec@crowdsec.net' password : ...","title":"Injection alerts into new database - while local instance is running"},{"location":"user_guide/forensic_mode.html#injection-alerts-into-new-database-dev-env","text":"From a fresh release : $ tar xvzf crowdsec-release.tgz $ cd crowdsec-v1.0.0-rc $ ./test_env.sh $ cd tests Install the needed collection(s) : $ ./cscli -c dev.yaml collections install crowdsecurity/nginx And we can process logs : $ ./crowdsec -c dev.yaml -dsn file://github/crowdsec/OLDS/LOGS/nginx/10k_ACCESS_LOGS.log -type nginx INFO [ 0000 ] single file mode : log_media = stdout daemonize = true INFO [ 15 -11-2020 11 :18:27 ] Crowdsec v1.0.0-rc-0ecb142dfffc89b019b6d9044cb7cc5569d12c70 INFO [ 15 -11-2020 11 :18:38 ] Ip x.x.x.x performed 'crowdsecurity/http-sensitive-files' ( 5 events over 4s ) at 2017 -10-23 12 :35:54 +0200 CEST INFO [ 15 -11-2020 11 :18:39 ] ( test/crowdsec ) crowdsecurity/http-probing by ip x.x.x.x ( DE ) : 1h ban on Ip x.x.x.x And we can then query the local api (while letting the crowdsec-agent running) : $ ./cscli -c dev.yaml alerts list +----+--------------------+---------------------------------------+---------+--------------+-----------+--------------------------------+ | ID | VALUE | REASON | COUNTRY | AS | DECISIONS | CREATED AT | +----+--------------------+---------------------------------------+---------+--------------+-----------+--------------------------------+ | 28 | Ip:x.x.x.x | crowdsecurity/http-crawl-non_statics | DE | Linode, LLC | ban:1 | 2017 -10-23 12 :36:48 +0200 | | | | | | | | +0200 | | 27 | Ip:x.x.x.x | crowdsecurity/http-sensitive-files | DE | Linode, LLC | ban:1 | 2017 -10-23 12 :35:50 +0200 | | | | | | | | +0200 | Or even start a dashboard to view data : $ sudo ./cscli dashboard setup ... INFO [ 0002 ] waiting for metabase to be up ( can take up to a minute ) ........","title":"Injection alerts into new database - dev env"},{"location":"user_guide/network.html","text":"Ports inventory \u00b6 tcp/8080 exposes a REST API for bouncers, cscli and comunication between crowdsec agent and local api tcp/6060 (endpoint /metrics ) exposes prometheus metrics tcp/6060 (endpoint /debug ) exposes pprof debugging metrics Outgoing connections \u00b6 Local API connects to tcp/443 on api.crowdsec.net (signal push and blocklists pull) cscli connects to tcp/443 on raw.githubusercontent.com to fetch scenarios, parsers etc. cscli dashboard fetches metabase configuration from a s3 bucket ( https://crowdsec-statics-assets.s3-eu-west-1.amazonaws.com/ ) Comunication between components \u00b6 Bouncers -> Local API \u00b6 Bouncers are using Local API on tcp/8080 by default Agents -> Local API \u00b6 Agents connect to local API on port tcp/8080 (only relevant ) Warning If there is an error in the agent configuration, it will also cause the Local API to fail if both of them are running in the same machine ! Both components need proper configuration to run (we decide to keep this behavior to detect agent or local API errors on start). Local API -> Central API \u00b6 Central API is reached on port tcp/443 by Local API. The FQDN is api.crowdsec.net Local API -> Database \u00b6 When using a networked database (PostgreSQL or MySQL), only the local API needs to access the database, agents don't have to be able to comunicate with it. Prometheus -> Agents \u00b6 If you're scrapping prometheus metrics from your agents or your local API, you need to allow inbound connections to tcp/6060","title":"Network management"},{"location":"user_guide/network.html#ports-inventory","text":"tcp/8080 exposes a REST API for bouncers, cscli and comunication between crowdsec agent and local api tcp/6060 (endpoint /metrics ) exposes prometheus metrics tcp/6060 (endpoint /debug ) exposes pprof debugging metrics","title":"Ports inventory"},{"location":"user_guide/network.html#outgoing-connections","text":"Local API connects to tcp/443 on api.crowdsec.net (signal push and blocklists pull) cscli connects to tcp/443 on raw.githubusercontent.com to fetch scenarios, parsers etc. cscli dashboard fetches metabase configuration from a s3 bucket ( https://crowdsec-statics-assets.s3-eu-west-1.amazonaws.com/ )","title":"Outgoing connections"},{"location":"user_guide/network.html#comunication-between-components","text":"","title":"Comunication between components"},{"location":"user_guide/network.html#bouncers-local-api","text":"Bouncers are using Local API on tcp/8080 by default","title":"Bouncers -&gt; Local API"},{"location":"user_guide/network.html#agents-local-api","text":"Agents connect to local API on port tcp/8080 (only relevant ) Warning If there is an error in the agent configuration, it will also cause the Local API to fail if both of them are running in the same machine ! Both components need proper configuration to run (we decide to keep this behavior to detect agent or local API errors on start).","title":"Agents -&gt; Local API"},{"location":"user_guide/network.html#local-api-central-api","text":"Central API is reached on port tcp/443 by Local API. The FQDN is api.crowdsec.net","title":"Local API -&gt; Central API"},{"location":"user_guide/network.html#local-api-database","text":"When using a networked database (PostgreSQL or MySQL), only the local API needs to access the database, agents don't have to be able to comunicate with it.","title":"Local API -&gt; Database"},{"location":"user_guide/network.html#prometheus-agents","text":"If you're scrapping prometheus metrics from your agents or your local API, you need to allow inbound connections to tcp/6060","title":"Prometheus -&gt; Agents"},{"location":"user_guide/simulation_mode.html","text":"Simulation \u00b6 $ sudo cscli simulation status INFO [ 0000 ] global simulation: disabled INFO [ 0000 ] Scenarios in simulation mode : INFO [ 0000 ] - crowdsecurity/ssh-bf cscli simulation allows to manage a list of scenarios that have their remediation \"simulated\" : they won't be effective (but will still be showed by cscli decisions list ). This configuration file is present in /etc/crowdsec/simulation.yaml . You can add and remove scenarios to the simulation list : $ sudo cscli simulation enable crowdsecurity/ssh-bf INFO [ 0000 ] simulation mode for 'crowdsecurity/ssh-bf' enabled INFO [ 0000 ] Run 'sudo systemctl reload crowdsec' for the new configuration to be effective. $ sudo systemctl reload crowdsec $ sudo tail -f /var/log/crowdsec.log .... time = \"01-11-2020 14:08:58\" level = info msg = \"Ip 1.2.3.6 performed 'crowdsecurity/ssh-bf' (6 events over 986.769\u00b5s) at 2020-11-01 14:08:58.575885389 +0100 CET m=+437.524832750\" time = \"01-11-2020 14:08:58\" level = info msg = \"Ip 1.2.3.6 decision : 1h (simulation) ban\" .... $ cscli decisions list +----+----------+--------------+-----------------------------------+------------+---------+----+--------+------------------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +----+----------+--------------+-----------------------------------+------------+---------+----+--------+------------------+ | 4 | crowdsec | Ip:1.2.3.6 | crowdsecurity/ssh-bf | ( simul ) ban | US | | 6 | 59m38.293036072s | +----+----------+--------------+-----------------------------------+------------+---------+----+--------+------------------+ But as well turn on \"global simulation\" : in this case, only scenarios in the exclusion list will have their decisions applied.","title":"Simulation management"},{"location":"user_guide/simulation_mode.html#simulation","text":"$ sudo cscli simulation status INFO [ 0000 ] global simulation: disabled INFO [ 0000 ] Scenarios in simulation mode : INFO [ 0000 ] - crowdsecurity/ssh-bf cscli simulation allows to manage a list of scenarios that have their remediation \"simulated\" : they won't be effective (but will still be showed by cscli decisions list ). This configuration file is present in /etc/crowdsec/simulation.yaml . You can add and remove scenarios to the simulation list : $ sudo cscli simulation enable crowdsecurity/ssh-bf INFO [ 0000 ] simulation mode for 'crowdsecurity/ssh-bf' enabled INFO [ 0000 ] Run 'sudo systemctl reload crowdsec' for the new configuration to be effective. $ sudo systemctl reload crowdsec $ sudo tail -f /var/log/crowdsec.log .... time = \"01-11-2020 14:08:58\" level = info msg = \"Ip 1.2.3.6 performed 'crowdsecurity/ssh-bf' (6 events over 986.769\u00b5s) at 2020-11-01 14:08:58.575885389 +0100 CET m=+437.524832750\" time = \"01-11-2020 14:08:58\" level = info msg = \"Ip 1.2.3.6 decision : 1h (simulation) ban\" .... $ cscli decisions list +----+----------+--------------+-----------------------------------+------------+---------+----+--------+------------------+ | ID | SOURCE | SCOPE:VALUE | REASON | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +----+----------+--------------+-----------------------------------+------------+---------+----+--------+------------------+ | 4 | crowdsec | Ip:1.2.3.6 | crowdsecurity/ssh-bf | ( simul ) ban | US | | 6 | 59m38.293036072s | +----+----------+--------------+-----------------------------------+------------+---------+----+--------+------------------+ But as well turn on \"global simulation\" : in this case, only scenarios in the exclusion list will have their decisions applied.","title":"Simulation"},{"location":"user_guide/configurations_management/collections.html","text":"Crowdsec Hub allows you to find needed collections. Installing collections \u00b6 $ sudo cscli collections install crowdsecurity/whitelist-good-actors cscli collection install example $ sudo cscli collections install crowdsecurity/whitelist-good-actors INFO [ 0000 ] crowdsecurity/seo-bots-whitelist : OK INFO [ 0000 ] downloading data 'https://raw.githubusercontent.com/crowdsecurity/sec-lists/master/whitelists/benign_bots/search_engine_crawlers/rdns_seo_bots.txt' in '/var/lib/crowdsec/data/rdns_seo_bots.txt' INFO [ 0001 ] downloading data 'https://raw.githubusercontent.com/crowdsecurity/sec-lists/master/whitelists/benign_bots/search_engine_crawlers/rnds_seo_bots.regex' in '/var/lib/crowdsec/data/rdns_seo_bots.regex' INFO [ 0002 ] downloading data 'https://raw.githubusercontent.com/crowdsecurity/sec-lists/master/whitelists/benign_bots/search_engine_crawlers/ip_seo_bots.txt' in '/var/lib/crowdsec/data/ip_seo_bots.txt' INFO [ 0002 ] crowdsecurity/cdn-whitelist : OK INFO [ 0002 ] downloading data 'https://www.cloudflare.com/ips-v4' in '/var/lib/crowdsec/data/cloudflare_ips.txt' INFO [ 0003 ] crowdsecurity/rdns : OK INFO [ 0003 ] crowdsecurity/whitelist-good-actors : OK INFO [ 0003 ] /etc/crowdsec/postoverflows/s01-whitelist doesn 't exist, create INFO[0003] Enabled postoverflows : crowdsecurity/seo-bots-whitelist INFO[0003] Enabled postoverflows : crowdsecurity/cdn-whitelist INFO[0003] /etc/crowdsec/postoverflows/s00-enrich doesn' t exist, create INFO [ 0003 ] Enabled postoverflows : crowdsecurity/rdns INFO [ 0003 ] Enabled collections : crowdsecurity/whitelist-good-actors INFO [ 0003 ] Enabled crowdsecurity/whitelist-good-actors INFO [ 0003 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. $ systemctl reload crowdsec Listing installed collections \u00b6 $ sudo cscli collections list cscli collections list example $ sudo cscli collections list ------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------------- crowdsecurity/nginx \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/nginx.yaml crowdsecurity/base-http-scenarios \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/base-http-scenarios.yaml crowdsecurity/sshd \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/sshd.yaml crowdsecurity/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/collections/linux.yaml ------------------------------------------------------------------------------------------------------------- Upgrading installed collections \u00b6 $ sudo cscli hub update $ sudo cscli collections upgrade crowdsecurity/sshd Collection upgrade allows you to upgrade an existing collection (and its items) to the latest version. cscli collections upgrade example $ sudo cscli collections upgrade crowdsecurity/sshd INFO [ 0000 ] crowdsecurity/sshd : up-to-date WARN [ 0000 ] crowdsecurity/sshd-logs : overwrite WARN [ 0000 ] crowdsecurity/ssh-bf : overwrite WARN [ 0000 ] crowdsecurity/sshd : overwrite INFO [ 0000 ] \ud83d\udce6 crowdsecurity/sshd : updated INFO [ 0000 ] Upgraded 1 items INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. $ systemctl reload crowdsec Monitoring collections \u00b6 $ sudo cscli collections inspect crowdsecurity/sshd Collections inspect will give you detailed information about a given collection, including versioning information and runtime metrics (fetched from prometheus). cscli collections inspect example $ sudo cscli collections inspect crowdsecurity/sshd type: collections name: crowdsecurity/sshd filename: sshd.yaml description: 'sshd support : parser and brute-force detection' author: crowdsecurity belongs_to_collections: - crowdsecurity/linux - crowdsecurity/linux remote_path: collections/crowdsecurity/sshd.yaml version: \"0.1\" local_path: /etc/crowdsec/collections/sshd.yaml localversion: \"0.1\" localhash: 21159aeb87529efcf1a5033f720413d5321a6451bab679a999f7f01a7aa972b3 installed: true downloaded: true uptodate: true tainted: false local: false parsers: - crowdsecurity/sshd-logs scenarios: - crowdsecurity/ssh-bf Current metrics : - ( Scenario ) crowdsecurity/ssh-bf: +---------------+-----------+--------------+--------+---------+ | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +---------------+-----------+--------------+--------+---------+ | 0 | 1 | 2 | 10 | 1 | +---------------+-----------+--------------+--------+---------+ Reference documentation \u00b6 Link to collections reference documentation","title":"Collections"},{"location":"user_guide/configurations_management/collections.html#installing-collections","text":"$ sudo cscli collections install crowdsecurity/whitelist-good-actors cscli collection install example $ sudo cscli collections install crowdsecurity/whitelist-good-actors INFO [ 0000 ] crowdsecurity/seo-bots-whitelist : OK INFO [ 0000 ] downloading data 'https://raw.githubusercontent.com/crowdsecurity/sec-lists/master/whitelists/benign_bots/search_engine_crawlers/rdns_seo_bots.txt' in '/var/lib/crowdsec/data/rdns_seo_bots.txt' INFO [ 0001 ] downloading data 'https://raw.githubusercontent.com/crowdsecurity/sec-lists/master/whitelists/benign_bots/search_engine_crawlers/rnds_seo_bots.regex' in '/var/lib/crowdsec/data/rdns_seo_bots.regex' INFO [ 0002 ] downloading data 'https://raw.githubusercontent.com/crowdsecurity/sec-lists/master/whitelists/benign_bots/search_engine_crawlers/ip_seo_bots.txt' in '/var/lib/crowdsec/data/ip_seo_bots.txt' INFO [ 0002 ] crowdsecurity/cdn-whitelist : OK INFO [ 0002 ] downloading data 'https://www.cloudflare.com/ips-v4' in '/var/lib/crowdsec/data/cloudflare_ips.txt' INFO [ 0003 ] crowdsecurity/rdns : OK INFO [ 0003 ] crowdsecurity/whitelist-good-actors : OK INFO [ 0003 ] /etc/crowdsec/postoverflows/s01-whitelist doesn 't exist, create INFO[0003] Enabled postoverflows : crowdsecurity/seo-bots-whitelist INFO[0003] Enabled postoverflows : crowdsecurity/cdn-whitelist INFO[0003] /etc/crowdsec/postoverflows/s00-enrich doesn' t exist, create INFO [ 0003 ] Enabled postoverflows : crowdsecurity/rdns INFO [ 0003 ] Enabled collections : crowdsecurity/whitelist-good-actors INFO [ 0003 ] Enabled crowdsecurity/whitelist-good-actors INFO [ 0003 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. $ systemctl reload crowdsec","title":"Installing collections"},{"location":"user_guide/configurations_management/collections.html#listing-installed-collections","text":"$ sudo cscli collections list cscli collections list example $ sudo cscli collections list ------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------------- crowdsecurity/nginx \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/nginx.yaml crowdsecurity/base-http-scenarios \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/base-http-scenarios.yaml crowdsecurity/sshd \u2714\ufe0f enabled 0 .1 /etc/crowdsec/collections/sshd.yaml crowdsecurity/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/collections/linux.yaml -------------------------------------------------------------------------------------------------------------","title":"Listing installed collections"},{"location":"user_guide/configurations_management/collections.html#upgrading-installed-collections","text":"$ sudo cscli hub update $ sudo cscli collections upgrade crowdsecurity/sshd Collection upgrade allows you to upgrade an existing collection (and its items) to the latest version. cscli collections upgrade example $ sudo cscli collections upgrade crowdsecurity/sshd INFO [ 0000 ] crowdsecurity/sshd : up-to-date WARN [ 0000 ] crowdsecurity/sshd-logs : overwrite WARN [ 0000 ] crowdsecurity/ssh-bf : overwrite WARN [ 0000 ] crowdsecurity/sshd : overwrite INFO [ 0000 ] \ud83d\udce6 crowdsecurity/sshd : updated INFO [ 0000 ] Upgraded 1 items INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. $ systemctl reload crowdsec","title":"Upgrading installed collections"},{"location":"user_guide/configurations_management/collections.html#monitoring-collections","text":"$ sudo cscli collections inspect crowdsecurity/sshd Collections inspect will give you detailed information about a given collection, including versioning information and runtime metrics (fetched from prometheus). cscli collections inspect example $ sudo cscli collections inspect crowdsecurity/sshd type: collections name: crowdsecurity/sshd filename: sshd.yaml description: 'sshd support : parser and brute-force detection' author: crowdsecurity belongs_to_collections: - crowdsecurity/linux - crowdsecurity/linux remote_path: collections/crowdsecurity/sshd.yaml version: \"0.1\" local_path: /etc/crowdsec/collections/sshd.yaml localversion: \"0.1\" localhash: 21159aeb87529efcf1a5033f720413d5321a6451bab679a999f7f01a7aa972b3 installed: true downloaded: true uptodate: true tainted: false local: false parsers: - crowdsecurity/sshd-logs scenarios: - crowdsecurity/ssh-bf Current metrics : - ( Scenario ) crowdsecurity/ssh-bf: +---------------+-----------+--------------+--------+---------+ | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +---------------+-----------+--------------+--------+---------+ | 0 | 1 | 2 | 10 | 1 | +---------------+-----------+--------------+--------+---------+","title":"Monitoring collections"},{"location":"user_guide/configurations_management/collections.html#reference-documentation","text":"Link to collections reference documentation","title":"Reference documentation"},{"location":"user_guide/configurations_management/enrichers.html","text":"Enrichers are basically parsers that can rely on external methods to provide extra contextual information to the event. The enrichers are usually in the s02-enrich stage (after most of the parsing happened). Enrichers functions should all accept a string as a parameter, and return an associative string array, that will be automatically merged into the Enriched map of the event . Warning At the time of writing, enrichers plugin mechanism implementation is still ongoing (read: the list of available enrichment methods is currently hardcoded). As an example let's look into the geoip-enrich parser/enricher : It relies on the geolite2 data created by maxmind and the geoip2 golang module to provide the actual data. It exposes three methods : GeoIpCity GeoIpASN and IpToRange that are used by the crowdsecurity/geoip-enrich . Enrichers can be installed as any other parsers with the following command: sudo cscli parsers install crowdsecurity/geoip-enrich Take a tour at the Crowdsec Hub to find them ! Reference documentation \u00b6 Link to enrichers reference documentation","title":"Enrichers"},{"location":"user_guide/configurations_management/enrichers.html#reference-documentation","text":"Link to enrichers reference documentation","title":"Reference documentation"},{"location":"user_guide/configurations_management/parsers.html","text":"Crowdsec Hub allows you to find needed parsers. Installing parsers \u00b6 $ sudo cscli parsers install crowdsecurity/sshd-logs cscli parsers install example $ sudo cscli parsers install crowdsecurity/iptables-logs INFO [ 0000 ] crowdsecurity/iptables-logs : OK INFO [ 0000 ] Enabled parsers : crowdsecurity/iptables-logs INFO [ 0000 ] Enabled crowdsecurity/iptables-logs INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. Listing installed parsers \u00b6 sudo cscli parsers list Parsers are yaml files in /etc/crowdsec/parsers/<STAGE>/parser.yaml . cscli parsers list example $ sudo cscli parsers list -------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------- crowdsecurity/whitelists \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/whitelists.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/dateparse-enrich.yaml crowdsecurity/iptables-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/iptables-logs.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 /etc/crowdsec/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/http-logs \u2714\ufe0f enabled 0 .2 /etc/crowdsec/parsers/s02-enrich/http-logs.yaml crowdsecurity/nginx-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/nginx-logs.yaml -------------------------------------------------------------------------------------------------------------- Upgrading installed parsers \u00b6 $ sudo cscli parsers upgrade crowdsecurity/sshd-logs Parsers upgrade allows you to upgrade an existing parser to the latest version. cscli parsers upgrade example $ sudo cscli parsers upgrade crowdsecurity/sshd-logs INFO [ 0000 ] crowdsecurity/sshd : up-to-date WARN [ 0000 ] crowdsecurity/sshd-logs : overwrite WARN [ 0000 ] crowdsecurity/ssh-bf : overwrite WARN [ 0000 ] crowdsecurity/sshd : overwrite INFO [ 0000 ] \ud83d\udce6 crowdsecurity/sshd : updated INFO [ 0000 ] Upgraded 1 items INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. Monitoring parsers \u00b6 $ sudo cscli parsers inspect crowdsecurity/sshd-logs Parsers inspect will give you detailed information about a given parser, including versioning information and runtime metrics (fetched from prometheus). cscli parsers inspect example $ sudo cscli parsers inspect crowdsecurity/sshd-logs type: parsers stage: s01-parse name: crowdsecurity/sshd-logs filename: sshd-logs.yaml description: Parse openSSH logs author: crowdsecurity belongs_to_collections: - crowdsecurity/sshd remote_path: parsers/s01-parse/crowdsecurity/sshd-logs.yaml version: \"0.1\" local_path: /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml localversion: \"0.1\" localhash: ecd40cb8cd95e2bad398824ab67b479362cdbf0e1598b8833e2f537ae3ce2f93 installed: true downloaded: true uptodate: true tainted: false local: false Current metrics : - ( Parser ) crowdsecurity/sshd-logs: +-------------------+-------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +-------------------+-------+--------+----------+ | /var/log/auth.log | 94138 | 42404 | 51734 | +-------------------+-------+--------+----------+ ## Reference documentation [Link to parsers reference documentation](/Crowdsec/v1/references/parsers/)","title":"Parsers"},{"location":"user_guide/configurations_management/parsers.html#installing-parsers","text":"$ sudo cscli parsers install crowdsecurity/sshd-logs cscli parsers install example $ sudo cscli parsers install crowdsecurity/iptables-logs INFO [ 0000 ] crowdsecurity/iptables-logs : OK INFO [ 0000 ] Enabled parsers : crowdsecurity/iptables-logs INFO [ 0000 ] Enabled crowdsecurity/iptables-logs INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective.","title":"Installing parsers"},{"location":"user_guide/configurations_management/parsers.html#listing-installed-parsers","text":"sudo cscli parsers list Parsers are yaml files in /etc/crowdsec/parsers/<STAGE>/parser.yaml . cscli parsers list example $ sudo cscli parsers list -------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------- crowdsecurity/whitelists \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/whitelists.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s02-enrich/dateparse-enrich.yaml crowdsecurity/iptables-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/iptables-logs.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s00-raw/syslog-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 /etc/crowdsec/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/http-logs \u2714\ufe0f enabled 0 .2 /etc/crowdsec/parsers/s02-enrich/http-logs.yaml crowdsecurity/nginx-logs \u2714\ufe0f enabled 0 .1 /etc/crowdsec/parsers/s01-parse/nginx-logs.yaml --------------------------------------------------------------------------------------------------------------","title":"Listing installed parsers"},{"location":"user_guide/configurations_management/parsers.html#upgrading-installed-parsers","text":"$ sudo cscli parsers upgrade crowdsecurity/sshd-logs Parsers upgrade allows you to upgrade an existing parser to the latest version. cscli parsers upgrade example $ sudo cscli parsers upgrade crowdsecurity/sshd-logs INFO [ 0000 ] crowdsecurity/sshd : up-to-date WARN [ 0000 ] crowdsecurity/sshd-logs : overwrite WARN [ 0000 ] crowdsecurity/ssh-bf : overwrite WARN [ 0000 ] crowdsecurity/sshd : overwrite INFO [ 0000 ] \ud83d\udce6 crowdsecurity/sshd : updated INFO [ 0000 ] Upgraded 1 items INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective.","title":"Upgrading installed parsers"},{"location":"user_guide/configurations_management/parsers.html#monitoring-parsers","text":"$ sudo cscli parsers inspect crowdsecurity/sshd-logs Parsers inspect will give you detailed information about a given parser, including versioning information and runtime metrics (fetched from prometheus). cscli parsers inspect example $ sudo cscli parsers inspect crowdsecurity/sshd-logs type: parsers stage: s01-parse name: crowdsecurity/sshd-logs filename: sshd-logs.yaml description: Parse openSSH logs author: crowdsecurity belongs_to_collections: - crowdsecurity/sshd remote_path: parsers/s01-parse/crowdsecurity/sshd-logs.yaml version: \"0.1\" local_path: /etc/crowdsec/parsers/s01-parse/sshd-logs.yaml localversion: \"0.1\" localhash: ecd40cb8cd95e2bad398824ab67b479362cdbf0e1598b8833e2f537ae3ce2f93 installed: true downloaded: true uptodate: true tainted: false local: false Current metrics : - ( Parser ) crowdsecurity/sshd-logs: +-------------------+-------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +-------------------+-------+--------+----------+ | /var/log/auth.log | 94138 | 42404 | 51734 | +-------------------+-------+--------+----------+ ## Reference documentation [Link to parsers reference documentation](/Crowdsec/v1/references/parsers/)","title":"Monitoring parsers"},{"location":"user_guide/configurations_management/scenarios.html","text":"Crowdsec Hub allows you to find needed scenarios. Installing scenarios \u00b6 $ sudo cscli scenarios install crowdsecurity/http-bf-wordpress_bf cscli scenarios install example $ sudo cscli scenarios install crowdsecurity/http-bf-wordpress_bf INFO [ 0000 ] crowdsecurity/http-bf-wordpress_bf : OK INFO [ 0000 ] Enabled scenarios : crowdsecurity/http-bf-wordpress_bf INFO [ 0000 ] Enabled crowdsecurity/http-bf-wordpress_bf INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. $ systemctl reload crowdsec Listing installed scenarios \u00b6 sudo cscli scenarios list Scenarios are yaml files in /etc/crowdsec/scenarios/ . cscli scenarios list example $ sudo cscli scenarios list --------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH --------------------------------------------------------------------------------------------------------------------------- crowdsecurity/ssh-bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/ssh-bf.yaml crowdsecurity/http-bf-wordpress_bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/http-bf-wordpress_bf.yaml crowdsecurity/http-crawl-non_statics \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-crawl-non_statics.yaml crowdsecurity/http-probing \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/http-probing.yaml crowdsecurity/http-sensitive-files \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-sensitive-files.yaml crowdsecurity/http-bad-user-agent \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-bad-user-agent.yaml crowdsecurity/http-path-traversal-probing \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-path-traversal-probing.yaml crowdsecurity/http-sqli-probing \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-sqli-probing.yaml crowdsecurity/http-backdoors-attempts \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-backdoors-attempts.yaml crowdsecurity/http-xss-probing \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-xss-probing.yaml --------------------------------------------------------------------------------------------------------------------------- Upgrading installed scenarios \u00b6 $ sudo cscli scenarios upgrade crowdsecurity/ssh-bf Scenarios upgrade allows you to upgrade an existing scenario to the latest version. cscli scenarios upgrade example $ sudo cscli scenarios upgrade crowdsecurity/ssh-bf INFO [ 0000 ] crowdsecurity/ssh-bf : up-to-date WARN [ 0000 ] crowdsecurity/ssh-bf : overwrite INFO [ 0000 ] \ud83d\udce6 crowdsecurity/ssh-bf : updated INFO [ 0000 ] Upgraded 1 items INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. Monitoring scenarios \u00b6 $ sudo cscli scenarios inspect crowdsecurity/ssh-bf Scenarios inspect will give you detailed information about a given scenario, including versioning information and runtime metrics (fetched from prometheus). cscli scenarios inspect example $ sudo cscli scenarios inspect crowdsecurity/ssh-bf type: scenarios name: crowdsecurity/ssh-bf filename: ssh-bf.yaml description: Detect ssh bruteforce author: crowdsecurity references: - http://wikipedia.com/ssh-bf-is-bad belongs_to_collections: - crowdsecurity/sshd remote_path: scenarios/crowdsecurity/ssh-bf.yaml version: \"0.1\" local_path: /etc/crowdsec/scenarios/ssh-bf.yaml localversion: \"0.1\" localhash: 4441dcff07020f6690d998b7101e642359ba405c2abb83565bbbdcee36de280f installed: true downloaded: true uptodate: true tainted: false local: false Current metrics : - ( Scenario ) crowdsecurity/ssh-bf: +---------------+-----------+--------------+--------+---------+ | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +---------------+-----------+--------------+--------+---------+ | 14 | 5700 | 7987 | 42572 | 2273 | +---------------+-----------+--------------+--------+---------+ ## Reference documentation [Link to scenarios reference documentation](/Crowdsec/v1/references/scenarios/)","title":"Scenarios"},{"location":"user_guide/configurations_management/scenarios.html#installing-scenarios","text":"$ sudo cscli scenarios install crowdsecurity/http-bf-wordpress_bf cscli scenarios install example $ sudo cscli scenarios install crowdsecurity/http-bf-wordpress_bf INFO [ 0000 ] crowdsecurity/http-bf-wordpress_bf : OK INFO [ 0000 ] Enabled scenarios : crowdsecurity/http-bf-wordpress_bf INFO [ 0000 ] Enabled crowdsecurity/http-bf-wordpress_bf INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective. $ systemctl reload crowdsec","title":"Installing scenarios"},{"location":"user_guide/configurations_management/scenarios.html#listing-installed-scenarios","text":"sudo cscli scenarios list Scenarios are yaml files in /etc/crowdsec/scenarios/ . cscli scenarios list example $ sudo cscli scenarios list --------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH --------------------------------------------------------------------------------------------------------------------------- crowdsecurity/ssh-bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/ssh-bf.yaml crowdsecurity/http-bf-wordpress_bf \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/http-bf-wordpress_bf.yaml crowdsecurity/http-crawl-non_statics \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-crawl-non_statics.yaml crowdsecurity/http-probing \u2714\ufe0f enabled 0 .1 /etc/crowdsec/scenarios/http-probing.yaml crowdsecurity/http-sensitive-files \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-sensitive-files.yaml crowdsecurity/http-bad-user-agent \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-bad-user-agent.yaml crowdsecurity/http-path-traversal-probing \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-path-traversal-probing.yaml crowdsecurity/http-sqli-probing \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-sqli-probing.yaml crowdsecurity/http-backdoors-attempts \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-backdoors-attempts.yaml crowdsecurity/http-xss-probing \u2714\ufe0f enabled 0 .2 /etc/crowdsec/scenarios/http-xss-probing.yaml ---------------------------------------------------------------------------------------------------------------------------","title":"Listing installed scenarios"},{"location":"user_guide/configurations_management/scenarios.html#upgrading-installed-scenarios","text":"$ sudo cscli scenarios upgrade crowdsecurity/ssh-bf Scenarios upgrade allows you to upgrade an existing scenario to the latest version. cscli scenarios upgrade example $ sudo cscli scenarios upgrade crowdsecurity/ssh-bf INFO [ 0000 ] crowdsecurity/ssh-bf : up-to-date WARN [ 0000 ] crowdsecurity/ssh-bf : overwrite INFO [ 0000 ] \ud83d\udce6 crowdsecurity/ssh-bf : updated INFO [ 0000 ] Upgraded 1 items INFO [ 0000 ] Run 'systemctl reload crowdsec' for the new configuration to be effective.","title":"Upgrading installed scenarios"},{"location":"user_guide/configurations_management/scenarios.html#monitoring-scenarios","text":"$ sudo cscli scenarios inspect crowdsecurity/ssh-bf Scenarios inspect will give you detailed information about a given scenario, including versioning information and runtime metrics (fetched from prometheus). cscli scenarios inspect example $ sudo cscli scenarios inspect crowdsecurity/ssh-bf type: scenarios name: crowdsecurity/ssh-bf filename: ssh-bf.yaml description: Detect ssh bruteforce author: crowdsecurity references: - http://wikipedia.com/ssh-bf-is-bad belongs_to_collections: - crowdsecurity/sshd remote_path: scenarios/crowdsecurity/ssh-bf.yaml version: \"0.1\" local_path: /etc/crowdsec/scenarios/ssh-bf.yaml localversion: \"0.1\" localhash: 4441dcff07020f6690d998b7101e642359ba405c2abb83565bbbdcee36de280f installed: true downloaded: true uptodate: true tainted: false local: false Current metrics : - ( Scenario ) crowdsecurity/ssh-bf: +---------------+-----------+--------------+--------+---------+ | CURRENT COUNT | OVERFLOWS | INSTANCIATED | POURED | EXPIRED | +---------------+-----------+--------------+--------+---------+ | 14 | 5700 | 7987 | 42572 | 2273 | +---------------+-----------+--------------+--------+---------+ ## Reference documentation [Link to scenarios reference documentation](/Crowdsec/v1/references/scenarios/)","title":"Monitoring scenarios"},{"location":"user_guide/data_sources/acquisition.html","text":"Introduction \u00b6 Data sources, are in charge of dictating to crowdsec-agent which source should be read. Data sources are configured via /etc/crowdsec/acquis.yaml or via the directory specified in acquisition_dir . Info Please note that the /etc/crowdsec/acquis.yaml should be auto generated by the wizard in most case. Acquisition configuration \u00b6 The acquisition configuration specifies lists of logs sources that crowdsec-agent will ingest and feed to parsers. Acquisition provides at least two information about a given log : a source (a path to a file, a journalctl filter, a cloudwatch group/stream etc.) a type , given in the form of a label Extra parameters are as well supported : a name that will ease tracking and logs readability a log_level to individually configure the log level of a given source The type label is crucial as it's later used in the process to determine which parser(s) can handle lines coming from this source. Acquisition can be found in /etc/crowdsec/acquis.yaml , for example : Acquisition example source : file log_level : debug filenames : - /var/log/nginx/access-*.log - /var/log/nginx/error.log labels : type : nginx --- source : journalctl journalctl_filter : - \"_SYSTEMD_UNIT=ssh.service\" labels : type : syslog --- source : cloudwatch group_name : /aws/group/name aws_profile : production labels : type : syslog Testing and viewing acquisition \u00b6 At startup \u00b6 At startup, you will see the monitored files in /var/log/crowdsec.log : ... INFO[23-11-2020 15:21:17] [file datasource] opening file '/tmp/test.log' WARN[23-11-2020 15:21:17] [file datasource] no results for /tmp/ratata.log INFO[23-11-2020 15:21:17] [journald datasource] Configured with filters : [--follow _SYSTEMD_UNIT=ssh.service] ... At runtime \u00b6 cscli allows you to view crowdsec-agent metrics info via the metrics command. This allows you to see how many lines are coming from each source, and if they are parsed correctly. You can see those metrics with the following command: sudo cscli metrics cscli metrics example $ sudo cscli metrics ... ... INFO [ 0000 ] Acquisition Metrics: +--------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +--------------------------------------+------------+--------------+----------------+------------------------+ | /tmp/test.log | 10 | 10 | - | 11 | | journalctl-_SYSTEMD_UNIT = ssh.service | 36 | 12 | 24 | 17 | +--------------------------------------+------------+--------------+----------------+------------------------+ ... ... Info All these metrics are actually coming from crowdsec-agent's prometheus agent. See prometheus directly for more insights. Reference documentation \u00b6 Link to acquisition reference documentation","title":"Introduction"},{"location":"user_guide/data_sources/acquisition.html#introduction","text":"Data sources, are in charge of dictating to crowdsec-agent which source should be read. Data sources are configured via /etc/crowdsec/acquis.yaml or via the directory specified in acquisition_dir . Info Please note that the /etc/crowdsec/acquis.yaml should be auto generated by the wizard in most case.","title":"Introduction"},{"location":"user_guide/data_sources/acquisition.html#acquisition-configuration","text":"The acquisition configuration specifies lists of logs sources that crowdsec-agent will ingest and feed to parsers. Acquisition provides at least two information about a given log : a source (a path to a file, a journalctl filter, a cloudwatch group/stream etc.) a type , given in the form of a label Extra parameters are as well supported : a name that will ease tracking and logs readability a log_level to individually configure the log level of a given source The type label is crucial as it's later used in the process to determine which parser(s) can handle lines coming from this source. Acquisition can be found in /etc/crowdsec/acquis.yaml , for example : Acquisition example source : file log_level : debug filenames : - /var/log/nginx/access-*.log - /var/log/nginx/error.log labels : type : nginx --- source : journalctl journalctl_filter : - \"_SYSTEMD_UNIT=ssh.service\" labels : type : syslog --- source : cloudwatch group_name : /aws/group/name aws_profile : production labels : type : syslog","title":"Acquisition configuration"},{"location":"user_guide/data_sources/acquisition.html#testing-and-viewing-acquisition","text":"","title":"Testing and viewing acquisition"},{"location":"user_guide/data_sources/acquisition.html#at-startup","text":"At startup, you will see the monitored files in /var/log/crowdsec.log : ... INFO[23-11-2020 15:21:17] [file datasource] opening file '/tmp/test.log' WARN[23-11-2020 15:21:17] [file datasource] no results for /tmp/ratata.log INFO[23-11-2020 15:21:17] [journald datasource] Configured with filters : [--follow _SYSTEMD_UNIT=ssh.service] ...","title":"At startup"},{"location":"user_guide/data_sources/acquisition.html#at-runtime","text":"cscli allows you to view crowdsec-agent metrics info via the metrics command. This allows you to see how many lines are coming from each source, and if they are parsed correctly. You can see those metrics with the following command: sudo cscli metrics cscli metrics example $ sudo cscli metrics ... ... INFO [ 0000 ] Acquisition Metrics: +--------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +--------------------------------------+------------+--------------+----------------+------------------------+ | /tmp/test.log | 10 | 10 | - | 11 | | journalctl-_SYSTEMD_UNIT = ssh.service | 36 | 12 | 24 | 17 | +--------------------------------------+------------+--------------+----------------+------------------------+ ... ... Info All these metrics are actually coming from crowdsec-agent's prometheus agent. See prometheus directly for more insights.","title":"At runtime"},{"location":"user_guide/data_sources/acquisition.html#reference-documentation","text":"Link to acquisition reference documentation","title":"Reference documentation"},{"location":"user_guide/data_sources/cloudwatch.html","text":"Cloudwatch acquisition \u00b6 This module allows crowdsec-agent to acquire logs from AWS's cloudwatch service, in one-shot and streaming mode. Configuration \u00b6 To monitor a given stream within a group : source : cloudwatch group_name : /aws/my/group/ stream_name : 'given_stream' aws_profile : monitoring aws_config_dir : /home/user/.aws/ labels : type : apigateway To monitor streams matching regexp within a group : source : cloudwatch group_name : /aws/my/group/ stream_regexp : '^stream[0-9]+$' aws_profile : monitoring labels : type : apigateway Look at the configuration parameters to view all supported options. Configuration parameters \u00b6 group_name \u00b6 Name of the group to monitor, exact match. stream_regexp \u00b6 A RE2 expression that will restrict streams within the group that will be monitored. stream_name \u00b6 Name of stream to monitor, exact match. *_limit \u00b6 describelogstreams_limit : control the pagination size of describelogstreams calls (default: 1000 ) getlogeventspages_limit : control the pagination size of getlogeventspages calls (default: 1000 ) *_interval \u00b6 note : AWS SDK allows to identify streams according to the timestamp of the latest even within, and this is what we rely on. poll_new_stream_interval : frequency to poll for new stream within given group (default 10s ) max_stream_age : open only streams for which last event is at most this age (default 5m ) poll_stream_interval : frequency to poll for new events within given group (default 10s ) stream_read_timeout : stop reading a given stream when no new events have been seen for this duration (default 10m ) prepend_cloudwatch_timestamp \u00b6 When set to true (default: false ), prepend the cloudwatch event timestamp to the generated log string. This is intended for cases where you log itself wouldn't contain timestamp. aws_profile \u00b6 The aws profile to use to poll cloudwatch, relies on your ~/.aws/config/ . aws_config_dir \u00b6 The path to your ~/.aws/ , defaults to /root/.aws . DSN and command-line \u00b6 cloudwatch implements a very approximative DSN, as follows : cloudwatch:///your/group/path:stream_name?[args] Supported args are : log_level : set log level of parser profile : set aws profile name start_date / end_date : provide start and end date limits for events, see supported formats backlog : provide a duration, events from now()-duration till now() will be read Notes \u00b6 This data source lacks unit tests because mocking aws sdk is fastidious.","title":"Cloudwatch"},{"location":"user_guide/data_sources/cloudwatch.html#cloudwatch-acquisition","text":"This module allows crowdsec-agent to acquire logs from AWS's cloudwatch service, in one-shot and streaming mode.","title":"Cloudwatch acquisition"},{"location":"user_guide/data_sources/cloudwatch.html#configuration","text":"To monitor a given stream within a group : source : cloudwatch group_name : /aws/my/group/ stream_name : 'given_stream' aws_profile : monitoring aws_config_dir : /home/user/.aws/ labels : type : apigateway To monitor streams matching regexp within a group : source : cloudwatch group_name : /aws/my/group/ stream_regexp : '^stream[0-9]+$' aws_profile : monitoring labels : type : apigateway Look at the configuration parameters to view all supported options.","title":"Configuration"},{"location":"user_guide/data_sources/cloudwatch.html#configuration-parameters","text":"","title":"Configuration parameters"},{"location":"user_guide/data_sources/cloudwatch.html#group_name","text":"Name of the group to monitor, exact match.","title":"group_name"},{"location":"user_guide/data_sources/cloudwatch.html#stream_regexp","text":"A RE2 expression that will restrict streams within the group that will be monitored.","title":"stream_regexp"},{"location":"user_guide/data_sources/cloudwatch.html#stream_name","text":"Name of stream to monitor, exact match.","title":"stream_name"},{"location":"user_guide/data_sources/cloudwatch.html#_limit","text":"describelogstreams_limit : control the pagination size of describelogstreams calls (default: 1000 ) getlogeventspages_limit : control the pagination size of getlogeventspages calls (default: 1000 )","title":"*_limit"},{"location":"user_guide/data_sources/cloudwatch.html#_interval","text":"note : AWS SDK allows to identify streams according to the timestamp of the latest even within, and this is what we rely on. poll_new_stream_interval : frequency to poll for new stream within given group (default 10s ) max_stream_age : open only streams for which last event is at most this age (default 5m ) poll_stream_interval : frequency to poll for new events within given group (default 10s ) stream_read_timeout : stop reading a given stream when no new events have been seen for this duration (default 10m )","title":"*_interval"},{"location":"user_guide/data_sources/cloudwatch.html#prepend_cloudwatch_timestamp","text":"When set to true (default: false ), prepend the cloudwatch event timestamp to the generated log string. This is intended for cases where you log itself wouldn't contain timestamp.","title":"prepend_cloudwatch_timestamp"},{"location":"user_guide/data_sources/cloudwatch.html#aws_profile","text":"The aws profile to use to poll cloudwatch, relies on your ~/.aws/config/ .","title":"aws_profile"},{"location":"user_guide/data_sources/cloudwatch.html#aws_config_dir","text":"The path to your ~/.aws/ , defaults to /root/.aws .","title":"aws_config_dir"},{"location":"user_guide/data_sources/cloudwatch.html#dsn-and-command-line","text":"cloudwatch implements a very approximative DSN, as follows : cloudwatch:///your/group/path:stream_name?[args] Supported args are : log_level : set log level of parser profile : set aws profile name start_date / end_date : provide start and end date limits for events, see supported formats backlog : provide a duration, events from now()-duration till now() will be read","title":"DSN and command-line"},{"location":"user_guide/data_sources/cloudwatch.html#notes","text":"This data source lacks unit tests because mocking aws sdk is fastidious.","title":"Notes"},{"location":"user_guide/data_sources/file.html","text":"File Acquisition \u00b6 This module allows crowdsec-agent to acquire logs from text files (in one-shot and streaming mode), and GZ files in one-shot mode. Configuration Parameters \u00b6 filename : A single path to a file to tail. Globbing is supported. Required if filenames is not provided. filenames : A list of path to files to tail. Globbing is supported. Required if filename is not provided. force_inotify : If set to true , force an inotify watch on the log files folder, even if there is no log in it (default: false ) source : Must be file A basic configuration is as follows: source : file filenames : - /tmp/foo/*.log - /var/log/syslog labels : type : syslog DSN and command-line \u00b6 This module supports acquisition directly from the command line, to read files in one shot. A single file URI is accepted with the -dsn parameter, but globbing is supported for multiple files: crowdsec -type syslog -dsn file:///var/log/*.log You can specify the log_level parameter to change the log level for the acquisition : crowdsec -type syslog -dsn file:///var/log/*.log?log_level=info Notes \u00b6 By default, if a glob pattern does not match any files in an existing directory, this directory will not be watched for new files (ie, /var/log/nginx/*.log does not match, but /var/log/nginx/ exists). You can override this behaviour with the force_inotify parameter, which will put a watch on the directory.","title":"Files"},{"location":"user_guide/data_sources/file.html#file-acquisition","text":"This module allows crowdsec-agent to acquire logs from text files (in one-shot and streaming mode), and GZ files in one-shot mode.","title":"File Acquisition"},{"location":"user_guide/data_sources/file.html#configuration-parameters","text":"filename : A single path to a file to tail. Globbing is supported. Required if filenames is not provided. filenames : A list of path to files to tail. Globbing is supported. Required if filename is not provided. force_inotify : If set to true , force an inotify watch on the log files folder, even if there is no log in it (default: false ) source : Must be file A basic configuration is as follows: source : file filenames : - /tmp/foo/*.log - /var/log/syslog labels : type : syslog","title":"Configuration Parameters"},{"location":"user_guide/data_sources/file.html#dsn-and-command-line","text":"This module supports acquisition directly from the command line, to read files in one shot. A single file URI is accepted with the -dsn parameter, but globbing is supported for multiple files: crowdsec -type syslog -dsn file:///var/log/*.log You can specify the log_level parameter to change the log level for the acquisition : crowdsec -type syslog -dsn file:///var/log/*.log?log_level=info","title":"DSN and command-line"},{"location":"user_guide/data_sources/file.html#notes","text":"By default, if a glob pattern does not match any files in an existing directory, this directory will not be watched for new files (ie, /var/log/nginx/*.log does not match, but /var/log/nginx/ exists). You can override this behaviour with the force_inotify parameter, which will put a watch on the directory.","title":"Notes"},{"location":"user_guide/data_sources/journalctl.html","text":"Journalctl Acquisition \u00b6 This module allows crowdsec-agent to acquire logs from journalctl files in one-shot and streaming mode. Configuration Parameters \u00b6 journalctl_filters: A list of journalctl filters. This is mandatory. source: Must be journalctl Basic configuration example: source : journalctl journalctl_filters : - _SYSTEMD_UNIT=ssh.service DSN and command-line \u00b6 This module supports acquisition directly from the command line, to read journalctl logs in one shot. A 'pseudo DSN' must be provided: crowdsec -type syslog -dsn journalctl://filters=_SYSTEMD_UNIT=ssh.service&filters=_UID=42 You can specify the log_level parameter to change the log level for the acquisition : crowdsec -type syslog -dsn journalctl://filters=MY_FILTER&filters=MY_OTHER_FILTER&log_level=debug","title":"Journalctl"},{"location":"user_guide/data_sources/journalctl.html#journalctl-acquisition","text":"This module allows crowdsec-agent to acquire logs from journalctl files in one-shot and streaming mode.","title":"Journalctl Acquisition"},{"location":"user_guide/data_sources/journalctl.html#configuration-parameters","text":"journalctl_filters: A list of journalctl filters. This is mandatory. source: Must be journalctl Basic configuration example: source : journalctl journalctl_filters : - _SYSTEMD_UNIT=ssh.service","title":"Configuration Parameters"},{"location":"user_guide/data_sources/journalctl.html#dsn-and-command-line","text":"This module supports acquisition directly from the command line, to read journalctl logs in one shot. A 'pseudo DSN' must be provided: crowdsec -type syslog -dsn journalctl://filters=_SYSTEMD_UNIT=ssh.service&filters=_UID=42 You can specify the log_level parameter to change the log level for the acquisition : crowdsec -type syslog -dsn journalctl://filters=MY_FILTER&filters=MY_OTHER_FILTER&log_level=debug","title":"DSN and command-line"},{"location":"user_guide/data_sources/syslog.html","text":"Syslog Acquisition \u00b6 This module allows crowdsec to expose a syslog server, and ingest logs directly from another syslog server (or any software that knows how to forward logs with syslog). Only UDP is supported. Syslog messages must conform either to RFC3164 or RFC5424 , and can be up to 2048 bytes long by default (this value is configurable). Configuration Parameters \u00b6 listen_addr : Address on which the syslog will listen. Defaults to 127.0.0.1. listen_port : UDP port used by the syslog server. Defaults to 514. max_message_len : Maximum length of a syslog message (including priority and facility). Defaults to 2048. source : Must be syslog A basic configuration is as follows: source : syslog listen_addr : 127.0.0.1 listen_port : 4242 labels : type : syslog DSN and command-line \u00b6 This module does not support command-line acquisition.","title":"Syslog"},{"location":"user_guide/data_sources/syslog.html#syslog-acquisition","text":"This module allows crowdsec to expose a syslog server, and ingest logs directly from another syslog server (or any software that knows how to forward logs with syslog). Only UDP is supported. Syslog messages must conform either to RFC3164 or RFC5424 , and can be up to 2048 bytes long by default (this value is configurable).","title":"Syslog Acquisition"},{"location":"user_guide/data_sources/syslog.html#configuration-parameters","text":"listen_addr : Address on which the syslog will listen. Defaults to 127.0.0.1. listen_port : UDP port used by the syslog server. Defaults to 514. max_message_len : Maximum length of a syslog message (including priority and facility). Defaults to 2048. source : Must be syslog A basic configuration is as follows: source : syslog listen_addr : 127.0.0.1 listen_port : 4242 labels : type : syslog","title":"Configuration Parameters"},{"location":"user_guide/data_sources/syslog.html#dsn-and-command-line","text":"This module does not support command-line acquisition.","title":"DSN and command-line"},{"location":"write_configurations/acquisition.html","text":"Write the acquisition file (optional for test) \u00b6 In order for your log to be processed by the good parser, it must match the filter that you will configure in your parser file. The filters of the parsers in the first ( s00-raw ) stage will usually check evt.Line.Labels.type , which is the label of your acquisition file : With an acquisition file like this : filename : /path/to/log/file.log labels : type : my_program The log line will enter the parsing pipeline with evt.Line.Labels.type set to my_program The parsers in the 1st stage ( s00-raw ) are dealing with the raw format, and the program name will end up in evt.Parsed.program When the log line arrive the main parsing stage ( s01-parse ), evt.Parsed.program will be my_program For example, this file line(s) : filename : /var/log/nginx/access.log labels : type : nginx will be read by this parser : filter : \"evt.Parsed.program startsWith 'nginx'\" onsuccess : next_stage ...","title":"Acquisition"},{"location":"write_configurations/acquisition.html#write-the-acquisition-file-optional-for-test","text":"In order for your log to be processed by the good parser, it must match the filter that you will configure in your parser file. The filters of the parsers in the first ( s00-raw ) stage will usually check evt.Line.Labels.type , which is the label of your acquisition file : With an acquisition file like this : filename : /path/to/log/file.log labels : type : my_program The log line will enter the parsing pipeline with evt.Line.Labels.type set to my_program The parsers in the 1st stage ( s00-raw ) are dealing with the raw format, and the program name will end up in evt.Parsed.program When the log line arrive the main parsing stage ( s01-parse ), evt.Parsed.program will be my_program For example, this file line(s) : filename : /var/log/nginx/access.log labels : type : nginx will be read by this parser : filter : \"evt.Parsed.program startsWith 'nginx'\" onsuccess : next_stage ...","title":"Write the acquisition file (optional for test)"},{"location":"write_configurations/parsers.html","text":"Writing Crowdsec-agent parser \u00b6 Parser dependency The crowdsecurity/syslog-logs parsers is needed by the core parsing engine. Deletion or modification of this could result of crowdsec-agent being unable to parse logs, so this should be done very carefully. In the current example, we'll write a parser for the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new parsers. Exported fields You can view some of the extracted fields of existing parsers in the Hub Base parser file \u00b6 The most simple parser can be defined as : filter : 1 == 1 debug : true onsuccess : next_stage name : me/myparser description : a cool parser for my service grok : #our grok pattern : capture .* pattern : ^%{DATA:some_data}$ #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes a filter : if the expression is true , the event will enter the parser, otherwise, it won't a onsuccess : defines what happens when the event was successfully parsed : shall we continue ? shall we move to next stage ? etc. a name & a description some statics that will modify the event a debug flag that allows to enable local debugging information. We are going to use to following sample log as an example : May 11 16 :23:43 sd-126005 kernel: [ 47615895 .771900 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x00 PREC = 0x00 TTL = 245 ID = 51006 PROTO = TCP SPT = 45225 DPT = 8888 WINDOW = 1024 RES = 0x00 SYN URGP = 0 May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0 Trying our mock parser \u00b6 Warning Your yaml file must be in the config/parsers/s01-parse/ directory. For example it can be ~/crowdsec-v0.0.19/tests/config/parsers/s01-parse/myparser.yaml , or /etc/crowdsec/parsers/s01-parse/myparser.yaml . The stage directory might not exist, don't forget to create it. (deployment is assuming you're using a test environment ) Setting up our new parser : if config/parsers/s01-parse doesn't exist, create it: cd crowdsec-v0.X.Y/tests mkdir -p config/parsers/s01-parse Then copy your parser in config/parsers/s01-parse and try it: cp myparser.yaml config/parsers/s01-parse/ ./crowdsec -c ./dev.yaml -dsn file://x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 15 :48:28 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] + Grok '' returned 1 entries to merge in Parsed id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] .Parsed [ 'some_data' ] = 'May 11 16:23:41 sd-126005 kernel: [47615893.721616] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=54555 PROTO=TCP SPT=45225 DPT=8080 WINDOW=1024 RES=0x00 SYN URGP=0 ' id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] + Processing 1 statics id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] Event leaving node : ok id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] move Event from stage s01-parse to s02-enrich id = dark-water name = me/myparser stage = s01-parse ... We can see our \"mock\" parser is working, let's see what happened : The event enter the node The filter returned true ( 1 == 1 ) so the event will be processed Our grok pattern (just a .* capture) \"worked\" and captured data (the whole line actually) The grok captures (under the name \"some_data\") are merged into the .Parsed map of the event The statics section is processed, and .Parsed[is_my_service] is set to yes The event leaves the parser successfully, and because \"next_stage\" is set, we move the event to the next \"stage\" Writing the GROK pattern \u00b6 We are going to write a parser for iptables logs, they look like this : May 11 16:23:43 sd-126005 kernel: [47615895.771900] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=51006 PROTO=TCP SPT=45225 DPT=8888 WINDOW=1024 RES=0x00 SYN URGP=0 May 11 16:23:50 sd-126005 kernel: [47615902.763137] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=44.44.44.44 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=49 ID=17451 DF PROTO=TCP SPT=53668 DPT=80 WINDOW=14600 RES=0x00 SYN URGP=0 Using an online grok debugger or an online regex debugger , we come up with the following grok pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* Warning Check if the pattern you are looking for is not already present in patterns configuration . Test our new pattern \u00b6 Now, let's integrate our GROK pattern within our YAML : #let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"1 == 1\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes ./crowdsec -c ./dev.yaml -dsn file://x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 16 :18:58 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8080' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '99.99.99.99' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Processing 1 statics id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] Event leaving node : ok id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] move Event from stage s01-parse to s02-enrich id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse ... What changed ? We can now see that the fragment captured by the GROK pattern are merged in the Parsed array ! We now have parsed data, only a few more changes and we will be done :) Finalizing our parser \u00b6 #let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"evt.Parsed.program == 'kernel'\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - meta : log_type value : iptables_drop - meta : service expression : \"evt.Parsed.proto == 'TCP' ? 'tcp' : 'unknown'\" - meta : source_ip expression : \"evt.Parsed.src_ip\" filter \u00b6 We changed the filter to correctly filter on the program name. In the current example, our logs are produced by the kernel (netfilter), and thus the program is kernel : tail -f /var/log/kern.log May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0 statics \u00b6 We are setting various entries to static or dynamic values to give \"context\" to the log : .Meta.log_type is set to iptables_drop (so that we later can filter events coming from this) .Meta.source_ip is set the the source ip captured .Parsed.src_ip .Meta.service is set the the result of an expression that relies on the GROK output ( proto field) Look into dedicated statics documentation to know more about its possibilities. Testing our finalized parser \u00b6 ./crowdsec -c ./dev.yaml -dsn file://x.log -type kernel Expected output ... DEBU [ 0000 ] Event entering node id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] eval ( TRUE ) 'evt.Parsed.program == ' kernel '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8118' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Processing 3 statics id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Meta [ log_type ] = 'iptables_drop' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Meta [ service ] = 'tcp' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Meta [ source_ip ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] Event leaving node : ok id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] move Event from stage s01-parse to s02-enrich id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse ... Closing word \u00b6 We have now a fully functional parser for crowdsec-agent ! We can either deploy it to our production systems to do stuff, or even better, contribute to the Crowdsec Hub ! If you want to know more about directives and possibilities, take a look at the parser reference documentation !","title":"Parsers"},{"location":"write_configurations/parsers.html#writing-crowdsec-agent-parser","text":"Parser dependency The crowdsecurity/syslog-logs parsers is needed by the core parsing engine. Deletion or modification of this could result of crowdsec-agent being unable to parse logs, so this should be done very carefully. In the current example, we'll write a parser for the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new parsers. Exported fields You can view some of the extracted fields of existing parsers in the Hub","title":"Writing Crowdsec-agent parser"},{"location":"write_configurations/parsers.html#base-parser-file","text":"The most simple parser can be defined as : filter : 1 == 1 debug : true onsuccess : next_stage name : me/myparser description : a cool parser for my service grok : #our grok pattern : capture .* pattern : ^%{DATA:some_data}$ #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes a filter : if the expression is true , the event will enter the parser, otherwise, it won't a onsuccess : defines what happens when the event was successfully parsed : shall we continue ? shall we move to next stage ? etc. a name & a description some statics that will modify the event a debug flag that allows to enable local debugging information. We are going to use to following sample log as an example : May 11 16 :23:43 sd-126005 kernel: [ 47615895 .771900 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x00 PREC = 0x00 TTL = 245 ID = 51006 PROTO = TCP SPT = 45225 DPT = 8888 WINDOW = 1024 RES = 0x00 SYN URGP = 0 May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0","title":"Base parser file"},{"location":"write_configurations/parsers.html#trying-our-mock-parser","text":"Warning Your yaml file must be in the config/parsers/s01-parse/ directory. For example it can be ~/crowdsec-v0.0.19/tests/config/parsers/s01-parse/myparser.yaml , or /etc/crowdsec/parsers/s01-parse/myparser.yaml . The stage directory might not exist, don't forget to create it. (deployment is assuming you're using a test environment ) Setting up our new parser : if config/parsers/s01-parse doesn't exist, create it: cd crowdsec-v0.X.Y/tests mkdir -p config/parsers/s01-parse Then copy your parser in config/parsers/s01-parse and try it: cp myparser.yaml config/parsers/s01-parse/ ./crowdsec -c ./dev.yaml -dsn file://x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 15 :48:28 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] + Grok '' returned 1 entries to merge in Parsed id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] .Parsed [ 'some_data' ] = 'May 11 16:23:41 sd-126005 kernel: [47615893.721616] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=54555 PROTO=TCP SPT=45225 DPT=8080 WINDOW=1024 RES=0x00 SYN URGP=0 ' id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] + Processing 1 statics id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] Event leaving node : ok id = dark-water name = me/myparser stage = s01-parse DEBU [ 0000 ] move Event from stage s01-parse to s02-enrich id = dark-water name = me/myparser stage = s01-parse ... We can see our \"mock\" parser is working, let's see what happened : The event enter the node The filter returned true ( 1 == 1 ) so the event will be processed Our grok pattern (just a .* capture) \"worked\" and captured data (the whole line actually) The grok captures (under the name \"some_data\") are merged into the .Parsed map of the event The statics section is processed, and .Parsed[is_my_service] is set to yes The event leaves the parser successfully, and because \"next_stage\" is set, we move the event to the next \"stage\"","title":"Trying our mock parser"},{"location":"write_configurations/parsers.html#writing-the-grok-pattern","text":"We are going to write a parser for iptables logs, they look like this : May 11 16:23:43 sd-126005 kernel: [47615895.771900] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=51006 PROTO=TCP SPT=45225 DPT=8888 WINDOW=1024 RES=0x00 SYN URGP=0 May 11 16:23:50 sd-126005 kernel: [47615902.763137] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=44.44.44.44 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=49 ID=17451 DF PROTO=TCP SPT=53668 DPT=80 WINDOW=14600 RES=0x00 SYN URGP=0 Using an online grok debugger or an online regex debugger , we come up with the following grok pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* Warning Check if the pattern you are looking for is not already present in patterns configuration .","title":"Writing the GROK pattern"},{"location":"write_configurations/parsers.html#test-our-new-pattern","text":"Now, let's integrate our GROK pattern within our YAML : #let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"1 == 1\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes ./crowdsec -c ./dev.yaml -dsn file://x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 16 :18:58 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8080' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '99.99.99.99' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Processing 1 statics id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] Event leaving node : ok id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] move Event from stage s01-parse to s02-enrich id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parse ... What changed ? We can now see that the fragment captured by the GROK pattern are merged in the Parsed array ! We now have parsed data, only a few more changes and we will be done :)","title":"Test our new pattern"},{"location":"write_configurations/parsers.html#finalizing-our-parser","text":"#let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"evt.Parsed.program == 'kernel'\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - meta : log_type value : iptables_drop - meta : service expression : \"evt.Parsed.proto == 'TCP' ? 'tcp' : 'unknown'\" - meta : source_ip expression : \"evt.Parsed.src_ip\"","title":"Finalizing our parser"},{"location":"write_configurations/parsers.html#filter","text":"We changed the filter to correctly filter on the program name. In the current example, our logs are produced by the kernel (netfilter), and thus the program is kernel : tail -f /var/log/kern.log May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0","title":"filter"},{"location":"write_configurations/parsers.html#statics","text":"We are setting various entries to static or dynamic values to give \"context\" to the log : .Meta.log_type is set to iptables_drop (so that we later can filter events coming from this) .Meta.source_ip is set the the source ip captured .Parsed.src_ip .Meta.service is set the the result of an expression that relies on the GROK output ( proto field) Look into dedicated statics documentation to know more about its possibilities.","title":"statics"},{"location":"write_configurations/parsers.html#testing-our-finalized-parser","text":"./crowdsec -c ./dev.yaml -dsn file://x.log -type kernel Expected output ... DEBU [ 0000 ] Event entering node id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] eval ( TRUE ) 'evt.Parsed.program == ' kernel '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8118' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] + Processing 3 statics id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Meta [ log_type ] = 'iptables_drop' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Meta [ service ] = 'tcp' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] .Meta [ source_ip ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] Event leaving node : ok id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse DEBU [ 0000 ] move Event from stage s01-parse to s02-enrich id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parse ...","title":"Testing our finalized parser"},{"location":"write_configurations/parsers.html#closing-word","text":"We have now a fully functional parser for crowdsec-agent ! We can either deploy it to our production systems to do stuff, or even better, contribute to the Crowdsec Hub ! If you want to know more about directives and possibilities, take a look at the parser reference documentation !","title":"Closing word"},{"location":"write_configurations/requirements.html","text":"Requirements \u00b6 Having read and understood crowdsec concepts Some requirements are needed in order to be able to write your own end-to-end configurations. During all this documentation, we are going to show as an exemple how we wrote a full port scan detection scenario (from acqusition to scenario, including parser) Create the test environment \u00b6 First of all, please download the latest release of crowdsec-agent . Then run the following commands: tar xzvf crowdsec-release.tgz cd ./crowdsec-vX.Y/ ./test_env.sh # the -o is facultative, default is \"./tests/\" cd ./tests/ The ./test_env.sh script creates a local (non privileged) working environement for crowdsec-agent and cscli. The deployed environment is intended to write and test parsers and scenarios easily. Example $ tar xzvf ./crowdsec-release.tgz $ cd ./crowdsec-v*/ $ ./test_env.sh [ 12 /11/2020:11:45:19 ][ INFO ] Creating test arboresence in /tmp/crowdsec-v1.0.0/tests [ 12 /11/2020:11:45:19 ][ INFO ] Arboresence created [ 12 /11/2020:11:45:19 ][ INFO ] Copying needed files for tests environment [ 12 /11/2020:11:45:19 ][ INFO ] Files copied [ 12 /11/2020:11:45:19 ][ INFO ] Setting up configurations INFO [ 0000 ] Machine 'test' created successfully INFO [ 0000 ] API credentials dumped to '/tmp/crowdsec-v1.0.0/tests/config/local_api_credentials.yaml' INFO [ 0000 ] Wrote new 73826 bytes index to /tmp/crowdsec-v1.0.0/tests/config/hub/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK INFO [ 0000 ] downloading data 'https://crowdsec-statics-assets.s3-eu-west-1.amazonaws.com/GeoLite2-City.mmdb' in '/tmp/crowdsec-v1.0.0/tests/data/GeoLite2-City.mmdb' INFO [ 0002 ] downloading data 'https://crowdsec-statics-assets.s3-eu-west-1.amazonaws.com/GeoLite2-ASN.mmdb' in '/tmp/crowdsec-v1.0.0/tests/data/GeoLite2-ASN.mmdb' INFO [ 0003 ] crowdsecurity/dateparse-enrich : OK INFO [ 0003 ] crowdsecurity/sshd-logs : OK INFO [ 0004 ] crowdsecurity/ssh-bf : OK INFO [ 0004 ] crowdsecurity/sshd : OK WARN [ 0004 ] crowdsecurity/sshd : overwrite INFO [ 0004 ] crowdsecurity/linux : OK INFO [ 0004 ] /tmp/crowdsec-v1.0.0/tests/config/collections doesn 't exist, create INFO[0004] Enabled parsers : crowdsecurity/syslog-logs INFO[0004] Enabled parsers : crowdsecurity/geoip-enrich INFO[0004] Enabled parsers : crowdsecurity/dateparse-enrich INFO[0004] Enabled parsers : crowdsecurity/sshd-logs INFO[0004] Enabled scenarios : crowdsecurity/ssh-bf INFO[0004] Enabled collections : crowdsecurity/sshd INFO[0004] Enabled collections : crowdsecurity/linux INFO[0004] Enabled crowdsecurity/linux INFO[0004] Run ' systemctl reload crowdsec ' for the new configuration to be effective. [ 12 /11/2020:11:45:25 ][ INFO ] Environment is ready in /tmp/crowdsec-v1.0.0/tests","title":"Requirements"},{"location":"write_configurations/requirements.html#requirements","text":"Having read and understood crowdsec concepts Some requirements are needed in order to be able to write your own end-to-end configurations. During all this documentation, we are going to show as an exemple how we wrote a full port scan detection scenario (from acqusition to scenario, including parser)","title":"Requirements"},{"location":"write_configurations/requirements.html#create-the-test-environment","text":"First of all, please download the latest release of crowdsec-agent . Then run the following commands: tar xzvf crowdsec-release.tgz cd ./crowdsec-vX.Y/ ./test_env.sh # the -o is facultative, default is \"./tests/\" cd ./tests/ The ./test_env.sh script creates a local (non privileged) working environement for crowdsec-agent and cscli. The deployed environment is intended to write and test parsers and scenarios easily. Example $ tar xzvf ./crowdsec-release.tgz $ cd ./crowdsec-v*/ $ ./test_env.sh [ 12 /11/2020:11:45:19 ][ INFO ] Creating test arboresence in /tmp/crowdsec-v1.0.0/tests [ 12 /11/2020:11:45:19 ][ INFO ] Arboresence created [ 12 /11/2020:11:45:19 ][ INFO ] Copying needed files for tests environment [ 12 /11/2020:11:45:19 ][ INFO ] Files copied [ 12 /11/2020:11:45:19 ][ INFO ] Setting up configurations INFO [ 0000 ] Machine 'test' created successfully INFO [ 0000 ] API credentials dumped to '/tmp/crowdsec-v1.0.0/tests/config/local_api_credentials.yaml' INFO [ 0000 ] Wrote new 73826 bytes index to /tmp/crowdsec-v1.0.0/tests/config/hub/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK INFO [ 0000 ] downloading data 'https://crowdsec-statics-assets.s3-eu-west-1.amazonaws.com/GeoLite2-City.mmdb' in '/tmp/crowdsec-v1.0.0/tests/data/GeoLite2-City.mmdb' INFO [ 0002 ] downloading data 'https://crowdsec-statics-assets.s3-eu-west-1.amazonaws.com/GeoLite2-ASN.mmdb' in '/tmp/crowdsec-v1.0.0/tests/data/GeoLite2-ASN.mmdb' INFO [ 0003 ] crowdsecurity/dateparse-enrich : OK INFO [ 0003 ] crowdsecurity/sshd-logs : OK INFO [ 0004 ] crowdsecurity/ssh-bf : OK INFO [ 0004 ] crowdsecurity/sshd : OK WARN [ 0004 ] crowdsecurity/sshd : overwrite INFO [ 0004 ] crowdsecurity/linux : OK INFO [ 0004 ] /tmp/crowdsec-v1.0.0/tests/config/collections doesn 't exist, create INFO[0004] Enabled parsers : crowdsecurity/syslog-logs INFO[0004] Enabled parsers : crowdsecurity/geoip-enrich INFO[0004] Enabled parsers : crowdsecurity/dateparse-enrich INFO[0004] Enabled parsers : crowdsecurity/sshd-logs INFO[0004] Enabled scenarios : crowdsecurity/ssh-bf INFO[0004] Enabled collections : crowdsecurity/sshd INFO[0004] Enabled collections : crowdsecurity/linux INFO[0004] Enabled crowdsecurity/linux INFO[0004] Run ' systemctl reload crowdsec ' for the new configuration to be effective. [ 12 /11/2020:11:45:25 ][ INFO ] Environment is ready in /tmp/crowdsec-v1.0.0/tests","title":"Create the test environment"},{"location":"write_configurations/scenarios.html","text":"Writing Crowdsec-agent scenarios \u00b6 Info Please ensure that you have working env or setup test environment before writing your scenario. Ensure that your logs are properly parsed . Have some sample logs at hand reach to test your scenario as you progress. In the current example, we'll write a scenario to detect port scans relying on the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new scenarios. If you're writing scenario for existing logs, take a look at the taxonomy to find your way ! Exported fields You can view some of the extracted fields of existing parsers in the Hub Base scenario file \u00b6 A rudimentary scenario can be defined as : Warning Your yaml file must be in the config/scenarios/ directory. type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : evt.Meta.log_type == 'iptables_drop' capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test a filter : if the expression is true , the event will enter the scenario, otherwise, it won't a name & a description a capacity for our Leaky Bucket a leak speed for our Leaky Bucket a blackhole duration (it will prevent the same bucket from overflowing too often to limit spam) some labels to qualify the events that just happen a debug flag that allows to enable local debugging information. We are going to use the following sample log in our example : May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 66 .66.66.66 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929245 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 Let's try our mock scenario \u00b6 Info This assumes that you've followed the previous tutorial and that your iptables logs are properly parsed ./crowdsec -c ./dev.yaml -dsn file://x.log -type syslog Expected output DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow ( start: 2020 -05-12 09 :40:15 +0000 UTC, end: 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Adding overflow to blackhole ( 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] Bucket ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 found dead, cleanup the body bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 WARN [ 04 -08-2020 10 :44:26 ] read 4 lines file = ./x.log ... INFO [ 04 -08-2020 10 :44:26 ] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' ( 2 events over 0s ) at 2020 -05-12 09 :40:15 +0000 UTC bucket_id = sparkling-thunder event_time = \"2020-05-12 09:40:15 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 66 .66.66.66 ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow discarded, still blackholed for 59s bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Overflow has been discard ( *leakybucket.Blackhole ) bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 ... We can see our \"mock\" scenario is working, let's see what happened : The first event (parsed line) is processed : The filter returned true ( evt.Meta.log_type == 'iptables_drop' ) so the event will be processed by our bucket The bucket is instantiated in timeMachine mode, and its creation date is set to the timestamp from the first log The event is poured in the actual bucket The second event is processed The filter is still true, and the event is poured As our bucket's capacity is 1 , pouring this second overflow leads to an alert Because we set a blackhole directive of 1 minute , we remember to prevent this bucket to overflowing again for the next minute The overflow itself is produced and we get this message : INFO[12-05-2020 11:22:17] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' (2 events over 0s) at 2020-05-12 09:40:15 +0000 UTC bucket_id=withered-brook event_time=\"2020-05-12 09:40:15 +0000 UTC\" scenario=me/my-cool-scenario source_ip=66.66.66.66 Warning While it \"worked\" we can see the first issue : the offending IP is reported to be 66.66.66.66 but there are actually 3 IPs involved ( 66.66.66.66 , 99.99.99.99 and 44.44.44.44 ). To make sense our \"detect port scans\" should detect events coming from a single IP ! One step forward : peer attribution \u00b6 Let's evolve our scenario to be closer to something meaningful : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test What did we change ? we added a meaningful filter : we are only going to look into iptables_drop events, and only take care of tcp ones (see the parser we wrote in the previous step ) we added a groupby directive : it's going to ensure that each offending peer get its own bucket Let's try again ! ./crowdsec -c ./dev.yaml -dsn file://x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = cold-lake capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Instanciating TimeMachine bucket cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = muddy-haze capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 6236f134d0f34d0061748c065bdcb64d8ac6dc54 ... INFO [ 12 -05-2020 11 :25:20 ] node warning : no remediation bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 INFO [ 12 -05-2020 11 :25:20 ] Processing Overflow with no decisions 99 .99.99.99 performed 'me/my-cool-scenario' ( 2 events over 1s ) at 2020 -05-12 09 :40:16 +0000 UTC bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 ... Let's see what happened : Thanks to our groupby key, we now see two different partition keys appearing ( partition=... ). It means that each peer will get its own bucket, and a \"unique key\" is derived from the groupby field value (here : the source IP) We see that we only have one overflow, and it correctly concerns 99.99.99.99 (it's the one that actually triggered two events). This is again thanks to the groupby key One step forward : unique ports \u00b6 Is it done ? not yet, but we're getting close ! To really qualify a port-scan, we want to rely on the number of unique probed ports. Let's arbitrarily decide that a port-scan is : \"One peer trying to probe AT LEAST 15 different ports within a few seconds\" Our evolved scenario is now : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp What did we changed : We add a distinct directive on the evt.Parsed.dst_port . It allows the bucket to discard any event with an already seen evt.Parsed.dst_port . (yes, like in SQL) We changed capacity and leakspeed to be more relevant to our target We fixed the labels so that the event makes sense ! Let's see what it changes : ./crowdsec -c ./dev.yaml -dsn file://x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:49:01+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Instantiating TimeMachine bucket cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Leaky routine starting, lifetime : 1m20s bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq 'evt.Parsed.dst_port' -> '7681' bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq ( 7681 ) : false, discard bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Pouring event bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... We can see that the second event was discarded, because it had a destination port similar to the first one No overflow were produced Is it really working \u00b6 Ok, fingers crossed our thing should be working. Let's grab some real-life logs ! $ wc -l kern.log 78215 kern.log $ head -n1 kern.log May 11 06 :25:20 sd-126005 kernel: ... $ tail -n1 kern.log May 12 12 :09:00 sd-126005 kernel: ... We have around 80k lines averaging about 24h of logs, let's try ! ./crowdsec -c ./dev.yaml -dsn file://kern.log -type syslog Expected output INFO [ 0000 ] setting loglevel to info INFO [ 12 -05-2020 11 :50:38 ] Crowdsec v0.0.18-f672dbb4aec29ca2b24080a33d4d92eb9d4441cc ... INFO [ 12 -05-2020 11 :50:42 ] node warning : no remediation bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx INFO [ 12 -05-2020 11 :50:42 ] Processing Overflow with no decisions xx.xx.xx.xx performed 'me/my-cool-scenario' ( 16 events over 0s ) at 2020 -05-11 10 :41:45 +0000 UTC bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx ... INFO [ 12 -05-2020 11 :50:43 ] node warning : no remediation bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy INFO [ 12 -05-2020 11 :50:43 ] Processing Overflow with no decisions yy.yy.yy.yy performed 'me/my-cool-scenario' ( 16 events over 2s ) at 2020 -05-11 11 :34:11 +0000 UTC bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy ... WARN [ 12 -05-2020 11 :51:05 ] read 78215 lines file = ./kern.log ... It seems to work correctly ! Hold my beer and watch this \u00b6 Once I have acquire confidence in my scenario and I want it to trigger some bans, we can simply add : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp remediation : true scope : ip Adding remediation: true into the labels tells crowdsec-agent that we should write a ban for the IP when the scenario is triggered ! Let's try : I copied the yaml file to a production system ( /etc/crowdsec/scenarios/mytest.yaml ) I restart crowdsec-agent ( systemctl reload crowdsec ) Let's check if it seems correctly enabled : $ cscli list ... INFO [ 0000 ] SCENARIOS: ---------------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ---------------------------------------------------------------------------------------------------------------------------------- ... mytest.yaml \ud83d\udeab enabled,local /etc/crowdsec/scenarios/mytest.yaml ... Let's launch (from an external machine, as crowdsec-agent ignores events from private IPs by default) a real port-scan with a good old nmap : sudo nmap -sS xx.xx.xx.xx and on our server : $ tail -f /var/log/crowdsec.log ... time = \"12-05-2020 12:31:43\" level = warning msg = \"xx.xx.16.6 triggered a 4h0m0s ip ban remediation for [me/my-cool-scenario]\" bucket_id = wispy-breeze event_time = \"2020-05-12 12:31:43.953498645 +0200 CEST m=+64.533521568\" scenario = me/my-cool-scenario source_ip = xx.xx.16.6 ... ^C $ cscli ban list INFO [ 0000 ] backend plugin 'database' loaded 8 local decisions: +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | local | xx.xx.xx.xx | me/my-cool-scenario | 4 | ban | FR | 21502 SFR SA | 79 | 3h58m27s | ... It worked !!!","title":"Scenarios"},{"location":"write_configurations/scenarios.html#writing-crowdsec-agent-scenarios","text":"Info Please ensure that you have working env or setup test environment before writing your scenario. Ensure that your logs are properly parsed . Have some sample logs at hand reach to test your scenario as you progress. In the current example, we'll write a scenario to detect port scans relying on the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new scenarios. If you're writing scenario for existing logs, take a look at the taxonomy to find your way ! Exported fields You can view some of the extracted fields of existing parsers in the Hub","title":"Writing Crowdsec-agent scenarios"},{"location":"write_configurations/scenarios.html#base-scenario-file","text":"A rudimentary scenario can be defined as : Warning Your yaml file must be in the config/scenarios/ directory. type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : evt.Meta.log_type == 'iptables_drop' capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test a filter : if the expression is true , the event will enter the scenario, otherwise, it won't a name & a description a capacity for our Leaky Bucket a leak speed for our Leaky Bucket a blackhole duration (it will prevent the same bucket from overflowing too often to limit spam) some labels to qualify the events that just happen a debug flag that allows to enable local debugging information. We are going to use the following sample log in our example : May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 66 .66.66.66 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929245 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0","title":"Base scenario file"},{"location":"write_configurations/scenarios.html#lets-try-our-mock-scenario","text":"Info This assumes that you've followed the previous tutorial and that your iptables logs are properly parsed ./crowdsec -c ./dev.yaml -dsn file://x.log -type syslog Expected output DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow ( start: 2020 -05-12 09 :40:15 +0000 UTC, end: 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Adding overflow to blackhole ( 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] Bucket ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 found dead, cleanup the body bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 WARN [ 04 -08-2020 10 :44:26 ] read 4 lines file = ./x.log ... INFO [ 04 -08-2020 10 :44:26 ] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' ( 2 events over 0s ) at 2020 -05-12 09 :40:15 +0000 UTC bucket_id = sparkling-thunder event_time = \"2020-05-12 09:40:15 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 66 .66.66.66 ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow discarded, still blackholed for 59s bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Overflow has been discard ( *leakybucket.Blackhole ) bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 ... We can see our \"mock\" scenario is working, let's see what happened : The first event (parsed line) is processed : The filter returned true ( evt.Meta.log_type == 'iptables_drop' ) so the event will be processed by our bucket The bucket is instantiated in timeMachine mode, and its creation date is set to the timestamp from the first log The event is poured in the actual bucket The second event is processed The filter is still true, and the event is poured As our bucket's capacity is 1 , pouring this second overflow leads to an alert Because we set a blackhole directive of 1 minute , we remember to prevent this bucket to overflowing again for the next minute The overflow itself is produced and we get this message : INFO[12-05-2020 11:22:17] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' (2 events over 0s) at 2020-05-12 09:40:15 +0000 UTC bucket_id=withered-brook event_time=\"2020-05-12 09:40:15 +0000 UTC\" scenario=me/my-cool-scenario source_ip=66.66.66.66 Warning While it \"worked\" we can see the first issue : the offending IP is reported to be 66.66.66.66 but there are actually 3 IPs involved ( 66.66.66.66 , 99.99.99.99 and 44.44.44.44 ). To make sense our \"detect port scans\" should detect events coming from a single IP !","title":"Let's try our mock scenario"},{"location":"write_configurations/scenarios.html#one-step-forward-peer-attribution","text":"Let's evolve our scenario to be closer to something meaningful : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test What did we change ? we added a meaningful filter : we are only going to look into iptables_drop events, and only take care of tcp ones (see the parser we wrote in the previous step ) we added a groupby directive : it's going to ensure that each offending peer get its own bucket Let's try again ! ./crowdsec -c ./dev.yaml -dsn file://x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = cold-lake capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Instanciating TimeMachine bucket cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = muddy-haze capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 6236f134d0f34d0061748c065bdcb64d8ac6dc54 ... INFO [ 12 -05-2020 11 :25:20 ] node warning : no remediation bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 INFO [ 12 -05-2020 11 :25:20 ] Processing Overflow with no decisions 99 .99.99.99 performed 'me/my-cool-scenario' ( 2 events over 1s ) at 2020 -05-12 09 :40:16 +0000 UTC bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 ... Let's see what happened : Thanks to our groupby key, we now see two different partition keys appearing ( partition=... ). It means that each peer will get its own bucket, and a \"unique key\" is derived from the groupby field value (here : the source IP) We see that we only have one overflow, and it correctly concerns 99.99.99.99 (it's the one that actually triggered two events). This is again thanks to the groupby key","title":"One step forward : peer attribution"},{"location":"write_configurations/scenarios.html#one-step-forward-unique-ports","text":"Is it done ? not yet, but we're getting close ! To really qualify a port-scan, we want to rely on the number of unique probed ports. Let's arbitrarily decide that a port-scan is : \"One peer trying to probe AT LEAST 15 different ports within a few seconds\" Our evolved scenario is now : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp What did we changed : We add a distinct directive on the evt.Parsed.dst_port . It allows the bucket to discard any event with an already seen evt.Parsed.dst_port . (yes, like in SQL) We changed capacity and leakspeed to be more relevant to our target We fixed the labels so that the event makes sense ! Let's see what it changes : ./crowdsec -c ./dev.yaml -dsn file://x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:49:01+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Instantiating TimeMachine bucket cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Leaky routine starting, lifetime : 1m20s bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq 'evt.Parsed.dst_port' -> '7681' bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq ( 7681 ) : false, discard bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Pouring event bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... We can see that the second event was discarded, because it had a destination port similar to the first one No overflow were produced","title":"One step forward : unique ports"},{"location":"write_configurations/scenarios.html#is-it-really-working","text":"Ok, fingers crossed our thing should be working. Let's grab some real-life logs ! $ wc -l kern.log 78215 kern.log $ head -n1 kern.log May 11 06 :25:20 sd-126005 kernel: ... $ tail -n1 kern.log May 12 12 :09:00 sd-126005 kernel: ... We have around 80k lines averaging about 24h of logs, let's try ! ./crowdsec -c ./dev.yaml -dsn file://kern.log -type syslog Expected output INFO [ 0000 ] setting loglevel to info INFO [ 12 -05-2020 11 :50:38 ] Crowdsec v0.0.18-f672dbb4aec29ca2b24080a33d4d92eb9d4441cc ... INFO [ 12 -05-2020 11 :50:42 ] node warning : no remediation bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx INFO [ 12 -05-2020 11 :50:42 ] Processing Overflow with no decisions xx.xx.xx.xx performed 'me/my-cool-scenario' ( 16 events over 0s ) at 2020 -05-11 10 :41:45 +0000 UTC bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx ... INFO [ 12 -05-2020 11 :50:43 ] node warning : no remediation bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy INFO [ 12 -05-2020 11 :50:43 ] Processing Overflow with no decisions yy.yy.yy.yy performed 'me/my-cool-scenario' ( 16 events over 2s ) at 2020 -05-11 11 :34:11 +0000 UTC bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy ... WARN [ 12 -05-2020 11 :51:05 ] read 78215 lines file = ./kern.log ... It seems to work correctly !","title":"Is it really working"},{"location":"write_configurations/scenarios.html#hold-my-beer-and-watch-this","text":"Once I have acquire confidence in my scenario and I want it to trigger some bans, we can simply add : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp remediation : true scope : ip Adding remediation: true into the labels tells crowdsec-agent that we should write a ban for the IP when the scenario is triggered ! Let's try : I copied the yaml file to a production system ( /etc/crowdsec/scenarios/mytest.yaml ) I restart crowdsec-agent ( systemctl reload crowdsec ) Let's check if it seems correctly enabled : $ cscli list ... INFO [ 0000 ] SCENARIOS: ---------------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ---------------------------------------------------------------------------------------------------------------------------------- ... mytest.yaml \ud83d\udeab enabled,local /etc/crowdsec/scenarios/mytest.yaml ... Let's launch (from an external machine, as crowdsec-agent ignores events from private IPs by default) a real port-scan with a good old nmap : sudo nmap -sS xx.xx.xx.xx and on our server : $ tail -f /var/log/crowdsec.log ... time = \"12-05-2020 12:31:43\" level = warning msg = \"xx.xx.16.6 triggered a 4h0m0s ip ban remediation for [me/my-cool-scenario]\" bucket_id = wispy-breeze event_time = \"2020-05-12 12:31:43.953498645 +0200 CEST m=+64.533521568\" scenario = me/my-cool-scenario source_ip = xx.xx.16.6 ... ^C $ cscli ban list INFO [ 0000 ] backend plugin 'database' loaded 8 local decisions: +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | local | xx.xx.xx.xx | me/my-cool-scenario | 4 | ban | FR | 21502 SFR SA | 79 | 3h58m27s | ... It worked !!!","title":"Hold my beer and watch this"},{"location":"write_configurations/whitelist.html","text":"What are whitelists \u00b6 Whitelists are special parsers that allow you to \"discard\" events, and can exist at two different steps : Parser whitelists : Allows you to discard an event at parse time, so that it never hits the buckets. PostOverflow whitelists : Those are whitelists that are checked after the overflow happens. It is usually best for whitelisting process that can be expensive (such as performing reverse DNS on an IP, or performing a whois of an IP). Info While the whitelists are the same for parser or postoverflows, beware that field names might change. Source ip is usually in evt.Meta.source_ip when it's a log, but evt.Overflow.Source_ip when it's an overflow The whitelist can be based on several criteria : specific ip address : if the event/overflow IP is the same, event is whitelisted ip ranges : if the event/overflow IP belongs to this range, event is whitelisted a list of expr expressions : if any expression returns true, event is whitelisted Here is an example showcasing configuration : name : crowdsecurity/my-whitelists description : \"Whitelist events from my ipv4 addresses\" #it's a normal parser, so we can restrict its scope with filter filter : \"1 == 1\" whitelist : reason : \"my ipv4 ranges\" ip : - \"127.0.0.1\" cidr : - \"192.168.0.0/16\" - \"10.0.0.0/8\" - \"172.16.0.0/12\" expression : #beware, this one will work *only* if you enabled the reverse dns (crowdsecurity/rdns) enrichment postoverflow parser - evt.Enriched.reverse_dns endsWith \".mycoolorg.com.\" #this one will work *only* if you enabled the geoip (crowdsecurity/geoip-enrich) enrichment parser - evt.Enriched.IsoCode == 'FR' Whitelists in parsing \u00b6 When a whitelist is present in parsing /etc/crowdsec/parsers/... , it will be checked/discarded before being poured to any bucket. These whitelists intentionally generate no logs and are useful to discard noisy false positive sources. Whitelist by ip \u00b6 Let's assume we have a setup with a crowdsecurity/nginx collection enabled and no whitelists. Thus, if I \"attack\" myself : nikto -host myfqdn.com my own IP will be flagged as being an attacker : $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-bad-user-agent]\" bucket_id = cool-smoke event_time = \"2020-07-07 16:13:16.579581642 +0200 CEST m=+358819.413561109\" scenario = crowdsecurity/http-bad-user-agent source_ip = 80 .x.x.x time = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-probing]\" bucket_id = green-silence event_time = \"2020-07-07 16:13:16.737579458 +0200 CEST m=+358819.571558901\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 16:13:17\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-crawl-non_statics]\" bucket_id = purple-snowflake event_time = \"2020-07-07 16:13:17.353641625 +0200 CEST m=+358820.187621068\" scenario = crowdsecurity/http-crawl-non_statics source_ip = 80 .x.x.x time = \"07-07-2020 16:13:18\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-sensitive-files]\" bucket_id = small-hill event_time = \"2020-07-07 16:13:18.005919055 +0200 CEST m=+358820.839898498\" scenario = crowdsecurity/http-sensitive-files source_ip = 80 .x.x.x ^C $ cscli ban list 4 local decisions: +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | local | 80 .x.x.x | crowdsecurity/http-bad-user-agent | 4 | ban | FR | 21502 SFR SA | 60 | 3h59m3s | ... Create the whitelist by IP \u00b6 Let's create a /etc/crowdsec/parsers/s02-enrich/mywhitelists.yaml file with the following content : name : crowdsecurity/whitelists description : \"Whitelist events from my ip addresses\" whitelist : reason : \"my ip ranges\" ip : - \"80.x.x.x\" and reload crowdsec-agent : sudo systemctl reload crowdsec Test the whitelist \u00b6 Thus, if we restart our attack : nikto -host myfqdn.com And we don't get bans : $ tail -f /var/log/crowdsec.log ... ^C $ cscli ban list No local decisions. And 21 records from API, 15 distinct AS, 12 distinct countries Here, we don't get any logs, as the event have been discarded at parsing time. Create whitelist by expression \u00b6 Now, let's make something more tricky : let's whitelist a specific user-agent (of course, it's just an example, don't do this at home !). The hub's taxonomy will helps us to find which data is present in which field. Let's change our whitelist to : name : crowdsecurity/whitelists description : \"Whitelist events from private ipv4 addresses\" whitelist : reason : \"private ipv4 ranges\" expression : - evt.Parsed.http_user_agent == 'MySecretUserAgent' again, let's restart crowdsec-agent ! For the record, I edited nikto's configuration to use 'MySecretUserAgent' as user-agent, and thus : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ... time = \"07-05-2020 09:39:09\" level = info msg = \"Event is whitelisted by Expr !\" filter = name = solitary-leaf stage = s02-enrich ... Whitelist in PostOverflows \u00b6 Whitelists in PostOverflows are applied after the bucket overflow happens. It has the advantage of being triggered only once we are about to take decision about an IP or Range, and thus happens a lot less often. A good example is the crowdsecurity/whitelist-good-actors collection. But let's craft ours based on our previous example ! First of all, install the crowdsecurity/rdns postoverflow : it will be in charge of enriching overflows with reverse dns information of the offending IP. Let's put the following file in /etc/crowdsec/postoverflows/s01-whitelists/mywhitelists.yaml : name : me/my_cool_whitelist description : lets whitelist our own reverse dns whitelist : reason : dont ban my ISP expression : #this is the reverse of my ip, you can get it by performing a \"host\" command on your public IP for example - evt.Enriched.reverse_dns endsWith '.asnieres.rev.numericable.fr.' After reloading crowdsec-agent, and launching (again!) nikto : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 17:11:09\" level = info msg = \"Ban for 80.x.x.x whitelisted, reason [dont ban my ISP]\" id = cold-sunset name = me/my_cool_whitelist stage = s01 time = \"07-07-2020 17:11:09\" level = info msg = \"node warning : no remediation\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 17:11:09\" level = info msg = \"Processing Overflow with no decisions 80.x.x.x performed 'crowdsecurity/http-probing' (11 events over 313.983994ms) at 2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x ... This time, we can see that logs are being produced when the event is discarded.","title":"Whitelists"},{"location":"write_configurations/whitelist.html#what-are-whitelists","text":"Whitelists are special parsers that allow you to \"discard\" events, and can exist at two different steps : Parser whitelists : Allows you to discard an event at parse time, so that it never hits the buckets. PostOverflow whitelists : Those are whitelists that are checked after the overflow happens. It is usually best for whitelisting process that can be expensive (such as performing reverse DNS on an IP, or performing a whois of an IP). Info While the whitelists are the same for parser or postoverflows, beware that field names might change. Source ip is usually in evt.Meta.source_ip when it's a log, but evt.Overflow.Source_ip when it's an overflow The whitelist can be based on several criteria : specific ip address : if the event/overflow IP is the same, event is whitelisted ip ranges : if the event/overflow IP belongs to this range, event is whitelisted a list of expr expressions : if any expression returns true, event is whitelisted Here is an example showcasing configuration : name : crowdsecurity/my-whitelists description : \"Whitelist events from my ipv4 addresses\" #it's a normal parser, so we can restrict its scope with filter filter : \"1 == 1\" whitelist : reason : \"my ipv4 ranges\" ip : - \"127.0.0.1\" cidr : - \"192.168.0.0/16\" - \"10.0.0.0/8\" - \"172.16.0.0/12\" expression : #beware, this one will work *only* if you enabled the reverse dns (crowdsecurity/rdns) enrichment postoverflow parser - evt.Enriched.reverse_dns endsWith \".mycoolorg.com.\" #this one will work *only* if you enabled the geoip (crowdsecurity/geoip-enrich) enrichment parser - evt.Enriched.IsoCode == 'FR'","title":"What are whitelists"},{"location":"write_configurations/whitelist.html#whitelists-in-parsing","text":"When a whitelist is present in parsing /etc/crowdsec/parsers/... , it will be checked/discarded before being poured to any bucket. These whitelists intentionally generate no logs and are useful to discard noisy false positive sources.","title":"Whitelists in parsing"},{"location":"write_configurations/whitelist.html#whitelist-by-ip","text":"Let's assume we have a setup with a crowdsecurity/nginx collection enabled and no whitelists. Thus, if I \"attack\" myself : nikto -host myfqdn.com my own IP will be flagged as being an attacker : $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-bad-user-agent]\" bucket_id = cool-smoke event_time = \"2020-07-07 16:13:16.579581642 +0200 CEST m=+358819.413561109\" scenario = crowdsecurity/http-bad-user-agent source_ip = 80 .x.x.x time = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-probing]\" bucket_id = green-silence event_time = \"2020-07-07 16:13:16.737579458 +0200 CEST m=+358819.571558901\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 16:13:17\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-crawl-non_statics]\" bucket_id = purple-snowflake event_time = \"2020-07-07 16:13:17.353641625 +0200 CEST m=+358820.187621068\" scenario = crowdsecurity/http-crawl-non_statics source_ip = 80 .x.x.x time = \"07-07-2020 16:13:18\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-sensitive-files]\" bucket_id = small-hill event_time = \"2020-07-07 16:13:18.005919055 +0200 CEST m=+358820.839898498\" scenario = crowdsecurity/http-sensitive-files source_ip = 80 .x.x.x ^C $ cscli ban list 4 local decisions: +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | local | 80 .x.x.x | crowdsecurity/http-bad-user-agent | 4 | ban | FR | 21502 SFR SA | 60 | 3h59m3s | ...","title":"Whitelist by ip"},{"location":"write_configurations/whitelist.html#create-the-whitelist-by-ip","text":"Let's create a /etc/crowdsec/parsers/s02-enrich/mywhitelists.yaml file with the following content : name : crowdsecurity/whitelists description : \"Whitelist events from my ip addresses\" whitelist : reason : \"my ip ranges\" ip : - \"80.x.x.x\" and reload crowdsec-agent : sudo systemctl reload crowdsec","title":"Create the whitelist by IP"},{"location":"write_configurations/whitelist.html#test-the-whitelist","text":"Thus, if we restart our attack : nikto -host myfqdn.com And we don't get bans : $ tail -f /var/log/crowdsec.log ... ^C $ cscli ban list No local decisions. And 21 records from API, 15 distinct AS, 12 distinct countries Here, we don't get any logs, as the event have been discarded at parsing time.","title":"Test the whitelist"},{"location":"write_configurations/whitelist.html#create-whitelist-by-expression","text":"Now, let's make something more tricky : let's whitelist a specific user-agent (of course, it's just an example, don't do this at home !). The hub's taxonomy will helps us to find which data is present in which field. Let's change our whitelist to : name : crowdsecurity/whitelists description : \"Whitelist events from private ipv4 addresses\" whitelist : reason : \"private ipv4 ranges\" expression : - evt.Parsed.http_user_agent == 'MySecretUserAgent' again, let's restart crowdsec-agent ! For the record, I edited nikto's configuration to use 'MySecretUserAgent' as user-agent, and thus : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ... time = \"07-05-2020 09:39:09\" level = info msg = \"Event is whitelisted by Expr !\" filter = name = solitary-leaf stage = s02-enrich ...","title":"Create whitelist by expression"},{"location":"write_configurations/whitelist.html#whitelist-in-postoverflows","text":"Whitelists in PostOverflows are applied after the bucket overflow happens. It has the advantage of being triggered only once we are about to take decision about an IP or Range, and thus happens a lot less often. A good example is the crowdsecurity/whitelist-good-actors collection. But let's craft ours based on our previous example ! First of all, install the crowdsecurity/rdns postoverflow : it will be in charge of enriching overflows with reverse dns information of the offending IP. Let's put the following file in /etc/crowdsec/postoverflows/s01-whitelists/mywhitelists.yaml : name : me/my_cool_whitelist description : lets whitelist our own reverse dns whitelist : reason : dont ban my ISP expression : #this is the reverse of my ip, you can get it by performing a \"host\" command on your public IP for example - evt.Enriched.reverse_dns endsWith '.asnieres.rev.numericable.fr.' After reloading crowdsec-agent, and launching (again!) nikto : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 17:11:09\" level = info msg = \"Ban for 80.x.x.x whitelisted, reason [dont ban my ISP]\" id = cold-sunset name = me/my_cool_whitelist stage = s01 time = \"07-07-2020 17:11:09\" level = info msg = \"node warning : no remediation\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 17:11:09\" level = info msg = \"Processing Overflow with no decisions 80.x.x.x performed 'crowdsecurity/http-probing' (11 events over 313.983994ms) at 2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x ... This time, we can see that logs are being produced when the event is discarded.","title":"Whitelist in PostOverflows"}]}