{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"[Hub] [Releases] What is {{v1X.crowdsec.Name}} ? \u00b6 {{v1X.crowdsec.Name}} is an open-source and lightweight software that allows you to detect peers with malevolent behaviors and block them from accessing your systems at various level (infrastructural, system, applicative). To achieve this, {{v1X.crowdsec.Name}} reads logs from different sources (files, streams ...) to parse, normalize and enrich them before matching them to threats patterns called scenarios. {{v1X.crowdsec.Name}} is a modular and plug-able framework, it ships a large variety of well known popular scenarios ; users can choose what scenarios they want to be protected from as well as easily adding new custom ones to better fit their environment. Detected malevolent peers can then be prevented from accessing your resources by deploying bouncers at various levels (applicative, system, infrastructural) of your stack. One of the advantages of Crowdsec when compared to other solutions is its crowd-sourced aspect : Meta information about detected attacks (source IP, time and triggered scenario) are sent to a central API and then shared amongst all users. Thanks to this, besides detecting and stopping attacks in real time based on your logs, it allows you to preemptively block known bad actors from accessing your information system. Main features \u00b6 {{v0X.crowdsec.Name}}, besides the core \"detect and react\" mechanism, is committed to a few other key points : Easy Installation : The provided wizard allows a trivial deployment on most standard setups Easy daily operations : Using cscli and the {{v0X.hub.htmlname}}, keeping your detection mechanisms up-to-date is trivial Reproducibility : Crowdsec can run not only against live logs, but as well against cold logs. It makes it a lot easier to detect potential false-positives, perform forensic ou generate reporting Observability : Providing strongs insights on what is going on and what {{v0X.crowdsec.name}} is doing : Humans have access to a trivially deployable web interface OPs have access to detailed prometheus metrics Admins have a friendly command-line interface tool Architecture \u00b6 Components \u00b6 {{v0X.crowdsec.name}} ecosystem is based on the following components : {{v0X.crowdsec.Name}} is the lightweight service that processes logs and keeps track of attacks. {{v0X.cli.name}} is the command line interface for humans, it allows you to view, add, or remove bans as well as to install, find, or update scenarios and parsers {{v0X.bouncers.name}} are the components that block malevolent traffic, and can be deployed anywhere in your stack Moving forward \u00b6 To learn more about {{v0X.crowdsec.name}} and give it a try, please see : How to install {{v0X.crowdsec.name}} Take a quick tour of {{v0X.crowdsec.name}} and {{v0X.cli.name}} features Observability of {{v0X.crowdsec.name}} Understand {{v0X.crowdsec.name}} configuration Deploy {{v0X.bouncers.name}} to stop malevolent peers FAQ Don't hesitate to reach out if you're facing issues : report a bug suggest an improvement ask for help on the forums About this documentation \u00b6 This document is split according to major {{v1X.crowdsec.Name}} versions : Crowdsec v0 Refers to versions 0.3.X , before the local API was introduced. ( note: this is going to be deprecated and your are strongly incited to migrate to versions 1.X ) Crowdsec v1 Refers to versions 1.X , it is the current version","title":"Home"},{"location":"#what-is-v1xcrowdsecname","text":"{{v1X.crowdsec.Name}} is an open-source and lightweight software that allows you to detect peers with malevolent behaviors and block them from accessing your systems at various level (infrastructural, system, applicative). To achieve this, {{v1X.crowdsec.Name}} reads logs from different sources (files, streams ...) to parse, normalize and enrich them before matching them to threats patterns called scenarios. {{v1X.crowdsec.Name}} is a modular and plug-able framework, it ships a large variety of well known popular scenarios ; users can choose what scenarios they want to be protected from as well as easily adding new custom ones to better fit their environment. Detected malevolent peers can then be prevented from accessing your resources by deploying bouncers at various levels (applicative, system, infrastructural) of your stack. One of the advantages of Crowdsec when compared to other solutions is its crowd-sourced aspect : Meta information about detected attacks (source IP, time and triggered scenario) are sent to a central API and then shared amongst all users. Thanks to this, besides detecting and stopping attacks in real time based on your logs, it allows you to preemptively block known bad actors from accessing your information system.","title":"What is {{v1X.crowdsec.Name}} ?"},{"location":"#main-features","text":"{{v0X.crowdsec.Name}}, besides the core \"detect and react\" mechanism, is committed to a few other key points : Easy Installation : The provided wizard allows a trivial deployment on most standard setups Easy daily operations : Using cscli and the {{v0X.hub.htmlname}}, keeping your detection mechanisms up-to-date is trivial Reproducibility : Crowdsec can run not only against live logs, but as well against cold logs. It makes it a lot easier to detect potential false-positives, perform forensic ou generate reporting Observability : Providing strongs insights on what is going on and what {{v0X.crowdsec.name}} is doing : Humans have access to a trivially deployable web interface OPs have access to detailed prometheus metrics Admins have a friendly command-line interface tool","title":"Main features"},{"location":"#architecture","text":"","title":"Architecture"},{"location":"#components","text":"{{v0X.crowdsec.name}} ecosystem is based on the following components : {{v0X.crowdsec.Name}} is the lightweight service that processes logs and keeps track of attacks. {{v0X.cli.name}} is the command line interface for humans, it allows you to view, add, or remove bans as well as to install, find, or update scenarios and parsers {{v0X.bouncers.name}} are the components that block malevolent traffic, and can be deployed anywhere in your stack","title":"Components"},{"location":"#moving-forward","text":"To learn more about {{v0X.crowdsec.name}} and give it a try, please see : How to install {{v0X.crowdsec.name}} Take a quick tour of {{v0X.crowdsec.name}} and {{v0X.cli.name}} features Observability of {{v0X.crowdsec.name}} Understand {{v0X.crowdsec.name}} configuration Deploy {{v0X.bouncers.name}} to stop malevolent peers FAQ Don't hesitate to reach out if you're facing issues : report a bug suggest an improvement ask for help on the forums","title":"Moving forward"},{"location":"#about-this-documentation","text":"This document is split according to major {{v1X.crowdsec.Name}} versions : Crowdsec v0 Refers to versions 0.3.X , before the local API was introduced. ( note: this is going to be deprecated and your are strongly incited to migrate to versions 1.X ) Crowdsec v1 Refers to versions 1.X , it is the current version","title":"About this documentation"},{"location":"contributing/","text":"Contributing \u00b6 You have an idea, a suggestion or you spotted a mistake ? Help us improve the software and the user experience, to make the internet a safer place together ! Contributing to the documentation \u00b6 If you spotted some mistakes in the documentation or have improvement suggestions, you can : open a {{v1X.doc.new_issue}} if you are comfortable with github let us know on {{v1X.doc.discourse}} if you want to discuss about it Let us as well know if you have some improvement suggestions ! Preview your documentation changes locally python3 -m venv cs-env source cs-env/bin/activate pip install -r docs/requirements.txt mkdocs serve Contributing to the code \u00b6 If you want to report a bug, you can use the github bugtracker If you want to suggest an improvement you can use either the github bugtracker or the {{v1X.doc.discourse}} if you want to discuss Contributing to the parsers/scenarios \u00b6 If you want to contribute your parser or scenario to the community and have them appear on the {{v1X.hub.htmlname}}, you should open a merge request on the hub. We are currently working on a proper CI for the {{v1X.hub.htmlname}}, so for now all contribution are subject to peer-review, please bear with us ! Contacting the team \u00b6 If you want to contact us using non-public media, you can contact us on support AT crowdsec DOT net with the following gpg-key : -----BEGIN PGP PUBLIC KEY BLOCK----- mQGNBF+VOSUBDADP6bxKDv88CdLBNhQMFNI37LE82vyfIAQmrGszON1m1EtL/LSQ b/vC9mmlkUmJHM+bdxJ0BSl/xlWwrXjHVpaZNoluQDngVUe62cybN4tpFCvtVTMr lo4Y0UhETgOmBFxaQLVd7Xc/jaSZGoHtSzh9hpGHg9pKrcYviG0MR173JYQfilw3 L8yJ+K/oUUpvh2MRRwXiCNUVLtTppb7oxlcdExb0Px2PcaC34e/M30xFwiu7VJFj 0D7IIdKs6gvZuqwkNSUBF8/jtuzzM/YGzJHIdvOj15z+81/o/e6p3xvY/IKmyXC/ 1FMD8f4g5T/5fNDVq6QgJLel/g0bJ+kG75ccXfY45xKFo/YhdQ2Wg9JQX5Yjc5k7 5AI0iuJjatXlym2Ek1niPEqR5H0C/KXFG4mPyCu9wzJu11jtY34e5TNYl9DA31F6 81BbMmVFg4EbhYSN/2DuxpCvt2qQpk33bmdT7tFWcd2hYB/bSq2f8+K6ho50Sqwk PK68LNZzi5ZXqGEAEQEAAbQnQ3Jvd2RTZWMgc3VwcG9ydCA8c3VwcG9ydEBjcm93 ZHNlYy5uZXQ+iQHUBBMBCgA+FiEEpRXNfWM+DON/Satp2MpQXYwzLTEFAl+VOSUC GwMFCQPCZwAFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQ2MpQXYwzLTEhuwwA wWdsuSrTC4ryVOYnfHRcT2b/rfbJXIUYXqAy75qsdUGwvueYdYSBMCMXqRB65J+J juofCF0kTQKuhjtyJezwUfr5C+Sd08JWlZwf9F7CO83/ztLOPIUUp69H3m9heW7C +A/Lpq3epALytC/QSkDHYnKBBZbLhoR/7WXhdLFvh+A475/ggn4GAOnZMg8WULpR Kisu1GbEBPcVr1Xl6VTYVX5ghA/1W2WTY/NxAcLhCiJO/ENeka7xy4EKdCE5pDxM QO/fnpCHsWDIHTxpCx+JAhdkb2BIvzSiF2+o+9y+vwzcPxdGemx7y8MjSGXIp1xp TJparq309nljh+wqI6w/K+NjzNn/qJL0tpGqiHQXtYDbi86KaAXT9IYCGAIP36w8 XUHYGgo0s6zMEP1NEFHWAgGy5elO403vm+NO5vpHv59FTjgoK2UcjeSjqtAYwzvc bWQ6wZHwhoqD0WevFcAMmgdbebyOdPoA7+8eCPnkjER4eKxE23ffFU75HDuQNRYk uQGNBF+VOSUBDADNHEm33IcwhO+uJQxjKtcF0DdAMqbjU5cXxeryo1i7A1WkTH5/ wHfyJAmtLrY4abkQ1LEJ4bMYKdJz2vmvWq0fKCAXC18yLnxU+l0Ld4tWME8hJ/Wh p+aePsW5BdLpHQeqmQ5MCsw1cZllbURcee22hLJ/PIM2bRsZp7goSj4wXBFjhJyq EepVmasI17dBbIBFWBSSIJW4UnSBk+Zqbj6C6PDmsket68qcEebsqduWXPxegAzh IIFD2qhC5t+nn5i+hPwKZN5ZYLQJeAjI4Z7wi3FIBZCzZ214421BbohxPo+GKkFp mUQ7ZrIa+goHXAcj6ZHMeNNP0lsJRl91lK6NVu3p+Ygl0+wbMOAqDRguMfFdbnV8 gcoYpAyk4YFCfgVQLuKGaYcGjcMP8+nZnPsbaTwbUKkjDAUo+JGmrB4XyAQPugZq TiUN+lYgTs0cJALEQkKTh2w10TPyV6/YsYDSSnwJeVDIpNCQVg5EB0eRvhaCs9fd dVni1C5RMcb+Q4MAEQEAAYkBvAQYAQoAJhYhBKUVzX1jPgzjf0mradjKUF2MMy0x BQJflTklAhsMBQkDwmcAAAoJENjKUF2MMy0xkIcL/johqZbyHskQIaTfQUgASbbu bdLXSrIkB8Ort9WULxdqs8hveFy6RjXFJWFitFHk46Bj6FJ1ZykfozL+k9uOGrL9 lBk1e3bhqMVhW1o00DufgawNU2FU9NuH/rCuGpum9DE0cc1fFmQ3pjeiHV55GYxr BGuyyals1ORwK06h+1VFMHrGB12SR7Imgo7FWuexhgLyOK4t1MXg3E4h72qaowpj 5B45qG9jUXgIFKR1D8G8tPeDYLbd37pskNDFozzfAe/H2fqmEjQxMLHrk7J8I3wQ FPvKIvUF8M3NqZjyaFSiisOn32AS3RAsI8RuD4T2XgpE2L6e29u3RpJkvhPbcAN6 w0W8yw3z1/2uHSvYbwoH1cn4akAikYR9aVVHv86AvNlr0BguqWdzEfiGT6mcJ/hH 2sGQJ1nJRgGpAlx/2HpsLJxhJwLVbXSDSk6Bu2T9G/VIda95niVgq6MfE9GSS+MS ucVcwqjIXn/9V6+pFZ11soXNKuTk4Wx+uO2r/i5bVA== =Edl+ -----END PGP PUBLIC KEY BLOCK----- Publishing bouncers \u00b6 We do welcome bouncers from the community, and will gladly publish them on the hub. Why ? \u00b6 Sharing your bouncer on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it. How ? \u00b6 To have your bouncer published on the hub, please simply open a new issue on the hub , requesting \"bouncer inclusion\". The bouncer will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it ! The information that should be stated in your issue are : The source repository of your bouncer (for example https://github.com/crowdsecurity/cs-firewall-bouncer/ ) The software licence used The current status of the bouncer (stage : dev/unstable/stable) Documentation (can be simply in the README.md) : must contains : installing, uninstalling should contains : configuration documentation Link to existing tests if applicable (functional tests or unit tests) Please take care of the following : Ensure your repository has a About/Short description meaningful enough : it will be displayed in the hub Ensure your repository has a decent README.md file : it will be displayed in the hub Ensure your repository has at least one release : this is what users will be looking for (ideally) Have a \"social preview image\" on your repository : this will be displayed in the hub when available (ideally) A Howto or link to guide that provides a hands-on experience with the bouncer Please find below a template : Hello, I would like to suggest the addition of the `XXXX` to the hub : - Source repository: https://github.com/xxx/xxx/ - Licence : MIT - Current status : stable (has been used in production for a while) - README/doc : https://github.com/xxx/xxx/blob/main/README.md - Existing tests : - functional tests : https://github.com/xxx/xxx/blob/main/.github/workflows/tests.yml - Short/Long description : OK - Howto : in README - At least one release : yes Publishing parsers, scenarios and collections \u00b6 Why ? \u00b6 Sharing your parsers, scenarios and collections on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it. How ? \u00b6 To have your parser/scenario published on the hub, please simply open a new issue on the hub , requesting \"parser/scenario inclusion\". The configurations will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it !","title":"Guide"},{"location":"contributing/#contributing","text":"You have an idea, a suggestion or you spotted a mistake ? Help us improve the software and the user experience, to make the internet a safer place together !","title":"Contributing"},{"location":"contributing/#contributing-to-the-documentation","text":"If you spotted some mistakes in the documentation or have improvement suggestions, you can : open a {{v1X.doc.new_issue}} if you are comfortable with github let us know on {{v1X.doc.discourse}} if you want to discuss about it Let us as well know if you have some improvement suggestions ! Preview your documentation changes locally python3 -m venv cs-env source cs-env/bin/activate pip install -r docs/requirements.txt mkdocs serve","title":"Contributing to the documentation"},{"location":"contributing/#contributing-to-the-code","text":"If you want to report a bug, you can use the github bugtracker If you want to suggest an improvement you can use either the github bugtracker or the {{v1X.doc.discourse}} if you want to discuss","title":"Contributing to the code"},{"location":"contributing/#contributing-to-the-parsersscenarios","text":"If you want to contribute your parser or scenario to the community and have them appear on the {{v1X.hub.htmlname}}, you should open a merge request on the hub. We are currently working on a proper CI for the {{v1X.hub.htmlname}}, so for now all contribution are subject to peer-review, please bear with us !","title":"Contributing to the parsers/scenarios"},{"location":"contributing/#contacting-the-team","text":"If you want to contact us using non-public media, you can contact us on support AT crowdsec DOT net with the following gpg-key : -----BEGIN PGP PUBLIC KEY BLOCK----- mQGNBF+VOSUBDADP6bxKDv88CdLBNhQMFNI37LE82vyfIAQmrGszON1m1EtL/LSQ b/vC9mmlkUmJHM+bdxJ0BSl/xlWwrXjHVpaZNoluQDngVUe62cybN4tpFCvtVTMr lo4Y0UhETgOmBFxaQLVd7Xc/jaSZGoHtSzh9hpGHg9pKrcYviG0MR173JYQfilw3 L8yJ+K/oUUpvh2MRRwXiCNUVLtTppb7oxlcdExb0Px2PcaC34e/M30xFwiu7VJFj 0D7IIdKs6gvZuqwkNSUBF8/jtuzzM/YGzJHIdvOj15z+81/o/e6p3xvY/IKmyXC/ 1FMD8f4g5T/5fNDVq6QgJLel/g0bJ+kG75ccXfY45xKFo/YhdQ2Wg9JQX5Yjc5k7 5AI0iuJjatXlym2Ek1niPEqR5H0C/KXFG4mPyCu9wzJu11jtY34e5TNYl9DA31F6 81BbMmVFg4EbhYSN/2DuxpCvt2qQpk33bmdT7tFWcd2hYB/bSq2f8+K6ho50Sqwk PK68LNZzi5ZXqGEAEQEAAbQnQ3Jvd2RTZWMgc3VwcG9ydCA8c3VwcG9ydEBjcm93 ZHNlYy5uZXQ+iQHUBBMBCgA+FiEEpRXNfWM+DON/Satp2MpQXYwzLTEFAl+VOSUC GwMFCQPCZwAFCwkIBwIGFQoJCAsCBBYCAwECHgECF4AACgkQ2MpQXYwzLTEhuwwA wWdsuSrTC4ryVOYnfHRcT2b/rfbJXIUYXqAy75qsdUGwvueYdYSBMCMXqRB65J+J juofCF0kTQKuhjtyJezwUfr5C+Sd08JWlZwf9F7CO83/ztLOPIUUp69H3m9heW7C +A/Lpq3epALytC/QSkDHYnKBBZbLhoR/7WXhdLFvh+A475/ggn4GAOnZMg8WULpR Kisu1GbEBPcVr1Xl6VTYVX5ghA/1W2WTY/NxAcLhCiJO/ENeka7xy4EKdCE5pDxM QO/fnpCHsWDIHTxpCx+JAhdkb2BIvzSiF2+o+9y+vwzcPxdGemx7y8MjSGXIp1xp TJparq309nljh+wqI6w/K+NjzNn/qJL0tpGqiHQXtYDbi86KaAXT9IYCGAIP36w8 XUHYGgo0s6zMEP1NEFHWAgGy5elO403vm+NO5vpHv59FTjgoK2UcjeSjqtAYwzvc bWQ6wZHwhoqD0WevFcAMmgdbebyOdPoA7+8eCPnkjER4eKxE23ffFU75HDuQNRYk uQGNBF+VOSUBDADNHEm33IcwhO+uJQxjKtcF0DdAMqbjU5cXxeryo1i7A1WkTH5/ wHfyJAmtLrY4abkQ1LEJ4bMYKdJz2vmvWq0fKCAXC18yLnxU+l0Ld4tWME8hJ/Wh p+aePsW5BdLpHQeqmQ5MCsw1cZllbURcee22hLJ/PIM2bRsZp7goSj4wXBFjhJyq EepVmasI17dBbIBFWBSSIJW4UnSBk+Zqbj6C6PDmsket68qcEebsqduWXPxegAzh IIFD2qhC5t+nn5i+hPwKZN5ZYLQJeAjI4Z7wi3FIBZCzZ214421BbohxPo+GKkFp mUQ7ZrIa+goHXAcj6ZHMeNNP0lsJRl91lK6NVu3p+Ygl0+wbMOAqDRguMfFdbnV8 gcoYpAyk4YFCfgVQLuKGaYcGjcMP8+nZnPsbaTwbUKkjDAUo+JGmrB4XyAQPugZq TiUN+lYgTs0cJALEQkKTh2w10TPyV6/YsYDSSnwJeVDIpNCQVg5EB0eRvhaCs9fd dVni1C5RMcb+Q4MAEQEAAYkBvAQYAQoAJhYhBKUVzX1jPgzjf0mradjKUF2MMy0x BQJflTklAhsMBQkDwmcAAAoJENjKUF2MMy0xkIcL/johqZbyHskQIaTfQUgASbbu bdLXSrIkB8Ort9WULxdqs8hveFy6RjXFJWFitFHk46Bj6FJ1ZykfozL+k9uOGrL9 lBk1e3bhqMVhW1o00DufgawNU2FU9NuH/rCuGpum9DE0cc1fFmQ3pjeiHV55GYxr BGuyyals1ORwK06h+1VFMHrGB12SR7Imgo7FWuexhgLyOK4t1MXg3E4h72qaowpj 5B45qG9jUXgIFKR1D8G8tPeDYLbd37pskNDFozzfAe/H2fqmEjQxMLHrk7J8I3wQ FPvKIvUF8M3NqZjyaFSiisOn32AS3RAsI8RuD4T2XgpE2L6e29u3RpJkvhPbcAN6 w0W8yw3z1/2uHSvYbwoH1cn4akAikYR9aVVHv86AvNlr0BguqWdzEfiGT6mcJ/hH 2sGQJ1nJRgGpAlx/2HpsLJxhJwLVbXSDSk6Bu2T9G/VIda95niVgq6MfE9GSS+MS ucVcwqjIXn/9V6+pFZ11soXNKuTk4Wx+uO2r/i5bVA== =Edl+ -----END PGP PUBLIC KEY BLOCK-----","title":"Contacting the team"},{"location":"contributing/#publishing-bouncers","text":"We do welcome bouncers from the community, and will gladly publish them on the hub.","title":"Publishing bouncers"},{"location":"contributing/#why","text":"Sharing your bouncer on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it.","title":"Why ?"},{"location":"contributing/#how","text":"To have your bouncer published on the hub, please simply open a new issue on the hub , requesting \"bouncer inclusion\". The bouncer will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it ! The information that should be stated in your issue are : The source repository of your bouncer (for example https://github.com/crowdsecurity/cs-firewall-bouncer/ ) The software licence used The current status of the bouncer (stage : dev/unstable/stable) Documentation (can be simply in the README.md) : must contains : installing, uninstalling should contains : configuration documentation Link to existing tests if applicable (functional tests or unit tests) Please take care of the following : Ensure your repository has a About/Short description meaningful enough : it will be displayed in the hub Ensure your repository has a decent README.md file : it will be displayed in the hub Ensure your repository has at least one release : this is what users will be looking for (ideally) Have a \"social preview image\" on your repository : this will be displayed in the hub when available (ideally) A Howto or link to guide that provides a hands-on experience with the bouncer Please find below a template : Hello, I would like to suggest the addition of the `XXXX` to the hub : - Source repository: https://github.com/xxx/xxx/ - Licence : MIT - Current status : stable (has been used in production for a while) - README/doc : https://github.com/xxx/xxx/blob/main/README.md - Existing tests : - functional tests : https://github.com/xxx/xxx/blob/main/.github/workflows/tests.yml - Short/Long description : OK - Howto : in README - At least one release : yes","title":"How ?"},{"location":"contributing/#publishing-parsers-scenarios-and-collections","text":"","title":"Publishing parsers, scenarios and collections"},{"location":"contributing/#why_1","text":"Sharing your parsers, scenarios and collections on the hub allows other users to find it and use it. While increasing your code's visibility, it ensures as well a benevolent look from the community and the team over it.","title":"Why ?"},{"location":"contributing/#how_1","text":"To have your parser/scenario published on the hub, please simply open a new issue on the hub , requesting \"parser/scenario inclusion\". The configurations will then be reviewed by the team, and then will be published directly on the hub, for everyone to find & use it !","title":"How ?"},{"location":"faq/","text":"FREQUENTLY ASKED QUESTIONS \u00b6 What is {{v1X.crowdsec.name}} ? \u00b6 {{v1X.crowdsec.Name}} is a security open-source software. See the overview . I've installed crowdsec, it detects attacks but doesn't block anything ?! \u00b6 Yes, {{v1X.crowdsec.Name}} is in charge of detecting attacks, and {{v1X.bouncers.htmlname}} are applying decisions. If you want to block the detected IPs, you should deploy a bouncer, such as the ones found on the hub ! What language is it written in ? \u00b6 {{v1X.crowdsec.Name}} is written in Golang . What licence is {{v1X.crowdsec.name}} released under ? \u00b6 {{v1X.crowdsec.Name}} is under MIT license . Which information is sent to the APIs ? \u00b6 Our aim is to build a strong community that can share malevolent attackers IPs, for that we need to collect the bans triggered locally by each user. The signal sent by your {{v1X.crowdsec.name}} to the central API only contains only meta-data about the attack : Attacker IP Scenario name Time of start/end of attack Your logs are not sent to our central API, only meta-data about blocked attacks will be. When pulling block-lists from the platform, the following information is shared as well : list of upstream installed scenarios list of bouncers & number of machines What is the performance impact ? \u00b6 As {{v1X.crowdsec.name}} only works on logs, it shouldn't impact your production. When it comes to {{v1X.bouncers.name}}, it should perform one request to the database when a new IP is discovered thus have minimal performance impact. How fast is it ? \u00b6 {{v1X.crowdsec.name}} can easily handle several thousands of events per second on a rich pipeline (multiple parsers, geoip enrichment, scenarios and so on). Logs are a good fit for sharding by default, so it is definitely the way to go if you need to handle higher throughput. If you need help for large scale deployment, please get in touch with us on the {{v1X.doc.discourse}}, we love challenges ;) What backend database does {{v1X.crowdsec.Name}} supports and how to switch ? \u00b6 {{v1X.crowdsec.name}} versions (under v0.3.X) supports SQLite (default) and MySQL databases. See backend configuration for relevant configuration. MySQL here is more suitable for distributed architectures where bouncers across the applicative stack need to access a centralized ban database. {{v1X.crowdsec.name}} versions (after v1) supports SQLite (default), MySQL and PostgreSQL databases. See databases configuration for relevant configuration. Thanks to the {{v1X.lapi.Htmlname}}, distributed architectures are resolved even with sqlite database. SQLite by default as it's suitable for standalone/single-machine setups. How to control granularity of actions ? (whitelists, simulation etc.) \u00b6 {{v1X.crowdsec.name}} support both whitelists and simulation : Whitelists allows you to \"discard\" events or overflows Simulation allows you to simply cancel the decision that is going to be taken, but keep track of it {{v1X.profiles.htmlname}} allows you to control which decision will be applied to which alert. How to know if my setup is working correctly ? Some of my logs are unparsed, is it normal ? \u00b6 Yes, crowdsec parsers only parse the logs that are relevant for scenarios :) Take a look at cscli metrics and understand what do they mean to know if your setup is correct. How to add whitelists ? \u00b6 You can follow this guide How to set up proxy ? \u00b6 Setting up a proxy works out of the box, the net/http golang library can handle those environment variables: HTTP_PROXY HTTPS_PROXY NO_PROXY For example: export HTTP_PROXY=http://<proxy_url>:<proxy_port> Systemd variable \u00b6 On Systemd devices you have to set the proxy variable in the environment section for the CrowdSec service. To avoid overwriting the service file during an update, a folder is created in /etc/systemd/system/crowdsec.service.d and a file in it named http-proxy.conf . The content for this file should look something like this: [Service] Environment=HTTP_PROXY=http://myawesomeproxy.com:8080 Environment=HTTPS_PROXY=https://myawesomeproxy.com:443 After this change you need to reload the systemd daemon using: systemctl daemon-reload Then you can restart CrowdSec like this: systemctl restart crowdsec Sudo \u00b6 If you use sudo {{v1X.cli.name}}, just add this line in visudo after setting up the previous environment variables: Defaults env_keep += \"HTTP_PROXY HTTPS_PROXY NO_PROXY\" How to report a bug ? \u00b6 To report a bug, please open an issue on the repository . What about false positives ? \u00b6 Several initiatives have been taken to tackle the false positives approach as early as possible : The scenarios published on the hub are tailored to favor low false positive rates You can find generic whitelists that should allow to cover most common cases (SEO whitelists, CDN whitelists etc.) The simulation configuration allows you to keep a tight control over scenario and their false positives I need some help \u00b6 Feel free to ask for some help to the {{v1X.doc.discourse}} or directly in the {{v1X.doc.gitter}} chat. How to use crowdsec on raspberry pi OS (formerly known as rasbian) \u00b6 Please keep in mind that raspberry pi OS is designed to work on all raspberry pi versions. Even if the port target is known as armhf, it's not exactly the same target as the debian named armhf port. The best way to have a crowdsec version for such an architecture is to do: install golang (all versions from 1.13 will do) export GOARCH=arm export CGO=1 Update the GOARCH variable in the Makefile to arm install the arm gcc cross compilator (On debian the package is gcc-arm-linux-gnueabihf) Compile crowdsec using the usual make command How to have a dashboard without docker \u00b6 cscli dashboard rely on docker to launch the metabase image. If docker is not installed on your machine, here are the step to follow to get crowdsec dashboards without docker: Download Metabase jar file. See metabase documentation . Download the metabase.db folder from Crowdsec here . Unzip the zip file: unzip metabase_sqlite.zip Make crowdsec database reachable from metabase : sudo mkdir /metabase-data/ sudo ln -s /var/lib/crowdsec/data/crowdsec.db /metabase-data/crowdsec.db Launch Metabase: sudo MB_DB_TYPE = h2 MB_DB_FILE = <absolute-path>/metabase.db/metabase.db java -jar metabase.jar Warning The default username is crowdsec@crowdsec.net and the default password is !!Cr0wdS3c_M3t4b4s3?? . Please update the password when you will connect to metabase for the first time You can as well check liberodark's helper script for it . How to configure crowdsec/cscli to use Tor \u00b6 It is possible to configure cscli and crowdsec to use tor to anonymously interact with our API. All (http) requests made to the central API to go through the tor network . With tor installed, setting HTTP_PROXY and HTTPS_PROXY environment variables to your socks5 proxy will do the trick. Running the wizard with tor \u00b6 $ sudo HTTPS_PROXY = socks5://127.0.0.1:9050 HTTP_PROXY = socks5://127.0.0.1:9050 ./wizard.sh --bininstall Warning Do not use the wizard in interactive ( -i ) mode if you're concerned, as it will start the service at the end of the setup, leaking your IP address. Edit crowdsec systemd unit to push/pull via tor \u00b6 [ Service ] Environment = \"HTTPS_PROXY=socks5://127.0.0.1:9050\" Environment = \"HTTP_PROXY=socks5://127.0.0.1:9050\" ... Using cscli via tor \u00b6 $ sudo HTTP_PROXY = socks5://127.0.0.1:9050 HTTPS_PROXY = socks5://127.0.0.1:9050 cscli capi register","title":"Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"FREQUENTLY ASKED QUESTIONS"},{"location":"faq/#what-is-v1xcrowdsecname","text":"{{v1X.crowdsec.Name}} is a security open-source software. See the overview .","title":"What is {{v1X.crowdsec.name}} ?"},{"location":"faq/#ive-installed-crowdsec-it-detects-attacks-but-doesnt-block-anything","text":"Yes, {{v1X.crowdsec.Name}} is in charge of detecting attacks, and {{v1X.bouncers.htmlname}} are applying decisions. If you want to block the detected IPs, you should deploy a bouncer, such as the ones found on the hub !","title":"I've installed crowdsec, it detects attacks but doesn't block anything ?!"},{"location":"faq/#what-language-is-it-written-in","text":"{{v1X.crowdsec.Name}} is written in Golang .","title":"What language is it written in ?"},{"location":"faq/#what-licence-is-v1xcrowdsecname-released-under","text":"{{v1X.crowdsec.Name}} is under MIT license .","title":"What licence is {{v1X.crowdsec.name}} released under ?"},{"location":"faq/#which-information-is-sent-to-the-apis","text":"Our aim is to build a strong community that can share malevolent attackers IPs, for that we need to collect the bans triggered locally by each user. The signal sent by your {{v1X.crowdsec.name}} to the central API only contains only meta-data about the attack : Attacker IP Scenario name Time of start/end of attack Your logs are not sent to our central API, only meta-data about blocked attacks will be. When pulling block-lists from the platform, the following information is shared as well : list of upstream installed scenarios list of bouncers & number of machines","title":"Which information is sent to the APIs ?"},{"location":"faq/#what-is-the-performance-impact","text":"As {{v1X.crowdsec.name}} only works on logs, it shouldn't impact your production. When it comes to {{v1X.bouncers.name}}, it should perform one request to the database when a new IP is discovered thus have minimal performance impact.","title":"What is the performance impact ?"},{"location":"faq/#how-fast-is-it","text":"{{v1X.crowdsec.name}} can easily handle several thousands of events per second on a rich pipeline (multiple parsers, geoip enrichment, scenarios and so on). Logs are a good fit for sharding by default, so it is definitely the way to go if you need to handle higher throughput. If you need help for large scale deployment, please get in touch with us on the {{v1X.doc.discourse}}, we love challenges ;)","title":"How fast is it ?"},{"location":"faq/#what-backend-database-does-v1xcrowdsecname-supports-and-how-to-switch","text":"{{v1X.crowdsec.name}} versions (under v0.3.X) supports SQLite (default) and MySQL databases. See backend configuration for relevant configuration. MySQL here is more suitable for distributed architectures where bouncers across the applicative stack need to access a centralized ban database. {{v1X.crowdsec.name}} versions (after v1) supports SQLite (default), MySQL and PostgreSQL databases. See databases configuration for relevant configuration. Thanks to the {{v1X.lapi.Htmlname}}, distributed architectures are resolved even with sqlite database. SQLite by default as it's suitable for standalone/single-machine setups.","title":"What backend database does {{v1X.crowdsec.Name}} supports and how to switch ?"},{"location":"faq/#how-to-control-granularity-of-actions-whitelists-simulation-etc","text":"{{v1X.crowdsec.name}} support both whitelists and simulation : Whitelists allows you to \"discard\" events or overflows Simulation allows you to simply cancel the decision that is going to be taken, but keep track of it {{v1X.profiles.htmlname}} allows you to control which decision will be applied to which alert.","title":"How to control granularity of actions ? (whitelists, simulation etc.)"},{"location":"faq/#how-to-know-if-my-setup-is-working-correctly-some-of-my-logs-are-unparsed-is-it-normal","text":"Yes, crowdsec parsers only parse the logs that are relevant for scenarios :) Take a look at cscli metrics and understand what do they mean to know if your setup is correct.","title":"How to know if my setup is working correctly ? Some of my logs are unparsed, is it normal ?"},{"location":"faq/#how-to-add-whitelists","text":"You can follow this guide","title":"How to add whitelists ?"},{"location":"faq/#how-to-set-up-proxy","text":"Setting up a proxy works out of the box, the net/http golang library can handle those environment variables: HTTP_PROXY HTTPS_PROXY NO_PROXY For example: export HTTP_PROXY=http://<proxy_url>:<proxy_port>","title":"How to set up proxy ?"},{"location":"faq/#systemd-variable","text":"On Systemd devices you have to set the proxy variable in the environment section for the CrowdSec service. To avoid overwriting the service file during an update, a folder is created in /etc/systemd/system/crowdsec.service.d and a file in it named http-proxy.conf . The content for this file should look something like this: [Service] Environment=HTTP_PROXY=http://myawesomeproxy.com:8080 Environment=HTTPS_PROXY=https://myawesomeproxy.com:443 After this change you need to reload the systemd daemon using: systemctl daemon-reload Then you can restart CrowdSec like this: systemctl restart crowdsec","title":"Systemd variable"},{"location":"faq/#sudo","text":"If you use sudo {{v1X.cli.name}}, just add this line in visudo after setting up the previous environment variables: Defaults env_keep += \"HTTP_PROXY HTTPS_PROXY NO_PROXY\"","title":"Sudo"},{"location":"faq/#how-to-report-a-bug","text":"To report a bug, please open an issue on the repository .","title":"How to report a bug ?"},{"location":"faq/#what-about-false-positives","text":"Several initiatives have been taken to tackle the false positives approach as early as possible : The scenarios published on the hub are tailored to favor low false positive rates You can find generic whitelists that should allow to cover most common cases (SEO whitelists, CDN whitelists etc.) The simulation configuration allows you to keep a tight control over scenario and their false positives","title":"What about false positives ?"},{"location":"faq/#i-need-some-help","text":"Feel free to ask for some help to the {{v1X.doc.discourse}} or directly in the {{v1X.doc.gitter}} chat.","title":"I need some help"},{"location":"faq/#how-to-use-crowdsec-on-raspberry-pi-os-formerly-known-as-rasbian","text":"Please keep in mind that raspberry pi OS is designed to work on all raspberry pi versions. Even if the port target is known as armhf, it's not exactly the same target as the debian named armhf port. The best way to have a crowdsec version for such an architecture is to do: install golang (all versions from 1.13 will do) export GOARCH=arm export CGO=1 Update the GOARCH variable in the Makefile to arm install the arm gcc cross compilator (On debian the package is gcc-arm-linux-gnueabihf) Compile crowdsec using the usual make command","title":"How to use crowdsec on raspberry pi OS (formerly known as rasbian)"},{"location":"faq/#how-to-have-a-dashboard-without-docker","text":"cscli dashboard rely on docker to launch the metabase image. If docker is not installed on your machine, here are the step to follow to get crowdsec dashboards without docker: Download Metabase jar file. See metabase documentation . Download the metabase.db folder from Crowdsec here . Unzip the zip file: unzip metabase_sqlite.zip Make crowdsec database reachable from metabase : sudo mkdir /metabase-data/ sudo ln -s /var/lib/crowdsec/data/crowdsec.db /metabase-data/crowdsec.db Launch Metabase: sudo MB_DB_TYPE = h2 MB_DB_FILE = <absolute-path>/metabase.db/metabase.db java -jar metabase.jar Warning The default username is crowdsec@crowdsec.net and the default password is !!Cr0wdS3c_M3t4b4s3?? . Please update the password when you will connect to metabase for the first time You can as well check liberodark's helper script for it .","title":"How to have a dashboard without docker"},{"location":"faq/#how-to-configure-crowdseccscli-to-use-tor","text":"It is possible to configure cscli and crowdsec to use tor to anonymously interact with our API. All (http) requests made to the central API to go through the tor network . With tor installed, setting HTTP_PROXY and HTTPS_PROXY environment variables to your socks5 proxy will do the trick.","title":"How to configure crowdsec/cscli to use Tor"},{"location":"faq/#running-the-wizard-with-tor","text":"$ sudo HTTPS_PROXY = socks5://127.0.0.1:9050 HTTP_PROXY = socks5://127.0.0.1:9050 ./wizard.sh --bininstall Warning Do not use the wizard in interactive ( -i ) mode if you're concerned, as it will start the service at the end of the setup, leaking your IP address.","title":"Running the wizard with tor"},{"location":"faq/#edit-crowdsec-systemd-unit-to-pushpull-via-tor","text":"[ Service ] Environment = \"HTTPS_PROXY=socks5://127.0.0.1:9050\" Environment = \"HTTP_PROXY=socks5://127.0.0.1:9050\" ...","title":"Edit crowdsec systemd unit to push/pull via tor"},{"location":"faq/#using-cscli-via-tor","text":"$ sudo HTTP_PROXY = socks5://127.0.0.1:9050 HTTPS_PROXY = socks5://127.0.0.1:9050 cscli capi register","title":"Using cscli via tor"},{"location":"migration/","text":"Migration from v0.X to v1.X \u00b6 Warning Migrating to V1.X will impact (any change you made will be lost and must be adapted to the new configuration) : Database model : your existing database will be lost, a new one will be created in the V1. {{v1X.crowdsec.Name}} configuration : /etc/crowdsec/config/default.yaml : check new format /etc/crowdsec/config/profiles.yaml : check new format To upgrade {{v0X.crowdsec.name}} from v0.X to v1, we'll follow those steps Backup up configuration \u00b6 sudo cscli backup save /tmp/crowdsec_backup sudo cp -R /etc/crowdsec/config/patterns /tmp/crowdsec_backup Uninstall old version & install new \u00b6 Download latest V1 {{v0X.crowdsec.name}} version here tar xvzf crowdsec-release.tgz cd crowdsec-v1*/ sudo ./wizard.sh --uninstall sudo ./wizard.sh --bininstall Warning Don't forget to remove {{v0X.metabase.name}} dashboard if you installed it manually (without {{v0X.cli.name}}). Restore configuration \u00b6 Warning Before restoring old backup, if you have local or tainted postoverflows, be aware that they are no longer compatible. You should update the syntax (the community and us are available to help you doing this part). sudo cscli hub update sudo cscli config restore --old-backup /tmp/crowdsec_backup/ sudo cp -R /tmp/crowdsec_backup/patterns /etc/crowdsec/ Start & health check \u00b6 Finally, you will be able to start {{v0X.crowdsec.name}} service. Before that, just check if {{v1X.lapi.name}} and {{v0X.api.name}} are correctly configured. ubuntu@ip-:~$ sudo cscli lapi status INFO[0000] Loaded credentials from /etc/crowdsec/local_api_credentials.yaml INFO[0000] Trying to authenticate with username 941c3fxxxxxxxxxxxxxxxxxxxxxx on http://localhost:8080/ INFO[0000] You can successfully interact with Local API (LAPI) ubuntu@ip-:~$ sudo cscli capi status INFO[0000] Loaded credentials from /etc/crowdsec/online_api_credentials.yaml INFO[0000] Trying to authenticate with username 941c3fxxxxxxxxxxxxxxxxxxxxxxx on https://api.crowdsec.net/ INFO[0000] You can successfully interact with Central API (CAPI) ubuntu@ip-:~$ sudo systemctl start crowdsec.service ubuntu@ip-:~$ sudo systemctl status crowdsec.service You can even check logs (located by default here: /var/log/crowdsec.log & /var/log/crowdsec_api.log ). You can now navigate documentation to learn new {{v0X.cli.name}} commands to interact with crowdsec. Upgrade {{v0X.bouncers.name}} \u00b6 If you were using {{v0X.bouncers.name}} (formerly called blocker(s) ), you need to replace them by the new compatibles {{v0X.bouncers.name}}, available on the hub (selecting agent version to v1 ). Following your bouncer type (netfilter, nginx, wordpress etc...), you need to replace them by the new available {{v0X.bouncers.name}} on the hub, please follow the {{v0X.bouncers.name}} documentation that will help you to install easily. We're also available to help (on discourse or gitter ) upgrading your {{v0X.bouncers.name}}.","title":"Upgrade V0.X to V1.X"},{"location":"migration/#migration-from-v0x-to-v1x","text":"Warning Migrating to V1.X will impact (any change you made will be lost and must be adapted to the new configuration) : Database model : your existing database will be lost, a new one will be created in the V1. {{v1X.crowdsec.Name}} configuration : /etc/crowdsec/config/default.yaml : check new format /etc/crowdsec/config/profiles.yaml : check new format To upgrade {{v0X.crowdsec.name}} from v0.X to v1, we'll follow those steps","title":"Migration from v0.X to v1.X"},{"location":"migration/#backup-up-configuration","text":"sudo cscli backup save /tmp/crowdsec_backup sudo cp -R /etc/crowdsec/config/patterns /tmp/crowdsec_backup","title":"Backup up configuration"},{"location":"migration/#uninstall-old-version-install-new","text":"Download latest V1 {{v0X.crowdsec.name}} version here tar xvzf crowdsec-release.tgz cd crowdsec-v1*/ sudo ./wizard.sh --uninstall sudo ./wizard.sh --bininstall Warning Don't forget to remove {{v0X.metabase.name}} dashboard if you installed it manually (without {{v0X.cli.name}}).","title":"Uninstall old version &amp; install new"},{"location":"migration/#restore-configuration","text":"Warning Before restoring old backup, if you have local or tainted postoverflows, be aware that they are no longer compatible. You should update the syntax (the community and us are available to help you doing this part). sudo cscli hub update sudo cscli config restore --old-backup /tmp/crowdsec_backup/ sudo cp -R /tmp/crowdsec_backup/patterns /etc/crowdsec/","title":"Restore configuration"},{"location":"migration/#start-health-check","text":"Finally, you will be able to start {{v0X.crowdsec.name}} service. Before that, just check if {{v1X.lapi.name}} and {{v0X.api.name}} are correctly configured. ubuntu@ip-:~$ sudo cscli lapi status INFO[0000] Loaded credentials from /etc/crowdsec/local_api_credentials.yaml INFO[0000] Trying to authenticate with username 941c3fxxxxxxxxxxxxxxxxxxxxxx on http://localhost:8080/ INFO[0000] You can successfully interact with Local API (LAPI) ubuntu@ip-:~$ sudo cscli capi status INFO[0000] Loaded credentials from /etc/crowdsec/online_api_credentials.yaml INFO[0000] Trying to authenticate with username 941c3fxxxxxxxxxxxxxxxxxxxxxxx on https://api.crowdsec.net/ INFO[0000] You can successfully interact with Central API (CAPI) ubuntu@ip-:~$ sudo systemctl start crowdsec.service ubuntu@ip-:~$ sudo systemctl status crowdsec.service You can even check logs (located by default here: /var/log/crowdsec.log & /var/log/crowdsec_api.log ). You can now navigate documentation to learn new {{v0X.cli.name}} commands to interact with crowdsec.","title":"Start &amp; health check"},{"location":"migration/#upgrade-v0xbouncersname","text":"If you were using {{v0X.bouncers.name}} (formerly called blocker(s) ), you need to replace them by the new compatibles {{v0X.bouncers.name}}, available on the hub (selecting agent version to v1 ). Following your bouncer type (netfilter, nginx, wordpress etc...), you need to replace them by the new available {{v0X.bouncers.name}} on the hub, please follow the {{v0X.bouncers.name}} documentation that will help you to install easily. We're also available to help (on discourse or gitter ) upgrading your {{v0X.bouncers.name}}.","title":"Upgrade {{v0X.bouncers.name}}"},{"location":"bouncers/","text":"bouncers \u00b6 {{v0X.bouncers.Name}} are standalone software pieces in charge of acting upon blocked IPs. They can either within the applicative stack, or work out of band : nginx blocker will check every unknown IP against the database before letting go through or serving a 403 to the user, while a netfilter blocker will simply \"add\" malevolent IPs to nftables/ipset set of blacklisted IPs. You can explore available {{v0X.bouncers.name}} on the hub , and find below a few of the \"main\" {{v0X.bouncers.name}} :","title":"bouncers"},{"location":"bouncers/#bouncers","text":"{{v0X.bouncers.Name}} are standalone software pieces in charge of acting upon blocked IPs. They can either within the applicative stack, or work out of band : nginx blocker will check every unknown IP against the database before letting go through or serving a 403 to the user, while a netfilter blocker will simply \"add\" malevolent IPs to nftables/ipset set of blacklisted IPs. You can explore available {{v0X.bouncers.name}} on the hub , and find below a few of the \"main\" {{v0X.bouncers.name}} :","title":"bouncers"},{"location":"cheat_sheets/ban-mgmt/","text":"Info Please see your local {{v0X.cli.bin}} help ban for up-to-date documentation. List bans \u00b6 {{ v0X.cli.bin }} ban list example bui@sd:~$ cli ban list 4 local decisions: +--------+----------------+----------------------+------+--------+---------+--------------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+----------------+----------------------+------+--------+---------+--------------------------------+--------+------------+ | cli | 1 .1.1.1 | spammer | 1 | ban | | | 0 | 23h59m58s | | local | 2 .2.2.2 | crowdsecurity/ssh-bf | 1 | ban | FR | 3215 Orange | 6 | 3h7m30s | | local | 3 .3.3.3 | crowdsecurity/ssh-bf | 1 | ban | US | 3266 Joao Carlos de Almeida | 6 | 57m17s | | | | | | | | Silveira trading as Bitcanal | | | | local | 4 .4.4.4 | crowdsecurity/ssh-bf | 1 | ban | FR | 15557 SFR SA | 6 | 5m11s | +--------+----------------+----------------------+------+--------+---------+--------------------------------+--------+------------+ And 64 records from API, 32 distinct AS, 19 distinct countries SOURCE is the source of the decision : \"local\" : the decision has been taken by {{v0X.crowdsec.name}} \"cli\" : the decision has been made with {{v0X.cli.name}} (ie. {{v0X.cli.name}} ban ip 1.2.3.4 24h \"because\" ) \"api\" : the decision has been pushed to you by the API (because there is a consensus about this ip) IP is the IP or the IP range impacted by the decision REASON is the scenario that was triggered (or human-supplied reason) BANS is the number of \"active\" remediation against this IP COUNTRY and AS are provided by GeoIP enrichment if present EXPIRATION is the time left on remediation Check command usage for additional filtering and output control flags. Delete a ban \u00b6 delete the ban on IP 1.2.3.4 {{ v0X.cli.bin }} ban del ip 1 .2.3.4 delete the ban on range 1.2.3.0/24 {{ v0X.cli.bin }} ban del range 1 .2.3.0/24 Add a ban manually \u00b6 Add a ban on IP 1.2.3.4 for 24 hours, with reason 'web bruteforce' {{ v0X.cli.bin }} ban add ip 1 .2.3.4 24h \"web bruteforce\" Add a ban on range 1.2.3.0/24 for 24 hours, with reason 'web bruteforce' {{ v0X.cli.bin }} ban add range 1 .2.3.0/24 \"web bruteforce\" Flush all existing bans \u00b6 Flush all the existing bans {{ v0X.cli.bin }} ban flush Warning This will as well remove any existing ban","title":"Ban Management"},{"location":"cheat_sheets/ban-mgmt/#list-bans","text":"{{ v0X.cli.bin }} ban list example bui@sd:~$ cli ban list 4 local decisions: +--------+----------------+----------------------+------+--------+---------+--------------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+----------------+----------------------+------+--------+---------+--------------------------------+--------+------------+ | cli | 1 .1.1.1 | spammer | 1 | ban | | | 0 | 23h59m58s | | local | 2 .2.2.2 | crowdsecurity/ssh-bf | 1 | ban | FR | 3215 Orange | 6 | 3h7m30s | | local | 3 .3.3.3 | crowdsecurity/ssh-bf | 1 | ban | US | 3266 Joao Carlos de Almeida | 6 | 57m17s | | | | | | | | Silveira trading as Bitcanal | | | | local | 4 .4.4.4 | crowdsecurity/ssh-bf | 1 | ban | FR | 15557 SFR SA | 6 | 5m11s | +--------+----------------+----------------------+------+--------+---------+--------------------------------+--------+------------+ And 64 records from API, 32 distinct AS, 19 distinct countries SOURCE is the source of the decision : \"local\" : the decision has been taken by {{v0X.crowdsec.name}} \"cli\" : the decision has been made with {{v0X.cli.name}} (ie. {{v0X.cli.name}} ban ip 1.2.3.4 24h \"because\" ) \"api\" : the decision has been pushed to you by the API (because there is a consensus about this ip) IP is the IP or the IP range impacted by the decision REASON is the scenario that was triggered (or human-supplied reason) BANS is the number of \"active\" remediation against this IP COUNTRY and AS are provided by GeoIP enrichment if present EXPIRATION is the time left on remediation Check command usage for additional filtering and output control flags.","title":"List bans"},{"location":"cheat_sheets/ban-mgmt/#delete-a-ban","text":"delete the ban on IP 1.2.3.4 {{ v0X.cli.bin }} ban del ip 1 .2.3.4 delete the ban on range 1.2.3.0/24 {{ v0X.cli.bin }} ban del range 1 .2.3.0/24","title":"Delete a ban"},{"location":"cheat_sheets/ban-mgmt/#add-a-ban-manually","text":"Add a ban on IP 1.2.3.4 for 24 hours, with reason 'web bruteforce' {{ v0X.cli.bin }} ban add ip 1 .2.3.4 24h \"web bruteforce\" Add a ban on range 1.2.3.0/24 for 24 hours, with reason 'web bruteforce' {{ v0X.cli.bin }} ban add range 1 .2.3.0/24 \"web bruteforce\"","title":"Add a ban manually"},{"location":"cheat_sheets/ban-mgmt/#flush-all-existing-bans","text":"Flush all the existing bans {{ v0X.cli.bin }} ban flush Warning This will as well remove any existing ban","title":"Flush all existing bans"},{"location":"cheat_sheets/config-mgmt/","text":"{{v0X.cli.bin}} allows you install, list, upgrade and remove configurations : parsers, enrichment, scenarios. Warning If you're not running the latest CrowdSec version, configurations might not be the latest available. cscli will use the branch of the corresponding CrowdSec version to download and install configurations from the hub (it will use the master branch if you are on the latest CrowdSec version). The various parsers, enrichers and scenarios installed on your machine makes a coherent ensemble to provide detection capabilities. Parsers, Scenarios and Enrichers are often bundled together in \"collections\" to facilitate configuration. Parsers, scenarios, enrichers and collections all follow the same principle : {{v0X.cli.bin}} install parser crowdsec/nginx-logs {{v0X.cli.bin}} update collection crowdsec/base-http-scenarios {{v0X.cli.bin}} remove scenario crowdsec/mysql-bf Please see your local {{v0X.cli.bin}} help for up-to-date documentation List configurations \u00b6 {{v0X.cli.bin}} list note -a allows for listing of uninstalled configurations as well {{v0X.cli.name}} list example $ {{ v0X.cli.bin }} list INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] PARSERS: -------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------------- crowdsec/nginx-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml crowdsec/geoip-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/geoip-enrich.yaml crowdsec/syslog-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml crowdsec/whitelists \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/whitelists.yaml crowdsec/http-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/http-logs.yaml crowdsec/dateparse-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/dateparse-enrich.yaml -------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] SCENARIOS: ----------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ----------------------------------------------------------------------------------------------------------------------- crowdsec/http-scan-uniques_404 \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-scan-uniques_404.yaml crowdsec/http-crawl-non_statics \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-crawl-non_statics.yaml ----------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] COLLECTIONS: ------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------------------- crowdsec/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/linux.yaml crowdsec/nginx \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/nginx.yaml crowdsec/base-http-scenarios \u2714\ufe0f enabled 0 .1 /etc/crowdsec/config/collections/base-http-scenarios.yaml ------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] POSTOVERFLOWS: -------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------- -------------------------------------- For {{v0X.parsers.htmlname}}, {{v0X.scenarios.htmlname}}, {{v0X.collections.htmlname}} the outputs include, beside the version, the path and the name, a STATUS column : \u2714\ufe0f enabled : configuration is up-to-date \u26a0\ufe0f enabled,outdated : a newer version is available \ud83d\udeab enabled,local : configuration is not managed by {{v0X.cli.name}} \u26a0\ufe0f enabled,tainted : configuration has been locally modified (see {{v0X.cli.name}} upgrade to upgrade/sync your configurations with {{v0X.hub.htmlname}}) Install new configurations \u00b6 {{v0X.cli.bin}} install parser|scenario|postoverflow <name> [--force] {{v0X.cli.bin}} install parser crowdsec/nginx-logs {{v0X.cli.bin}} install scenario crowdsec/http-scan-uniques_404 Remove configurations \u00b6 {{v0X.cli.bin}} remove parser|scenario|postoverflow <name> [--force] Upgrade configurations \u00b6 upgrade a specific scenario {{v0X.cli.bin}} upgrade scenario crowdsec/http-scan-uniques_404 upgrade all scenarios {{v0X.cli.bin}} upgrade scenario --all upgrade all configurations (parsers, scenarios, collections, postoverflows) {{v0X.cli.bin}} upgrade --all","title":"Configuration Management"},{"location":"cheat_sheets/config-mgmt/#list-configurations","text":"{{v0X.cli.bin}} list note -a allows for listing of uninstalled configurations as well {{v0X.cli.name}} list example $ {{ v0X.cli.bin }} list INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] PARSERS: -------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------------- crowdsec/nginx-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml crowdsec/geoip-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/geoip-enrich.yaml crowdsec/syslog-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml crowdsec/whitelists \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/whitelists.yaml crowdsec/http-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/http-logs.yaml crowdsec/dateparse-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/dateparse-enrich.yaml -------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] SCENARIOS: ----------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ----------------------------------------------------------------------------------------------------------------------- crowdsec/http-scan-uniques_404 \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-scan-uniques_404.yaml crowdsec/http-crawl-non_statics \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-crawl-non_statics.yaml ----------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] COLLECTIONS: ------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------------------- crowdsec/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/linux.yaml crowdsec/nginx \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/nginx.yaml crowdsec/base-http-scenarios \u2714\ufe0f enabled 0 .1 /etc/crowdsec/config/collections/base-http-scenarios.yaml ------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] POSTOVERFLOWS: -------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------- -------------------------------------- For {{v0X.parsers.htmlname}}, {{v0X.scenarios.htmlname}}, {{v0X.collections.htmlname}} the outputs include, beside the version, the path and the name, a STATUS column : \u2714\ufe0f enabled : configuration is up-to-date \u26a0\ufe0f enabled,outdated : a newer version is available \ud83d\udeab enabled,local : configuration is not managed by {{v0X.cli.name}} \u26a0\ufe0f enabled,tainted : configuration has been locally modified (see {{v0X.cli.name}} upgrade to upgrade/sync your configurations with {{v0X.hub.htmlname}})","title":"List configurations"},{"location":"cheat_sheets/config-mgmt/#install-new-configurations","text":"{{v0X.cli.bin}} install parser|scenario|postoverflow <name> [--force] {{v0X.cli.bin}} install parser crowdsec/nginx-logs {{v0X.cli.bin}} install scenario crowdsec/http-scan-uniques_404","title":"Install new configurations"},{"location":"cheat_sheets/config-mgmt/#remove-configurations","text":"{{v0X.cli.bin}} remove parser|scenario|postoverflow <name> [--force]","title":"Remove configurations"},{"location":"cheat_sheets/config-mgmt/#upgrade-configurations","text":"upgrade a specific scenario {{v0X.cli.bin}} upgrade scenario crowdsec/http-scan-uniques_404 upgrade all scenarios {{v0X.cli.bin}} upgrade scenario --all upgrade all configurations (parsers, scenarios, collections, postoverflows) {{v0X.cli.bin}} upgrade --all","title":"Upgrade configurations"},{"location":"cheat_sheets/debugging_configs/","text":"Debugging Scenarios and Parsers \u00b6 General Advice \u00b6 When trying to debug a parser or a scenario : Work on \"cold logs\" (with the -file and -type options) rather than live ones Use the /etc/crowdsec/config/user.yaml configuration files to have logs on stdout Using user-mode configuration \u00b6 crowdsec -c /etc/crowdsec/config/user.yaml -file mylogs.log.gz -type syslog INFO [ 05 -08-2020 16 :15:47 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :15:47 ] Loading grok library ... WARN [ 05 -08-2020 16 :16:12 ] 182 .x.x.x triggered a 4h0m0s ip ban remediation for [ crowdsecurity/http-probing ] bucket_id = misty-moon event_time = \"2019-01-01 22:58:32 +0100 CET\" scenario = crowdsecurity/http-probing source_ip = 182 .x.x.x ... /etc/crowdsec/config/user.yaml disables demonization and push logs to stdout/stderr -type must respect expected log type (ie. nginx syslog etc.) -file must point to a flat file or a gzip file When processing logs like this, {{v0X.crowdsec.name}} runs in \"time machine\" mode, and relies on the timestamps in the logs to evaluate scenarios. You will most likely need the crowdsecurity/dateparse-enrich parser for this. Testing configurations on live system \u00b6 If you're playing around with parser/scenarios on a live system, you can use the -t (lint) option of {{v0X.crowdsec.Name}} to check your configurations validity before restarting/reloading services : $ emacs /etc/crowdsec/config/scenarios/ssh-bf.yaml ... $ crowdsec -c /etc/crowdsec/config/user.yaml -t INFO [ 06 -08-2020 13 :36:04 ] Crowdsec v0.3.0-rc3-4cffef42732944d4b81b3e62a03d4040ad74f185 ... ERRO [ 06 -08-2020 13 :36:05 ] Bad yaml in /etc/crowdsec/config/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory FATA [ 06 -08-2020 13 :36:05 ] Failed to load scenarios: Scenario loading failed : bad yaml in /etc/crowdsec/config/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory Using this, you won't have to kill your running service before you know the scenarios/parsers are at least syntactically correct. Using debug \u00b6 Both scenarios and parsers support a debug: true|false option which produce useful debug. Debug parsing output (expand) DEBU [ 05 -08-2020 15 :25:36 ] eval ( evt.Parsed.program == 'nginx' ) = TRUE id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] eval variables: id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.Parsed.program = 'nginx' id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event entering node id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'request' ] = '/data.php' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_user_agent' ] = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_referer' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_addr' ] = '123.x.x.x' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_user' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'time_local' ] = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'method' ] = 'POST' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'body_bytes_sent' ] = '162' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_version' ] = '1.1' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'status' ] = '404' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Meta [ log_type ] = 'http_access-log' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.StrTime = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event leaving node : ok id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] child is success, OnSuccess = next_stage, skip id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse Debug scenario output (expand) DEBU [ 05 -08-2020 16 :02:26 ] eval ( evt.Meta.service == 'http' && evt.Meta.http_status in [ '404' , '403' , '400' ] && evt.Parsed.static_ressource == 'false' ) = TRUE cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] eval variables: cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.service = 'http' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.http_status = '404' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Parsed.static_ressource = 'false' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing Test environments \u00b6 From a {{v0X.crowdsec.name}} release archive , you can deploy a test (non-root) environment that is very suitable to write/debug/test parsers and scenarios. Environment is deployed using ./test_env.sh script from tgz directory, and creates a test environment in ./tests : $ cd crowdsec-v0.3.0/ $ ./test_env.sh ... [ 08 /05/2020:04:19:18 PM ][ INFO ] Setting up configurations INFO [ 0000 ] Wrote new 75065 bytes index to config/crowdsec-cli/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK ... INFO [ 0007 ] Enabled collections : crowdsecurity/linux INFO [ 0007 ] Enabled crowdsecurity/linux [ 08 /05/2020:04:19:26 PM ][ INFO ] Environment is ready in /home/bui/github/crowdsec/crowdsec/crowdsec-v0.3.0/tests $ cd tests $ ./cscli -c dev.yaml list ... INFO [ 0000 ] PARSERS: ------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------- crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 config/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .3 config/parsers/s00-raw/syslog-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .2 config/parsers/s01-parse/sshd-logs.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 config/parsers/s02-enrich/dateparse-enrich.yaml ------------------------------------------------------------------------------------------------------- ... $ ./crowdsec -c dev.yaml -file sshd.log -type syslog INFO [ 05 -08-2020 16 :23:32 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :23:32 ] Loading grok library ...","title":"Debugging Parsers & Scenarios"},{"location":"cheat_sheets/debugging_configs/#debugging-scenarios-and-parsers","text":"","title":"Debugging Scenarios and Parsers"},{"location":"cheat_sheets/debugging_configs/#general-advice","text":"When trying to debug a parser or a scenario : Work on \"cold logs\" (with the -file and -type options) rather than live ones Use the /etc/crowdsec/config/user.yaml configuration files to have logs on stdout","title":"General Advice"},{"location":"cheat_sheets/debugging_configs/#using-user-mode-configuration","text":"crowdsec -c /etc/crowdsec/config/user.yaml -file mylogs.log.gz -type syslog INFO [ 05 -08-2020 16 :15:47 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :15:47 ] Loading grok library ... WARN [ 05 -08-2020 16 :16:12 ] 182 .x.x.x triggered a 4h0m0s ip ban remediation for [ crowdsecurity/http-probing ] bucket_id = misty-moon event_time = \"2019-01-01 22:58:32 +0100 CET\" scenario = crowdsecurity/http-probing source_ip = 182 .x.x.x ... /etc/crowdsec/config/user.yaml disables demonization and push logs to stdout/stderr -type must respect expected log type (ie. nginx syslog etc.) -file must point to a flat file or a gzip file When processing logs like this, {{v0X.crowdsec.name}} runs in \"time machine\" mode, and relies on the timestamps in the logs to evaluate scenarios. You will most likely need the crowdsecurity/dateparse-enrich parser for this.","title":"Using user-mode configuration"},{"location":"cheat_sheets/debugging_configs/#testing-configurations-on-live-system","text":"If you're playing around with parser/scenarios on a live system, you can use the -t (lint) option of {{v0X.crowdsec.Name}} to check your configurations validity before restarting/reloading services : $ emacs /etc/crowdsec/config/scenarios/ssh-bf.yaml ... $ crowdsec -c /etc/crowdsec/config/user.yaml -t INFO [ 06 -08-2020 13 :36:04 ] Crowdsec v0.3.0-rc3-4cffef42732944d4b81b3e62a03d4040ad74f185 ... ERRO [ 06 -08-2020 13 :36:05 ] Bad yaml in /etc/crowdsec/config/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory FATA [ 06 -08-2020 13 :36:05 ] Failed to load scenarios: Scenario loading failed : bad yaml in /etc/crowdsec/config/scenarios/ssh-bf.yaml : yaml: unmarshal errors: line 2 : field typex not found in type leakybucket.BucketFactory Using this, you won't have to kill your running service before you know the scenarios/parsers are at least syntactically correct.","title":"Testing configurations on live system"},{"location":"cheat_sheets/debugging_configs/#using-debug","text":"Both scenarios and parsers support a debug: true|false option which produce useful debug. Debug parsing output (expand) DEBU [ 05 -08-2020 15 :25:36 ] eval ( evt.Parsed.program == 'nginx' ) = TRUE id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] eval variables: id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.Parsed.program = 'nginx' id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event entering node id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'request' ] = '/data.php' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_user_agent' ] = 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_referer' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_addr' ] = '123.x.x.x' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'remote_user' ] = '-' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'time_local' ] = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'method' ] = 'POST' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'body_bytes_sent' ] = '162' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'http_version' ] = '1.1' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Parsed [ 'status' ] = '404' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] .Meta [ log_type ] = 'http_access-log' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] evt.StrTime = '01/Jan/2019:01:39:06 +0100' id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] Event leaving node : ok id = icy-dew name = child-crowdsecurity/nginx-logs stage = s01-parse DEBU [ 05 -08-2020 15 :25:36 ] child is success, OnSuccess = next_stage, skip id = lively-smoke name = crowdsecurity/nginx-logs stage = s01-parse Debug scenario output (expand) DEBU [ 05 -08-2020 16 :02:26 ] eval ( evt.Meta.service == 'http' && evt.Meta.http_status in [ '404' , '403' , '400' ] && evt.Parsed.static_ressource == 'false' ) = TRUE cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] eval variables: cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.service = 'http' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Meta.http_status = '404' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing DEBU [ 05 -08-2020 16 :02:26 ] evt.Parsed.static_ressource = 'false' cfg = black-wave file = config/scenarios/http-probing.yaml name = crowdsecurity/http-probing","title":"Using debug"},{"location":"cheat_sheets/debugging_configs/#test-environments","text":"From a {{v0X.crowdsec.name}} release archive , you can deploy a test (non-root) environment that is very suitable to write/debug/test parsers and scenarios. Environment is deployed using ./test_env.sh script from tgz directory, and creates a test environment in ./tests : $ cd crowdsec-v0.3.0/ $ ./test_env.sh ... [ 08 /05/2020:04:19:18 PM ][ INFO ] Setting up configurations INFO [ 0000 ] Wrote new 75065 bytes index to config/crowdsec-cli/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK ... INFO [ 0007 ] Enabled collections : crowdsecurity/linux INFO [ 0007 ] Enabled crowdsecurity/linux [ 08 /05/2020:04:19:26 PM ][ INFO ] Environment is ready in /home/bui/github/crowdsec/crowdsec/crowdsec-v0.3.0/tests $ cd tests $ ./cscli -c dev.yaml list ... INFO [ 0000 ] PARSERS: ------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------- crowdsecurity/geoip-enrich \u2714\ufe0f enabled 0 .2 config/parsers/s02-enrich/geoip-enrich.yaml crowdsecurity/syslog-logs \u2714\ufe0f enabled 0 .3 config/parsers/s00-raw/syslog-logs.yaml crowdsecurity/sshd-logs \u2714\ufe0f enabled 0 .2 config/parsers/s01-parse/sshd-logs.yaml crowdsecurity/dateparse-enrich \u2714\ufe0f enabled 0 .1 config/parsers/s02-enrich/dateparse-enrich.yaml ------------------------------------------------------------------------------------------------------- ... $ ./crowdsec -c dev.yaml -file sshd.log -type syslog INFO [ 05 -08-2020 16 :23:32 ] Crowdsec v0.3.0-rc3-7525f11975a0107746213862dc41c69e00122ac7 INFO [ 05 -08-2020 16 :23:32 ] Loading grok library ...","title":"Test environments"},{"location":"cscli/cscli/","text":"cscli \u00b6 cscli allows you to manage crowdsec Synopsis \u00b6 cscli is the main command to interact with your crowdsec service, scenarios & db. It is meant to allow you to manage bans, parsers/scenarios/etc, api and generally manage you crowdsec setup. Examples \u00b6 View/Add/Remove bans: - cscli ban list - cscli ban add ip 1.2.3.4 24h 'go away' - cscli ban del 1.2.3.4 View/Add/Upgrade/Remove scenarios and parsers: - cscli list - cscli install collection crowdsec/linux-web - cscli remove scenario crowdsec/ssh_enum - cscli upgrade --all API interaction: - cscli api pull - cscli api register Options \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") -o, --output string Output format : human, json, raw. (default \"human\") --debug Set logging to debug. --info Set logging to info. --warning Set logging to warning. --error Set logging to error. -h, --help help for cscli SEE ALSO \u00b6 cscli api - Crowdsec API interaction cscli backup - Backup or restore configuration (api, parsers, scenarios etc.) to/from directory cscli ban - Manage bans/mitigations cscli config - Allows to view/edit cscli config cscli dashboard - Start a dashboard (metabase) container. cscli inspect - Inspect configuration(s) cscli install - Install configuration(s) from hub cscli list - List enabled configs cscli metrics - Display crowdsec prometheus metrics. cscli remove - Remove/disable configuration(s) cscli simulation - cscli update - Fetch available configs from hub cscli upgrade - Upgrade configuration(s)","title":"Cscli"},{"location":"cscli/cscli/#cscli","text":"cscli allows you to manage crowdsec","title":"cscli"},{"location":"cscli/cscli/#synopsis","text":"cscli is the main command to interact with your crowdsec service, scenarios & db. It is meant to allow you to manage bans, parsers/scenarios/etc, api and generally manage you crowdsec setup.","title":"Synopsis"},{"location":"cscli/cscli/#examples","text":"View/Add/Remove bans: - cscli ban list - cscli ban add ip 1.2.3.4 24h 'go away' - cscli ban del 1.2.3.4 View/Add/Upgrade/Remove scenarios and parsers: - cscli list - cscli install collection crowdsec/linux-web - cscli remove scenario crowdsec/ssh_enum - cscli upgrade --all API interaction: - cscli api pull - cscli api register","title":"Examples"},{"location":"cscli/cscli/#options","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") -o, --output string Output format : human, json, raw. (default \"human\") --debug Set logging to debug. --info Set logging to info. --warning Set logging to warning. --error Set logging to error. -h, --help help for cscli","title":"Options"},{"location":"cscli/cscli/#see-also","text":"cscli api - Crowdsec API interaction cscli backup - Backup or restore configuration (api, parsers, scenarios etc.) to/from directory cscli ban - Manage bans/mitigations cscli config - Allows to view/edit cscli config cscli dashboard - Start a dashboard (metabase) container. cscli inspect - Inspect configuration(s) cscli install - Install configuration(s) from hub cscli list - List enabled configs cscli metrics - Display crowdsec prometheus metrics. cscli remove - Remove/disable configuration(s) cscli simulation - cscli update - Fetch available configs from hub cscli upgrade - Upgrade configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_api/","text":"cscli api \u00b6 Crowdsec API interaction Synopsis \u00b6 Allow to register your machine into crowdsec API to send and receive signal. Examples \u00b6 cscli api register # Register to Crowdsec API cscli api pull # Pull malevolant IPs from Crowdsec API cscli api reset # Reset your machines credentials cscli api enroll # Enroll your machine to the user account you created on Crowdsec backend cscli api credentials # Display your API credentials Options \u00b6 -h, --help help for api Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli api credentials - Display api credentials cscli api enroll - Associate your machine to an existing crowdsec user cscli api pull - Pull crowdsec API TopX cscli api register - Register on Crowdsec API cscli api reset - Reset password on CrowdSec API","title":"API"},{"location":"cscli/cscli_api/#cscli-api","text":"Crowdsec API interaction","title":"cscli api"},{"location":"cscli/cscli_api/#synopsis","text":"Allow to register your machine into crowdsec API to send and receive signal.","title":"Synopsis"},{"location":"cscli/cscli_api/#examples","text":"cscli api register # Register to Crowdsec API cscli api pull # Pull malevolant IPs from Crowdsec API cscli api reset # Reset your machines credentials cscli api enroll # Enroll your machine to the user account you created on Crowdsec backend cscli api credentials # Display your API credentials","title":"Examples"},{"location":"cscli/cscli_api/#options","text":"-h, --help help for api","title":"Options"},{"location":"cscli/cscli_api/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_api/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli api credentials - Display api credentials cscli api enroll - Associate your machine to an existing crowdsec user cscli api pull - Pull crowdsec API TopX cscli api register - Register on Crowdsec API cscli api reset - Reset password on CrowdSec API","title":"SEE ALSO"},{"location":"cscli/cscli_api_credentials/","text":"cscli api credentials \u00b6 Display api credentials Synopsis \u00b6 Display api credentials cscli api credentials [flags] Examples \u00b6 cscli api credentials Options \u00b6 -h, --help help for credentials Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli api - Crowdsec API interaction","title":"Cscli api credentials"},{"location":"cscli/cscli_api_credentials/#cscli-api-credentials","text":"Display api credentials","title":"cscli api credentials"},{"location":"cscli/cscli_api_credentials/#synopsis","text":"Display api credentials cscli api credentials [flags]","title":"Synopsis"},{"location":"cscli/cscli_api_credentials/#examples","text":"cscli api credentials","title":"Examples"},{"location":"cscli/cscli_api_credentials/#options","text":"-h, --help help for credentials","title":"Options"},{"location":"cscli/cscli_api_credentials/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_api_credentials/#see-also","text":"cscli api - Crowdsec API interaction","title":"SEE ALSO"},{"location":"cscli/cscli_api_enroll/","text":"cscli api enroll \u00b6 Associate your machine to an existing crowdsec user Synopsis \u00b6 Enrolling your machine into your user account will allow for more accurate lists and threat detection. See website to create user account. cscli api enroll [flags] Examples \u00b6 cscli api enroll -u 1234567890ffff Options \u00b6 -h, --help help for enroll -u, --user string User ID (required) Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli api - Crowdsec API interaction","title":"Cscli api enroll"},{"location":"cscli/cscli_api_enroll/#cscli-api-enroll","text":"Associate your machine to an existing crowdsec user","title":"cscli api enroll"},{"location":"cscli/cscli_api_enroll/#synopsis","text":"Enrolling your machine into your user account will allow for more accurate lists and threat detection. See website to create user account. cscli api enroll [flags]","title":"Synopsis"},{"location":"cscli/cscli_api_enroll/#examples","text":"cscli api enroll -u 1234567890ffff","title":"Examples"},{"location":"cscli/cscli_api_enroll/#options","text":"-h, --help help for enroll -u, --user string User ID (required)","title":"Options"},{"location":"cscli/cscli_api_enroll/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_api_enroll/#see-also","text":"cscli api - Crowdsec API interaction","title":"SEE ALSO"},{"location":"cscli/cscli_api_pull/","text":"cscli api pull \u00b6 Pull crowdsec API TopX Synopsis \u00b6 Pulls a list of malveolent IPs relevant to your situation and add them into the local ban database. cscli api pull [flags] Examples \u00b6 cscli api pull Options \u00b6 -h, --help help for pull Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli api - Crowdsec API interaction","title":"Cscli api pull"},{"location":"cscli/cscli_api_pull/#cscli-api-pull","text":"Pull crowdsec API TopX","title":"cscli api pull"},{"location":"cscli/cscli_api_pull/#synopsis","text":"Pulls a list of malveolent IPs relevant to your situation and add them into the local ban database. cscli api pull [flags]","title":"Synopsis"},{"location":"cscli/cscli_api_pull/#examples","text":"cscli api pull","title":"Examples"},{"location":"cscli/cscli_api_pull/#options","text":"-h, --help help for pull","title":"Options"},{"location":"cscli/cscli_api_pull/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_api_pull/#see-also","text":"cscli api - Crowdsec API interaction","title":"SEE ALSO"},{"location":"cscli/cscli_api_register/","text":"cscli api register \u00b6 Register on Crowdsec API Synopsis \u00b6 This command will register your machine to crowdsec API to allow you to receive list of malveolent IPs. The printed machine_id and password should be added to your api.yaml file. cscli api register [flags] Examples \u00b6 cscli api register Options \u00b6 -h, --help help for register Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli api - Crowdsec API interaction","title":"Cscli api register"},{"location":"cscli/cscli_api_register/#cscli-api-register","text":"Register on Crowdsec API","title":"cscli api register"},{"location":"cscli/cscli_api_register/#synopsis","text":"This command will register your machine to crowdsec API to allow you to receive list of malveolent IPs. The printed machine_id and password should be added to your api.yaml file. cscli api register [flags]","title":"Synopsis"},{"location":"cscli/cscli_api_register/#examples","text":"cscli api register","title":"Examples"},{"location":"cscli/cscli_api_register/#options","text":"-h, --help help for register","title":"Options"},{"location":"cscli/cscli_api_register/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_api_register/#see-also","text":"cscli api - Crowdsec API interaction","title":"SEE ALSO"},{"location":"cscli/cscli_api_reset/","text":"cscli api reset \u00b6 Reset password on CrowdSec API Synopsis \u00b6 Attempts to reset your credentials to the API. cscli api reset [flags] Examples \u00b6 cscli api reset Options \u00b6 -h, --help help for reset Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli api - Crowdsec API interaction","title":"Cscli api reset"},{"location":"cscli/cscli_api_reset/#cscli-api-reset","text":"Reset password on CrowdSec API","title":"cscli api reset"},{"location":"cscli/cscli_api_reset/#synopsis","text":"Attempts to reset your credentials to the API. cscli api reset [flags]","title":"Synopsis"},{"location":"cscli/cscli_api_reset/#examples","text":"cscli api reset","title":"Examples"},{"location":"cscli/cscli_api_reset/#options","text":"-h, --help help for reset","title":"Options"},{"location":"cscli/cscli_api_reset/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_api_reset/#see-also","text":"cscli api - Crowdsec API interaction","title":"SEE ALSO"},{"location":"cscli/cscli_backup/","text":"cscli backup \u00b6 Backup or restore configuration (api, parsers, scenarios etc.) to/from directory Synopsis \u00b6 This command is here to help you save and/or restore crowdsec configurations to simple replication Examples \u00b6 cscli backup save ./my-backup cscli backup restore ./my-backup Options \u00b6 -h, --help help for backup Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli backup restore - Restore configuration (api, parsers, scenarios etc.) from directory cscli backup save - Backup configuration (api, parsers, scenarios etc.) to directory","title":"Backup"},{"location":"cscli/cscli_backup/#cscli-backup","text":"Backup or restore configuration (api, parsers, scenarios etc.) to/from directory","title":"cscli backup"},{"location":"cscli/cscli_backup/#synopsis","text":"This command is here to help you save and/or restore crowdsec configurations to simple replication","title":"Synopsis"},{"location":"cscli/cscli_backup/#examples","text":"cscli backup save ./my-backup cscli backup restore ./my-backup","title":"Examples"},{"location":"cscli/cscli_backup/#options","text":"-h, --help help for backup","title":"Options"},{"location":"cscli/cscli_backup/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_backup/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli backup restore - Restore configuration (api, parsers, scenarios etc.) from directory cscli backup save - Backup configuration (api, parsers, scenarios etc.) to directory","title":"SEE ALSO"},{"location":"cscli/cscli_backup_restore/","text":"cscli backup restore \u00b6 Restore configuration (api, parsers, scenarios etc.) from directory Synopsis \u00b6 restore command will try to restore all saved information from to yor local setup, including : Installation of up-to-date scenarios/parsers/... via cscli Restauration of tainted/local/out-of-date scenarios/parsers/... file Restauration of API credentials (if the existing ones aren't working) Restauration of acqusition configuration cscli backup restore <directory> [flags] Examples \u00b6 cscli backup restore ./my-backup Options \u00b6 -h, --help help for restore Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli backup - Backup or restore configuration (api, parsers, scenarios etc.) to/from directory","title":"Cscli backup restore"},{"location":"cscli/cscli_backup_restore/#cscli-backup-restore","text":"Restore configuration (api, parsers, scenarios etc.) from directory","title":"cscli backup restore"},{"location":"cscli/cscli_backup_restore/#synopsis","text":"restore command will try to restore all saved information from to yor local setup, including : Installation of up-to-date scenarios/parsers/... via cscli Restauration of tainted/local/out-of-date scenarios/parsers/... file Restauration of API credentials (if the existing ones aren't working) Restauration of acqusition configuration cscli backup restore <directory> [flags]","title":"Synopsis"},{"location":"cscli/cscli_backup_restore/#examples","text":"cscli backup restore ./my-backup","title":"Examples"},{"location":"cscli/cscli_backup_restore/#options","text":"-h, --help help for restore","title":"Options"},{"location":"cscli/cscli_backup_restore/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_backup_restore/#see-also","text":"cscli backup - Backup or restore configuration (api, parsers, scenarios etc.) to/from directory","title":"SEE ALSO"},{"location":"cscli/cscli_backup_save/","text":"cscli backup save \u00b6 Backup configuration (api, parsers, scenarios etc.) to directory Synopsis \u00b6 backup command will try to save all relevant informations to crowdsec config, including : List of scenarios, parsers, postoverflows and collections that are up-to-date Actual backup of tainted/local/out-of-date scenarios, parsers, postoverflows and collections Backup of API credentials Backup of acquisition configuration cscli backup save <directory> [flags] Examples \u00b6 cscli backup save ./my-backup Options \u00b6 -h, --help help for save Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli backup - Backup or restore configuration (api, parsers, scenarios etc.) to/from directory","title":"Cscli backup save"},{"location":"cscli/cscli_backup_save/#cscli-backup-save","text":"Backup configuration (api, parsers, scenarios etc.) to directory","title":"cscli backup save"},{"location":"cscli/cscli_backup_save/#synopsis","text":"backup command will try to save all relevant informations to crowdsec config, including : List of scenarios, parsers, postoverflows and collections that are up-to-date Actual backup of tainted/local/out-of-date scenarios, parsers, postoverflows and collections Backup of API credentials Backup of acquisition configuration cscli backup save <directory> [flags]","title":"Synopsis"},{"location":"cscli/cscli_backup_save/#examples","text":"cscli backup save ./my-backup","title":"Examples"},{"location":"cscli/cscli_backup_save/#options","text":"-h, --help help for save","title":"Options"},{"location":"cscli/cscli_backup_save/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_backup_save/#see-also","text":"cscli backup - Backup or restore configuration (api, parsers, scenarios etc.) to/from directory","title":"SEE ALSO"},{"location":"cscli/cscli_ban/","text":"cscli ban \u00b6 Manage bans/mitigations Synopsis \u00b6 This is the main interaction point with local ban database for humans. You can add/delete/list or flush current bans in your local ban DB. Options \u00b6 --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") -h, --help help for ban Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli ban add - Adds a ban against a given ip/range for the provided duration cscli ban del - Delete bans from db cscli ban flush - Fush ban DB cscli ban list - List local or api bans/remediations","title":"Bans"},{"location":"cscli/cscli_ban/#cscli-ban","text":"Manage bans/mitigations","title":"cscli ban"},{"location":"cscli/cscli_ban/#synopsis","text":"This is the main interaction point with local ban database for humans. You can add/delete/list or flush current bans in your local ban DB.","title":"Synopsis"},{"location":"cscli/cscli_ban/#options","text":"--remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") -h, --help help for ban","title":"Options"},{"location":"cscli/cscli_ban/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli ban add - Adds a ban against a given ip/range for the provided duration cscli ban del - Delete bans from db cscli ban flush - Fush ban DB cscli ban list - List local or api bans/remediations","title":"SEE ALSO"},{"location":"cscli/cscli_ban_add/","text":"cscli ban add \u00b6 Adds a ban against a given ip/range for the provided duration Synopsis \u00b6 Allows to add a ban against a specific ip or range target for a specific duration. The duration argument can be expressed in seconds(s), minutes(m) or hours (h). See time.ParseDuration for more informations. Examples \u00b6 cscli ban add ip 1.2.3.4 24h \"scan\" cscli ban add range 1.2.3.0/24 24h \"the whole range\" Options \u00b6 -h, --help help for add Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban - Manage bans/mitigations cscli ban add ip - Adds the specific ip to the ban db cscli ban add range - Adds the specific ip to the ban db","title":"Cscli ban add"},{"location":"cscli/cscli_ban_add/#cscli-ban-add","text":"Adds a ban against a given ip/range for the provided duration","title":"cscli ban add"},{"location":"cscli/cscli_ban_add/#synopsis","text":"Allows to add a ban against a specific ip or range target for a specific duration. The duration argument can be expressed in seconds(s), minutes(m) or hours (h). See time.ParseDuration for more informations.","title":"Synopsis"},{"location":"cscli/cscli_ban_add/#examples","text":"cscli ban add ip 1.2.3.4 24h \"scan\" cscli ban add range 1.2.3.0/24 24h \"the whole range\"","title":"Examples"},{"location":"cscli/cscli_ban_add/#options","text":"-h, --help help for add","title":"Options"},{"location":"cscli/cscli_ban_add/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_add/#see-also","text":"cscli ban - Manage bans/mitigations cscli ban add ip - Adds the specific ip to the ban db cscli ban add range - Adds the specific ip to the ban db","title":"SEE ALSO"},{"location":"cscli/cscli_ban_add_ip/","text":"cscli ban add ip \u00b6 Adds the specific ip to the ban db Synopsis \u00b6 Duration must be time.ParseDuration , expressed in s/m/h. cscli ban add ip <target> <duration> <reason> [flags] Examples \u00b6 cscli ban add ip 1.2.3.4 12h \"the scan\" Options \u00b6 -h, --help help for ip Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban add - Adds a ban against a given ip/range for the provided duration","title":"Cscli ban add ip"},{"location":"cscli/cscli_ban_add_ip/#cscli-ban-add-ip","text":"Adds the specific ip to the ban db","title":"cscli ban add ip"},{"location":"cscli/cscli_ban_add_ip/#synopsis","text":"Duration must be time.ParseDuration , expressed in s/m/h. cscli ban add ip <target> <duration> <reason> [flags]","title":"Synopsis"},{"location":"cscli/cscli_ban_add_ip/#examples","text":"cscli ban add ip 1.2.3.4 12h \"the scan\"","title":"Examples"},{"location":"cscli/cscli_ban_add_ip/#options","text":"-h, --help help for ip","title":"Options"},{"location":"cscli/cscli_ban_add_ip/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_add_ip/#see-also","text":"cscli ban add - Adds a ban against a given ip/range for the provided duration","title":"SEE ALSO"},{"location":"cscli/cscli_ban_add_range/","text":"cscli ban add range \u00b6 Adds the specific ip to the ban db Synopsis \u00b6 Duration must be time.ParseDuration compatible, expressed in s/m/h. cscli ban add range <target> <duration> <reason> [flags] Examples \u00b6 cscli ban add range 1.2.3.0/24 12h \"the whole range\" Options \u00b6 -h, --help help for range Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban add - Adds a ban against a given ip/range for the provided duration","title":"Cscli ban add range"},{"location":"cscli/cscli_ban_add_range/#cscli-ban-add-range","text":"Adds the specific ip to the ban db","title":"cscli ban add range"},{"location":"cscli/cscli_ban_add_range/#synopsis","text":"Duration must be time.ParseDuration compatible, expressed in s/m/h. cscli ban add range <target> <duration> <reason> [flags]","title":"Synopsis"},{"location":"cscli/cscli_ban_add_range/#examples","text":"cscli ban add range 1.2.3.0/24 12h \"the whole range\"","title":"Examples"},{"location":"cscli/cscli_ban_add_range/#options","text":"-h, --help help for range","title":"Options"},{"location":"cscli/cscli_ban_add_range/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_add_range/#see-also","text":"cscli ban add - Adds a ban against a given ip/range for the provided duration","title":"SEE ALSO"},{"location":"cscli/cscli_ban_del/","text":"cscli ban del \u00b6 Delete bans from db Synopsis \u00b6 The removal of the bans can be applied on a single IP address or directly on a IP range. Examples \u00b6 cscli ban del ip 1.2.3.4 cscli ban del range 1.2.3.0/24 Options \u00b6 -h, --help help for del Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban - Manage bans/mitigations cscli ban del ip - Delete bans for given ip from db cscli ban del range - Delete bans for given ip from db","title":"Cscli ban del"},{"location":"cscli/cscli_ban_del/#cscli-ban-del","text":"Delete bans from db","title":"cscli ban del"},{"location":"cscli/cscli_ban_del/#synopsis","text":"The removal of the bans can be applied on a single IP address or directly on a IP range.","title":"Synopsis"},{"location":"cscli/cscli_ban_del/#examples","text":"cscli ban del ip 1.2.3.4 cscli ban del range 1.2.3.0/24","title":"Examples"},{"location":"cscli/cscli_ban_del/#options","text":"-h, --help help for del","title":"Options"},{"location":"cscli/cscli_ban_del/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_del/#see-also","text":"cscli ban - Manage bans/mitigations cscli ban del ip - Delete bans for given ip from db cscli ban del range - Delete bans for given ip from db","title":"SEE ALSO"},{"location":"cscli/cscli_ban_del_ip/","text":"cscli ban del ip \u00b6 Delete bans for given ip from db Synopsis \u00b6 Delete bans for given ip from db cscli ban del ip <target> [flags] Examples \u00b6 cscli ban del ip 1.2.3.4 Options \u00b6 -h, --help help for ip Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban del - Delete bans from db","title":"Cscli ban del ip"},{"location":"cscli/cscli_ban_del_ip/#cscli-ban-del-ip","text":"Delete bans for given ip from db","title":"cscli ban del ip"},{"location":"cscli/cscli_ban_del_ip/#synopsis","text":"Delete bans for given ip from db cscli ban del ip <target> [flags]","title":"Synopsis"},{"location":"cscli/cscli_ban_del_ip/#examples","text":"cscli ban del ip 1.2.3.4","title":"Examples"},{"location":"cscli/cscli_ban_del_ip/#options","text":"-h, --help help for ip","title":"Options"},{"location":"cscli/cscli_ban_del_ip/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_del_ip/#see-also","text":"cscli ban del - Delete bans from db","title":"SEE ALSO"},{"location":"cscli/cscli_ban_del_range/","text":"cscli ban del range \u00b6 Delete bans for given ip from db Synopsis \u00b6 Delete bans for given ip from db cscli ban del range <target> [flags] Examples \u00b6 cscli ban del range 1.2.3.0/24 Options \u00b6 -h, --help help for range Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban del - Delete bans from db","title":"Cscli ban del range"},{"location":"cscli/cscli_ban_del_range/#cscli-ban-del-range","text":"Delete bans for given ip from db","title":"cscli ban del range"},{"location":"cscli/cscli_ban_del_range/#synopsis","text":"Delete bans for given ip from db cscli ban del range <target> [flags]","title":"Synopsis"},{"location":"cscli/cscli_ban_del_range/#examples","text":"cscli ban del range 1.2.3.0/24","title":"Examples"},{"location":"cscli/cscli_ban_del_range/#options","text":"-h, --help help for range","title":"Options"},{"location":"cscli/cscli_ban_del_range/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_del_range/#see-also","text":"cscli ban del - Delete bans from db","title":"SEE ALSO"},{"location":"cscli/cscli_ban_flush/","text":"cscli ban flush \u00b6 Fush ban DB Synopsis \u00b6 Fush ban DB cscli ban flush [flags] Examples \u00b6 cscli ban flush Options \u00b6 -h, --help help for flush Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban - Manage bans/mitigations","title":"Cscli ban flush"},{"location":"cscli/cscli_ban_flush/#cscli-ban-flush","text":"Fush ban DB","title":"cscli ban flush"},{"location":"cscli/cscli_ban_flush/#synopsis","text":"Fush ban DB cscli ban flush [flags]","title":"Synopsis"},{"location":"cscli/cscli_ban_flush/#examples","text":"cscli ban flush","title":"Examples"},{"location":"cscli/cscli_ban_flush/#options","text":"-h, --help help for flush","title":"Options"},{"location":"cscli/cscli_ban_flush/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_flush/#see-also","text":"cscli ban - Manage bans/mitigations","title":"SEE ALSO"},{"location":"cscli/cscli_ban_list/","text":"cscli ban list \u00b6 List local or api bans/remediations Synopsis \u00b6 List the bans, by default only local decisions. If --all/-a is specified, bans will be displayed without limit (--limit). Default limit is 50. Time can be specified with --at and support a variety of date formats: - Jan 2 15:04:05 - Mon Jan 02 15:04:05.000000 2006 - 2006-01-02T15:04:05Z07:00 - 2006/01/02 - 2006/01/02 15:04 - 2006-01-02 - 2006-01-02 15:04 cscli ban list [flags] Examples \u00b6 ban list --range 0.0.0.0/0 : will list all ban list --country CN ban list --reason crowdsecurity/http-probing ban list --as OVH Options \u00b6 -a, --all List bans without limit --api List as well bans received from API --as string List bans belonging to given AS name --at string List bans at given time --country string List bans belonging to given country code -h, --help help for list --ip string List bans for given IP --limit int Limit of bans to display (default 50) (default 50) --range string List bans belonging to given range --reason string List bans containing given reason Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning. SEE ALSO \u00b6 cscli ban - Manage bans/mitigations","title":"Cscli ban list"},{"location":"cscli/cscli_ban_list/#cscli-ban-list","text":"List local or api bans/remediations","title":"cscli ban list"},{"location":"cscli/cscli_ban_list/#synopsis","text":"List the bans, by default only local decisions. If --all/-a is specified, bans will be displayed without limit (--limit). Default limit is 50. Time can be specified with --at and support a variety of date formats: - Jan 2 15:04:05 - Mon Jan 02 15:04:05.000000 2006 - 2006-01-02T15:04:05Z07:00 - 2006/01/02 - 2006/01/02 15:04 - 2006-01-02 - 2006-01-02 15:04 cscli ban list [flags]","title":"Synopsis"},{"location":"cscli/cscli_ban_list/#examples","text":"ban list --range 0.0.0.0/0 : will list all ban list --country CN ban list --reason crowdsecurity/http-probing ban list --as OVH","title":"Examples"},{"location":"cscli/cscli_ban_list/#options","text":"-a, --all List bans without limit --api List as well bans received from API --as string List bans belonging to given AS name --at string List bans at given time --country string List bans belonging to given country code -h, --help help for list --ip string List bans for given IP --limit int Limit of bans to display (default 50) (default 50) --range string List bans belonging to given range --reason string List bans containing given reason","title":"Options"},{"location":"cscli/cscli_ban_list/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --remediation string Set specific remediation type : ban|slow|captcha (default \"ban\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_ban_list/#see-also","text":"cscli ban - Manage bans/mitigations","title":"SEE ALSO"},{"location":"cscli/cscli_config/","text":"cscli config \u00b6 Allows to view/edit cscli config Synopsis \u00b6 Allow to configure database plugin path and installation directory. If no commands are specified, config is in interactive mode. Examples \u00b6 - cscli config show - cscli config prompt Options \u00b6 -h, --help help for config Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli config show - Displays current config","title":"Cscli config"},{"location":"cscli/cscli_config/#cscli-config","text":"Allows to view/edit cscli config","title":"cscli config"},{"location":"cscli/cscli_config/#synopsis","text":"Allow to configure database plugin path and installation directory. If no commands are specified, config is in interactive mode.","title":"Synopsis"},{"location":"cscli/cscli_config/#examples","text":"- cscli config show - cscli config prompt","title":"Examples"},{"location":"cscli/cscli_config/#options","text":"-h, --help help for config","title":"Options"},{"location":"cscli/cscli_config/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_config/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli config show - Displays current config","title":"SEE ALSO"},{"location":"cscli/cscli_config_show/","text":"cscli config show \u00b6 Displays current config Synopsis \u00b6 Displays the current cli configuration. cscli config show [flags] Options \u00b6 -h, --help help for show Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli config - Allows to view/edit cscli config","title":"Cscli config show"},{"location":"cscli/cscli_config_show/#cscli-config-show","text":"Displays current config","title":"cscli config show"},{"location":"cscli/cscli_config_show/#synopsis","text":"Displays the current cli configuration. cscli config show [flags]","title":"Synopsis"},{"location":"cscli/cscli_config_show/#options","text":"-h, --help help for show","title":"Options"},{"location":"cscli/cscli_config_show/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_config_show/#see-also","text":"cscli config - Allows to view/edit cscli config","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard/","text":"cscli dashboard \u00b6 Start a dashboard (metabase) container. Synopsis \u00b6 Start a metabase container exposing dashboards and metrics. Examples \u00b6 cscli dashboard setup cscli dashboard start cscli dashboard stop cscli dashboard setup --force Options \u00b6 -h, --help help for dashboard Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli dashboard setup - Setup a metabase container. cscli dashboard start - Start the metabase container. cscli dashboard stop - Stops the metabase container.","title":"Dashboard"},{"location":"cscli/cscli_dashboard/#cscli-dashboard","text":"Start a dashboard (metabase) container.","title":"cscli dashboard"},{"location":"cscli/cscli_dashboard/#synopsis","text":"Start a metabase container exposing dashboards and metrics.","title":"Synopsis"},{"location":"cscli/cscli_dashboard/#examples","text":"cscli dashboard setup cscli dashboard start cscli dashboard stop cscli dashboard setup --force","title":"Examples"},{"location":"cscli/cscli_dashboard/#options","text":"-h, --help help for dashboard","title":"Options"},{"location":"cscli/cscli_dashboard/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli dashboard setup - Setup a metabase container. cscli dashboard start - Start the metabase container. cscli dashboard stop - Stops the metabase container.","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_setup/","text":"cscli dashboard setup \u00b6 Setup a metabase container. Synopsis \u00b6 Perform a metabase docker setup, download standard dashboards, create a fresh user and start the container cscli dashboard setup [flags] Examples \u00b6 cscli dashboard setup cscli dashboard setup --force cscli dashboard setup -l 0.0.0.0 -p 443 Options \u00b6 -d, --dir string Shared directory with metabase container. (default \"/var/lib/crowdsec/data\") -f, --force Force setup : override existing files. -h, --help help for setup -l, --listen string Listen address of container (default \"127.0.0.1\") -p, --port string Listen port of container (default \"3000\") Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Start a dashboard (metabase) container.","title":"Cscli dashboard setup"},{"location":"cscli/cscli_dashboard_setup/#cscli-dashboard-setup","text":"Setup a metabase container.","title":"cscli dashboard setup"},{"location":"cscli/cscli_dashboard_setup/#synopsis","text":"Perform a metabase docker setup, download standard dashboards, create a fresh user and start the container cscli dashboard setup [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_setup/#examples","text":"cscli dashboard setup cscli dashboard setup --force cscli dashboard setup -l 0.0.0.0 -p 443","title":"Examples"},{"location":"cscli/cscli_dashboard_setup/#options","text":"-d, --dir string Shared directory with metabase container. (default \"/var/lib/crowdsec/data\") -f, --force Force setup : override existing files. -h, --help help for setup -l, --listen string Listen address of container (default \"127.0.0.1\") -p, --port string Listen port of container (default \"3000\")","title":"Options"},{"location":"cscli/cscli_dashboard_setup/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_setup/#see-also","text":"cscli dashboard - Start a dashboard (metabase) container.","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_start/","text":"cscli dashboard start \u00b6 Start the metabase container. Synopsis \u00b6 Stats the metabase container using docker. cscli dashboard start [flags] Options \u00b6 -h, --help help for start Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Start a dashboard (metabase) container.","title":"Cscli dashboard start"},{"location":"cscli/cscli_dashboard_start/#cscli-dashboard-start","text":"Start the metabase container.","title":"cscli dashboard start"},{"location":"cscli/cscli_dashboard_start/#synopsis","text":"Stats the metabase container using docker. cscli dashboard start [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_start/#options","text":"-h, --help help for start","title":"Options"},{"location":"cscli/cscli_dashboard_start/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_start/#see-also","text":"cscli dashboard - Start a dashboard (metabase) container.","title":"SEE ALSO"},{"location":"cscli/cscli_dashboard_stop/","text":"cscli dashboard stop \u00b6 Stops the metabase container. Synopsis \u00b6 Stops the metabase container using docker. cscli dashboard stop [flags] Options \u00b6 -h, --help help for stop -r, --remove remove (docker rm) container as well. Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli dashboard - Start a dashboard (metabase) container.","title":"Cscli dashboard stop"},{"location":"cscli/cscli_dashboard_stop/#cscli-dashboard-stop","text":"Stops the metabase container.","title":"cscli dashboard stop"},{"location":"cscli/cscli_dashboard_stop/#synopsis","text":"Stops the metabase container using docker. cscli dashboard stop [flags]","title":"Synopsis"},{"location":"cscli/cscli_dashboard_stop/#options","text":"-h, --help help for stop -r, --remove remove (docker rm) container as well.","title":"Options"},{"location":"cscli/cscli_dashboard_stop/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_dashboard_stop/#see-also","text":"cscli dashboard - Start a dashboard (metabase) container.","title":"SEE ALSO"},{"location":"cscli/cscli_inspect/","text":"cscli inspect \u00b6 Inspect configuration(s) Synopsis \u00b6 Inspect give you full detail about local installed configuration. [type] must be parser, scenario, postoverflow, collection. [config_name] must be a valid config name from Crowdsec Hub or locally installed. Examples \u00b6 cscli inspect parser crowdsec/xxx cscli inspect collection crowdsec/xxx Options \u00b6 -h, --help help for inspect Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli inspect collection - Inspect given collection cscli inspect parser - Inspect given log parser cscli inspect postoverflow - Inspect given postoverflow parser cscli inspect scenario - Inspect given scenario","title":"Inspect configurations"},{"location":"cscli/cscli_inspect/#cscli-inspect","text":"Inspect configuration(s)","title":"cscli inspect"},{"location":"cscli/cscli_inspect/#synopsis","text":"Inspect give you full detail about local installed configuration. [type] must be parser, scenario, postoverflow, collection. [config_name] must be a valid config name from Crowdsec Hub or locally installed.","title":"Synopsis"},{"location":"cscli/cscli_inspect/#examples","text":"cscli inspect parser crowdsec/xxx cscli inspect collection crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_inspect/#options","text":"-h, --help help for inspect","title":"Options"},{"location":"cscli/cscli_inspect/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_inspect/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli inspect collection - Inspect given collection cscli inspect parser - Inspect given log parser cscli inspect postoverflow - Inspect given postoverflow parser cscli inspect scenario - Inspect given scenario","title":"SEE ALSO"},{"location":"cscli/cscli_inspect_collection/","text":"cscli inspect collection \u00b6 Inspect given collection Synopsis \u00b6 Inspect given collection from hub cscli inspect collection [config] [flags] Examples \u00b6 cscli inspect collection crowdsec/xxx Options \u00b6 -h, --help help for collection Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli inspect - Inspect configuration(s)","title":"Cscli inspect collection"},{"location":"cscli/cscli_inspect_collection/#cscli-inspect-collection","text":"Inspect given collection","title":"cscli inspect collection"},{"location":"cscli/cscli_inspect_collection/#synopsis","text":"Inspect given collection from hub cscli inspect collection [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_inspect_collection/#examples","text":"cscli inspect collection crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_inspect_collection/#options","text":"-h, --help help for collection","title":"Options"},{"location":"cscli/cscli_inspect_collection/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_inspect_collection/#see-also","text":"cscli inspect - Inspect configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_inspect_parser/","text":"cscli inspect parser \u00b6 Inspect given log parser Synopsis \u00b6 Inspect given parser from hub cscli inspect parser [config] [flags] Examples \u00b6 cscli inspect parser crowdsec/xxx Options \u00b6 -h, --help help for parser Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli inspect - Inspect configuration(s)","title":"Cscli inspect parser"},{"location":"cscli/cscli_inspect_parser/#cscli-inspect-parser","text":"Inspect given log parser","title":"cscli inspect parser"},{"location":"cscli/cscli_inspect_parser/#synopsis","text":"Inspect given parser from hub cscli inspect parser [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_inspect_parser/#examples","text":"cscli inspect parser crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_inspect_parser/#options","text":"-h, --help help for parser","title":"Options"},{"location":"cscli/cscli_inspect_parser/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_inspect_parser/#see-also","text":"cscli inspect - Inspect configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_inspect_postoverflow/","text":"cscli inspect postoverflow \u00b6 Inspect given postoverflow parser Synopsis \u00b6 Inspect given postoverflow from hub. cscli inspect postoverflow [config] [flags] Examples \u00b6 cscli inspect postoverflow crowdsec/xxx Options \u00b6 -h, --help help for postoverflow Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli inspect - Inspect configuration(s)","title":"Cscli inspect postoverflow"},{"location":"cscli/cscli_inspect_postoverflow/#cscli-inspect-postoverflow","text":"Inspect given postoverflow parser","title":"cscli inspect postoverflow"},{"location":"cscli/cscli_inspect_postoverflow/#synopsis","text":"Inspect given postoverflow from hub. cscli inspect postoverflow [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_inspect_postoverflow/#examples","text":"cscli inspect postoverflow crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_inspect_postoverflow/#options","text":"-h, --help help for postoverflow","title":"Options"},{"location":"cscli/cscli_inspect_postoverflow/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_inspect_postoverflow/#see-also","text":"cscli inspect - Inspect configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_inspect_scenario/","text":"cscli inspect scenario \u00b6 Inspect given scenario Synopsis \u00b6 Inspect given scenario from hub cscli inspect scenario [config] [flags] Examples \u00b6 cscli inspect scenario crowdsec/xxx Options \u00b6 -h, --help help for scenario Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli inspect - Inspect configuration(s)","title":"Cscli inspect scenario"},{"location":"cscli/cscli_inspect_scenario/#cscli-inspect-scenario","text":"Inspect given scenario","title":"cscli inspect scenario"},{"location":"cscli/cscli_inspect_scenario/#synopsis","text":"Inspect given scenario from hub cscli inspect scenario [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_inspect_scenario/#examples","text":"cscli inspect scenario crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_inspect_scenario/#options","text":"-h, --help help for scenario","title":"Options"},{"location":"cscli/cscli_inspect_scenario/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_inspect_scenario/#see-also","text":"cscli inspect - Inspect configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_install/","text":"cscli install \u00b6 Install configuration(s) from hub Synopsis \u00b6 Install configuration from the CrowdSec Hub. In order to download latest versions of configuration, you should update cscli . [type] must be parser, scenario, postoverflow, collection. [config_name] must be a valid config name from Crowdsec Hub . Examples \u00b6 cscli install [type] [config_name] Options \u00b6 -d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli install collection - Install given collection cscli install parser - Install given parser cscli install postoverflow - Install given postoverflow parser cscli install scenario - Install given scenario","title":"Install configurations"},{"location":"cscli/cscli_install/#cscli-install","text":"Install configuration(s) from hub","title":"cscli install"},{"location":"cscli/cscli_install/#synopsis","text":"Install configuration from the CrowdSec Hub. In order to download latest versions of configuration, you should update cscli . [type] must be parser, scenario, postoverflow, collection. [config_name] must be a valid config name from Crowdsec Hub .","title":"Synopsis"},{"location":"cscli/cscli_install/#examples","text":"cscli install [type] [config_name]","title":"Examples"},{"location":"cscli/cscli_install/#options","text":"-d, --download-only Only download packages, don't enable --force Force install : Overwrite tainted and outdated files -h, --help help for install","title":"Options"},{"location":"cscli/cscli_install/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_install/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli install collection - Install given collection cscli install parser - Install given parser cscli install postoverflow - Install given postoverflow parser cscli install scenario - Install given scenario","title":"SEE ALSO"},{"location":"cscli/cscli_install_collection/","text":"cscli install collection \u00b6 Install given collection Synopsis \u00b6 Fetch and install given collection from hub cscli install collection [config] [flags] Examples \u00b6 cscli install collection crowdsec/xxx Options \u00b6 -h, --help help for collection Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli install - Install configuration(s) from hub","title":"Cscli install collection"},{"location":"cscli/cscli_install_collection/#cscli-install-collection","text":"Install given collection","title":"cscli install collection"},{"location":"cscli/cscli_install_collection/#synopsis","text":"Fetch and install given collection from hub cscli install collection [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_install_collection/#examples","text":"cscli install collection crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_install_collection/#options","text":"-h, --help help for collection","title":"Options"},{"location":"cscli/cscli_install_collection/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_install_collection/#see-also","text":"cscli install - Install configuration(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_install_parser/","text":"cscli install parser \u00b6 Install given parser Synopsis \u00b6 Fetch and install given parser from hub cscli install parser [config] [flags] Examples \u00b6 cscli install parser crowdsec/xxx Options \u00b6 -h, --help help for parser Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli install - Install configuration(s) from hub","title":"Cscli install parser"},{"location":"cscli/cscli_install_parser/#cscli-install-parser","text":"Install given parser","title":"cscli install parser"},{"location":"cscli/cscli_install_parser/#synopsis","text":"Fetch and install given parser from hub cscli install parser [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_install_parser/#examples","text":"cscli install parser crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_install_parser/#options","text":"-h, --help help for parser","title":"Options"},{"location":"cscli/cscli_install_parser/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_install_parser/#see-also","text":"cscli install - Install configuration(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_install_postoverflow/","text":"cscli install postoverflow \u00b6 Install given postoverflow parser Synopsis \u00b6 Fetch and install given postoverflow from hub. As a reminder, postoverflows are parsing configuration that will occur after the overflow (before a decision is applied). cscli install postoverflow [config] [flags] Examples \u00b6 cscli install collection crowdsec/xxx Options \u00b6 -h, --help help for postoverflow Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli install - Install configuration(s) from hub","title":"Cscli install postoverflow"},{"location":"cscli/cscli_install_postoverflow/#cscli-install-postoverflow","text":"Install given postoverflow parser","title":"cscli install postoverflow"},{"location":"cscli/cscli_install_postoverflow/#synopsis","text":"Fetch and install given postoverflow from hub. As a reminder, postoverflows are parsing configuration that will occur after the overflow (before a decision is applied). cscli install postoverflow [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_install_postoverflow/#examples","text":"cscli install collection crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_install_postoverflow/#options","text":"-h, --help help for postoverflow","title":"Options"},{"location":"cscli/cscli_install_postoverflow/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_install_postoverflow/#see-also","text":"cscli install - Install configuration(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_install_scenario/","text":"cscli install scenario \u00b6 Install given scenario Synopsis \u00b6 Fetch and install given scenario from hub cscli install scenario [config] [flags] Examples \u00b6 cscli install scenario crowdsec/xxx Options \u00b6 -h, --help help for scenario Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli install - Install configuration(s) from hub","title":"Cscli install scenario"},{"location":"cscli/cscli_install_scenario/#cscli-install-scenario","text":"Install given scenario","title":"cscli install scenario"},{"location":"cscli/cscli_install_scenario/#synopsis","text":"Fetch and install given scenario from hub cscli install scenario [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_install_scenario/#examples","text":"cscli install scenario crowdsec/xxx","title":"Examples"},{"location":"cscli/cscli_install_scenario/#options","text":"-h, --help help for scenario","title":"Options"},{"location":"cscli/cscli_install_scenario/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. -d, --download-only Only download packages, don't enable --error Set logging to error. --force Force install : Overwrite tainted and outdated files --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_install_scenario/#see-also","text":"cscli install - Install configuration(s) from hub","title":"SEE ALSO"},{"location":"cscli/cscli_list/","text":"cscli list \u00b6 List enabled configs Synopsis \u00b6 List enabled configurations (parser/scenarios/collections) on your host. It is possible to list also configuration from Crowdsec Hub with the '-a' options. [type] must be parsers, scenarios, postoverflows, collections cscli list [-a] [flags] Examples \u00b6 cscli list # List all local configurations cscli list [type] # List all local configuration of type [type] cscli list -a # List all local and remote configurations Options \u00b6 -a, --all List as well disabled items -h, --help help for list Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli list collections - List enabled collections cscli list parsers - List enabled parsers cscli list postoverflows - List enabled postoverflow parsers cscli list scenarios - List enabled scenarios","title":"List configurations"},{"location":"cscli/cscli_list/#cscli-list","text":"List enabled configs","title":"cscli list"},{"location":"cscli/cscli_list/#synopsis","text":"List enabled configurations (parser/scenarios/collections) on your host. It is possible to list also configuration from Crowdsec Hub with the '-a' options. [type] must be parsers, scenarios, postoverflows, collections cscli list [-a] [flags]","title":"Synopsis"},{"location":"cscli/cscli_list/#examples","text":"cscli list # List all local configurations cscli list [type] # List all local configuration of type [type] cscli list -a # List all local and remote configurations","title":"Examples"},{"location":"cscli/cscli_list/#options","text":"-a, --all List as well disabled items -h, --help help for list","title":"Options"},{"location":"cscli/cscli_list/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_list/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli list collections - List enabled collections cscli list parsers - List enabled parsers cscli list postoverflows - List enabled postoverflow parsers cscli list scenarios - List enabled scenarios","title":"SEE ALSO"},{"location":"cscli/cscli_list_collections/","text":"cscli list collections \u00b6 List enabled collections Synopsis \u00b6 List enabled collections cscli list collections [-a] [flags] Options \u00b6 -h, --help help for collections Options inherited from parent commands \u00b6 -a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli list - List enabled configs","title":"Cscli list collections"},{"location":"cscli/cscli_list_collections/#cscli-list-collections","text":"List enabled collections","title":"cscli list collections"},{"location":"cscli/cscli_list_collections/#synopsis","text":"List enabled collections cscli list collections [-a] [flags]","title":"Synopsis"},{"location":"cscli/cscli_list_collections/#options","text":"-h, --help help for collections","title":"Options"},{"location":"cscli/cscli_list_collections/#options-inherited-from-parent-commands","text":"-a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_list_collections/#see-also","text":"cscli list - List enabled configs","title":"SEE ALSO"},{"location":"cscli/cscli_list_parsers/","text":"cscli list parsers \u00b6 List enabled parsers Synopsis \u00b6 List enabled parsers cscli list parsers [-a] [flags] Options \u00b6 -h, --help help for parsers Options inherited from parent commands \u00b6 -a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli list - List enabled configs","title":"Cscli list parsers"},{"location":"cscli/cscli_list_parsers/#cscli-list-parsers","text":"List enabled parsers","title":"cscli list parsers"},{"location":"cscli/cscli_list_parsers/#synopsis","text":"List enabled parsers cscli list parsers [-a] [flags]","title":"Synopsis"},{"location":"cscli/cscli_list_parsers/#options","text":"-h, --help help for parsers","title":"Options"},{"location":"cscli/cscli_list_parsers/#options-inherited-from-parent-commands","text":"-a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_list_parsers/#see-also","text":"cscli list - List enabled configs","title":"SEE ALSO"},{"location":"cscli/cscli_list_postoverflows/","text":"cscli list postoverflows \u00b6 List enabled postoverflow parsers Synopsis \u00b6 List enabled postoverflow parsers cscli list postoverflows [-a] [flags] Options \u00b6 -h, --help help for postoverflows Options inherited from parent commands \u00b6 -a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli list - List enabled configs","title":"Cscli list postoverflows"},{"location":"cscli/cscli_list_postoverflows/#cscli-list-postoverflows","text":"List enabled postoverflow parsers","title":"cscli list postoverflows"},{"location":"cscli/cscli_list_postoverflows/#synopsis","text":"List enabled postoverflow parsers cscli list postoverflows [-a] [flags]","title":"Synopsis"},{"location":"cscli/cscli_list_postoverflows/#options","text":"-h, --help help for postoverflows","title":"Options"},{"location":"cscli/cscli_list_postoverflows/#options-inherited-from-parent-commands","text":"-a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_list_postoverflows/#see-also","text":"cscli list - List enabled configs","title":"SEE ALSO"},{"location":"cscli/cscli_list_scenarios/","text":"cscli list scenarios \u00b6 List enabled scenarios Synopsis \u00b6 List enabled scenarios cscli list scenarios [-a] [flags] Options \u00b6 -h, --help help for scenarios Options inherited from parent commands \u00b6 -a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli list - List enabled configs","title":"Cscli list scenarios"},{"location":"cscli/cscli_list_scenarios/#cscli-list-scenarios","text":"List enabled scenarios","title":"cscli list scenarios"},{"location":"cscli/cscli_list_scenarios/#synopsis","text":"List enabled scenarios cscli list scenarios [-a] [flags]","title":"Synopsis"},{"location":"cscli/cscli_list_scenarios/#options","text":"-h, --help help for scenarios","title":"Options"},{"location":"cscli/cscli_list_scenarios/#options-inherited-from-parent-commands","text":"-a, --all List as well disabled items -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_list_scenarios/#see-also","text":"cscli list - List enabled configs","title":"SEE ALSO"},{"location":"cscli/cscli_metrics/","text":"cscli metrics \u00b6 Display crowdsec prometheus metrics. Synopsis \u00b6 Fetch metrics from the prometheus server and display them in a human-friendly way cscli metrics [flags] Options \u00b6 -h, --help help for metrics -u, --url string Prometheus url (default \"http://127.0.0.1:6060/metrics\") Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec","title":"Metrics"},{"location":"cscli/cscli_metrics/#cscli-metrics","text":"Display crowdsec prometheus metrics.","title":"cscli metrics"},{"location":"cscli/cscli_metrics/#synopsis","text":"Fetch metrics from the prometheus server and display them in a human-friendly way cscli metrics [flags]","title":"Synopsis"},{"location":"cscli/cscli_metrics/#options","text":"-h, --help help for metrics -u, --url string Prometheus url (default \"http://127.0.0.1:6060/metrics\")","title":"Options"},{"location":"cscli/cscli_metrics/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_metrics/#see-also","text":"cscli - cscli allows you to manage crowdsec","title":"SEE ALSO"},{"location":"cscli/cscli_remove/","text":"cscli remove \u00b6 Remove/disable configuration(s) Synopsis \u00b6 Remove local configuration. [type] must be parser, scenario, postoverflow, collection [config_name] must be a valid config name from Crowdsec Hub or locally installed. Examples \u00b6 cscli remove [type] [config_name] Options \u00b6 --all Delete all the files in selected scope -h, --help help for remove --purge Delete source file in ~/.cscli/hub/ too Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli remove collection - Remove/disable collection cscli remove parser - Remove/disable parser cscli remove postoverflow - Remove/disable postoverflow parser cscli remove scenario - Remove/disable scenario","title":"Remove configurations"},{"location":"cscli/cscli_remove/#cscli-remove","text":"Remove/disable configuration(s)","title":"cscli remove"},{"location":"cscli/cscli_remove/#synopsis","text":"Remove local configuration. [type] must be parser, scenario, postoverflow, collection [config_name] must be a valid config name from Crowdsec Hub or locally installed.","title":"Synopsis"},{"location":"cscli/cscli_remove/#examples","text":"cscli remove [type] [config_name]","title":"Examples"},{"location":"cscli/cscli_remove/#options","text":"--all Delete all the files in selected scope -h, --help help for remove --purge Delete source file in ~/.cscli/hub/ too","title":"Options"},{"location":"cscli/cscli_remove/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_remove/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli remove collection - Remove/disable collection cscli remove parser - Remove/disable parser cscli remove postoverflow - Remove/disable postoverflow parser cscli remove scenario - Remove/disable scenario","title":"SEE ALSO"},{"location":"cscli/cscli_remove_collection/","text":"cscli remove collection \u00b6 Remove/disable collection Synopsis \u00b6 must be a valid collection. cscli remove collection [config] [flags] Options \u00b6 -h, --help help for collection Options inherited from parent commands \u00b6 --all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning. SEE ALSO \u00b6 cscli remove - Remove/disable configuration(s)","title":"Cscli remove collection"},{"location":"cscli/cscli_remove_collection/#cscli-remove-collection","text":"Remove/disable collection","title":"cscli remove collection"},{"location":"cscli/cscli_remove_collection/#synopsis","text":"must be a valid collection. cscli remove collection [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_remove_collection/#options","text":"-h, --help help for collection","title":"Options"},{"location":"cscli/cscli_remove_collection/#options-inherited-from-parent-commands","text":"--all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_remove_collection/#see-also","text":"cscli remove - Remove/disable configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_remove_parser/","text":"cscli remove parser \u00b6 Remove/disable parser Synopsis \u00b6 must be a valid parser. cscli remove parser <config> [flags] Options \u00b6 -h, --help help for parser Options inherited from parent commands \u00b6 --all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning. SEE ALSO \u00b6 cscli remove - Remove/disable configuration(s)","title":"Cscli remove parser"},{"location":"cscli/cscli_remove_parser/#cscli-remove-parser","text":"Remove/disable parser","title":"cscli remove parser"},{"location":"cscli/cscli_remove_parser/#synopsis","text":"must be a valid parser. cscli remove parser <config> [flags]","title":"Synopsis"},{"location":"cscli/cscli_remove_parser/#options","text":"-h, --help help for parser","title":"Options"},{"location":"cscli/cscli_remove_parser/#options-inherited-from-parent-commands","text":"--all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_remove_parser/#see-also","text":"cscli remove - Remove/disable configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_remove_postoverflow/","text":"cscli remove postoverflow \u00b6 Remove/disable postoverflow parser Synopsis \u00b6 must be a valid collection. cscli remove postoverflow [config] [flags] Options \u00b6 -h, --help help for postoverflow Options inherited from parent commands \u00b6 --all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning. SEE ALSO \u00b6 cscli remove - Remove/disable configuration(s)","title":"Cscli remove postoverflow"},{"location":"cscli/cscli_remove_postoverflow/#cscli-remove-postoverflow","text":"Remove/disable postoverflow parser","title":"cscli remove postoverflow"},{"location":"cscli/cscli_remove_postoverflow/#synopsis","text":"must be a valid collection. cscli remove postoverflow [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_remove_postoverflow/#options","text":"-h, --help help for postoverflow","title":"Options"},{"location":"cscli/cscli_remove_postoverflow/#options-inherited-from-parent-commands","text":"--all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_remove_postoverflow/#see-also","text":"cscli remove - Remove/disable configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_remove_scenario/","text":"cscli remove scenario \u00b6 Remove/disable scenario Synopsis \u00b6 must be a valid scenario. cscli remove scenario [config] [flags] Options \u00b6 -h, --help help for scenario Options inherited from parent commands \u00b6 --all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning. SEE ALSO \u00b6 cscli remove - Remove/disable configuration(s)","title":"Cscli remove scenario"},{"location":"cscli/cscli_remove_scenario/#cscli-remove-scenario","text":"Remove/disable scenario","title":"cscli remove scenario"},{"location":"cscli/cscli_remove_scenario/#synopsis","text":"must be a valid scenario. cscli remove scenario [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_remove_scenario/#options","text":"-h, --help help for scenario","title":"Options"},{"location":"cscli/cscli_remove_scenario/#options-inherited-from-parent-commands","text":"--all Delete all the files in selected scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --purge Delete source file in ~/.cscli/hub/ too --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_remove_scenario/#see-also","text":"cscli remove - Remove/disable configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_simulation/","text":"cscli simulation \u00b6 Synopsis \u00b6 Options \u00b6 -h, --help help for simulation Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli simulation disable - Disable the simulation mode. Disable only specified scenarios cscli simulation enable - Enable the simulation, globally or on specified scenarios cscli simulation status - Show simulation mode status","title":"Manage simulation"},{"location":"cscli/cscli_simulation/#cscli-simulation","text":"","title":"cscli simulation"},{"location":"cscli/cscli_simulation/#synopsis","text":"","title":"Synopsis"},{"location":"cscli/cscli_simulation/#options","text":"-h, --help help for simulation","title":"Options"},{"location":"cscli/cscli_simulation/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli simulation disable - Disable the simulation mode. Disable only specified scenarios cscli simulation enable - Enable the simulation, globally or on specified scenarios cscli simulation status - Show simulation mode status","title":"SEE ALSO"},{"location":"cscli/cscli_simulation_disable/","text":"cscli simulation disable \u00b6 Disable the simulation mode. Disable only specified scenarios Synopsis \u00b6 Disable the simulation mode. Disable only specified scenarios cscli simulation disable [scenario_name] [flags] Examples \u00b6 cscli simulation disable Options \u00b6 -h, --help help for disable Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli simulation -","title":"Cscli simulation disable"},{"location":"cscli/cscli_simulation_disable/#cscli-simulation-disable","text":"Disable the simulation mode. Disable only specified scenarios","title":"cscli simulation disable"},{"location":"cscli/cscli_simulation_disable/#synopsis","text":"Disable the simulation mode. Disable only specified scenarios cscli simulation disable [scenario_name] [flags]","title":"Synopsis"},{"location":"cscli/cscli_simulation_disable/#examples","text":"cscli simulation disable","title":"Examples"},{"location":"cscli/cscli_simulation_disable/#options","text":"-h, --help help for disable","title":"Options"},{"location":"cscli/cscli_simulation_disable/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation_disable/#see-also","text":"cscli simulation -","title":"SEE ALSO"},{"location":"cscli/cscli_simulation_enable/","text":"cscli simulation enable \u00b6 Enable the simulation, globally or on specified scenarios Synopsis \u00b6 Enable the simulation, globally or on specified scenarios cscli simulation enable [scenario_name] [flags] Examples \u00b6 cscli simulation enable Options \u00b6 -h, --help help for enable Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli simulation -","title":"Cscli simulation enable"},{"location":"cscli/cscli_simulation_enable/#cscli-simulation-enable","text":"Enable the simulation, globally or on specified scenarios","title":"cscli simulation enable"},{"location":"cscli/cscli_simulation_enable/#synopsis","text":"Enable the simulation, globally or on specified scenarios cscli simulation enable [scenario_name] [flags]","title":"Synopsis"},{"location":"cscli/cscli_simulation_enable/#examples","text":"cscli simulation enable","title":"Examples"},{"location":"cscli/cscli_simulation_enable/#options","text":"-h, --help help for enable","title":"Options"},{"location":"cscli/cscli_simulation_enable/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation_enable/#see-also","text":"cscli simulation -","title":"SEE ALSO"},{"location":"cscli/cscli_simulation_status/","text":"cscli simulation status \u00b6 Show simulation mode status Synopsis \u00b6 Show simulation mode status cscli simulation status [flags] Examples \u00b6 cscli simulation status Options \u00b6 -h, --help help for status Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli simulation -","title":"Cscli simulation status"},{"location":"cscli/cscli_simulation_status/#cscli-simulation-status","text":"Show simulation mode status","title":"cscli simulation status"},{"location":"cscli/cscli_simulation_status/#synopsis","text":"Show simulation mode status cscli simulation status [flags]","title":"Synopsis"},{"location":"cscli/cscli_simulation_status/#examples","text":"cscli simulation status","title":"Examples"},{"location":"cscli/cscli_simulation_status/#options","text":"-h, --help help for status","title":"Options"},{"location":"cscli/cscli_simulation_status/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_simulation_status/#see-also","text":"cscli simulation -","title":"SEE ALSO"},{"location":"cscli/cscli_update/","text":"cscli update \u00b6 Fetch available configs from hub Synopsis \u00b6 Fetches the .index.json file from hub, containing the list of available configs. cscli update [flags] Options \u00b6 -h, --help help for update Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec","title":"Update"},{"location":"cscli/cscli_update/#cscli-update","text":"Fetch available configs from hub","title":"cscli update"},{"location":"cscli/cscli_update/#synopsis","text":"Fetches the .index.json file from hub, containing the list of available configs. cscli update [flags]","title":"Synopsis"},{"location":"cscli/cscli_update/#options","text":"-h, --help help for update","title":"Options"},{"location":"cscli/cscli_update/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_update/#see-also","text":"cscli - cscli allows you to manage crowdsec","title":"SEE ALSO"},{"location":"cscli/cscli_upgrade/","text":"cscli upgrade \u00b6 Upgrade configuration(s) Synopsis \u00b6 Upgrade configuration from the CrowdSec Hub. In order to upgrade latest versions of configuration, the Hub cache should be updated . Tainted configuration will not be updated (use --force to update them). [type] must be parser, scenario, postoverflow, collection. [config_name] must be a valid config name from Crowdsec Hub . cscli upgrade [type] [config] [flags] Examples \u00b6 cscli upgrade [type] [config_name] cscli upgrade --all # Upgrade all configurations types cscli upgrade --force # Overwrite tainted configuration Options \u00b6 --all Upgrade all configuration in scope --force Overwrite existing files, even if tainted -h, --help help for upgrade Options inherited from parent commands \u00b6 -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli - cscli allows you to manage crowdsec cscli upgrade collection - Upgrade collection configuration(s) cscli upgrade parser - Upgrade parser configuration(s) cscli upgrade postoverflow - Upgrade postoverflow parser configuration(s) cscli upgrade scenario - Upgrade scenario configuration(s)","title":"Upgrade configurations"},{"location":"cscli/cscli_upgrade/#cscli-upgrade","text":"Upgrade configuration(s)","title":"cscli upgrade"},{"location":"cscli/cscli_upgrade/#synopsis","text":"Upgrade configuration from the CrowdSec Hub. In order to upgrade latest versions of configuration, the Hub cache should be updated . Tainted configuration will not be updated (use --force to update them). [type] must be parser, scenario, postoverflow, collection. [config_name] must be a valid config name from Crowdsec Hub . cscli upgrade [type] [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_upgrade/#examples","text":"cscli upgrade [type] [config_name] cscli upgrade --all # Upgrade all configurations types cscli upgrade --force # Overwrite tainted configuration","title":"Examples"},{"location":"cscli/cscli_upgrade/#options","text":"--all Upgrade all configuration in scope --force Overwrite existing files, even if tainted -h, --help help for upgrade","title":"Options"},{"location":"cscli/cscli_upgrade/#options-inherited-from-parent-commands","text":"-c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_upgrade/#see-also","text":"cscli - cscli allows you to manage crowdsec cscli upgrade collection - Upgrade collection configuration(s) cscli upgrade parser - Upgrade parser configuration(s) cscli upgrade postoverflow - Upgrade postoverflow parser configuration(s) cscli upgrade scenario - Upgrade scenario configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_upgrade_collection/","text":"cscli upgrade collection \u00b6 Upgrade collection configuration(s) Synopsis \u00b6 Upgrade one or more collection configurations cscli upgrade collection [config] [flags] Examples \u00b6 - cscli upgrade collection crowdsec/apache-lamp - cscli upgrade collection -all - cscli upgrade collection crowdsec/apache-lamp --force Options \u00b6 -h, --help help for collection Options inherited from parent commands \u00b6 --all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli upgrade - Upgrade configuration(s)","title":"Cscli upgrade collection"},{"location":"cscli/cscli_upgrade_collection/#cscli-upgrade-collection","text":"Upgrade collection configuration(s)","title":"cscli upgrade collection"},{"location":"cscli/cscli_upgrade_collection/#synopsis","text":"Upgrade one or more collection configurations cscli upgrade collection [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_upgrade_collection/#examples","text":"- cscli upgrade collection crowdsec/apache-lamp - cscli upgrade collection -all - cscli upgrade collection crowdsec/apache-lamp --force","title":"Examples"},{"location":"cscli/cscli_upgrade_collection/#options","text":"-h, --help help for collection","title":"Options"},{"location":"cscli/cscli_upgrade_collection/#options-inherited-from-parent-commands","text":"--all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_upgrade_collection/#see-also","text":"cscli upgrade - Upgrade configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_upgrade_parser/","text":"cscli upgrade parser \u00b6 Upgrade parser configuration(s) Synopsis \u00b6 Upgrade one or more parser configurations cscli upgrade parser [config] [flags] Examples \u00b6 - cscli upgrade parser crowdsec/apache-logs - cscli upgrade parser -all - cscli upgrade parser crowdsec/apache-logs --force Options \u00b6 -h, --help help for parser Options inherited from parent commands \u00b6 --all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli upgrade - Upgrade configuration(s)","title":"Cscli upgrade parser"},{"location":"cscli/cscli_upgrade_parser/#cscli-upgrade-parser","text":"Upgrade parser configuration(s)","title":"cscli upgrade parser"},{"location":"cscli/cscli_upgrade_parser/#synopsis","text":"Upgrade one or more parser configurations cscli upgrade parser [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_upgrade_parser/#examples","text":"- cscli upgrade parser crowdsec/apache-logs - cscli upgrade parser -all - cscli upgrade parser crowdsec/apache-logs --force","title":"Examples"},{"location":"cscli/cscli_upgrade_parser/#options","text":"-h, --help help for parser","title":"Options"},{"location":"cscli/cscli_upgrade_parser/#options-inherited-from-parent-commands","text":"--all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_upgrade_parser/#see-also","text":"cscli upgrade - Upgrade configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_upgrade_postoverflow/","text":"cscli upgrade postoverflow \u00b6 Upgrade postoverflow parser configuration(s) Synopsis \u00b6 Upgrade one or more postoverflow parser configurations cscli upgrade postoverflow [config] [flags] Examples \u00b6 - cscli upgrade postoverflow crowdsec/enrich-rdns - cscli upgrade postoverflow -all - cscli upgrade postoverflow crowdsec/enrich-rdns --force Options \u00b6 -h, --help help for postoverflow Options inherited from parent commands \u00b6 --all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli upgrade - Upgrade configuration(s)","title":"Cscli upgrade postoverflow"},{"location":"cscli/cscli_upgrade_postoverflow/#cscli-upgrade-postoverflow","text":"Upgrade postoverflow parser configuration(s)","title":"cscli upgrade postoverflow"},{"location":"cscli/cscli_upgrade_postoverflow/#synopsis","text":"Upgrade one or more postoverflow parser configurations cscli upgrade postoverflow [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_upgrade_postoverflow/#examples","text":"- cscli upgrade postoverflow crowdsec/enrich-rdns - cscli upgrade postoverflow -all - cscli upgrade postoverflow crowdsec/enrich-rdns --force","title":"Examples"},{"location":"cscli/cscli_upgrade_postoverflow/#options","text":"-h, --help help for postoverflow","title":"Options"},{"location":"cscli/cscli_upgrade_postoverflow/#options-inherited-from-parent-commands","text":"--all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_upgrade_postoverflow/#see-also","text":"cscli upgrade - Upgrade configuration(s)","title":"SEE ALSO"},{"location":"cscli/cscli_upgrade_scenario/","text":"cscli upgrade scenario \u00b6 Upgrade scenario configuration(s) Synopsis \u00b6 Upgrade one or more scenario configurations cscli upgrade scenario [config] [flags] Examples \u00b6 - cscli upgrade scenario -all - cscli upgrade scenario crowdsec/http-404 --force Options \u00b6 -h, --help help for scenario Options inherited from parent commands \u00b6 --all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning. SEE ALSO \u00b6 cscli upgrade - Upgrade configuration(s)","title":"Cscli upgrade scenario"},{"location":"cscli/cscli_upgrade_scenario/#cscli-upgrade-scenario","text":"Upgrade scenario configuration(s)","title":"cscli upgrade scenario"},{"location":"cscli/cscli_upgrade_scenario/#synopsis","text":"Upgrade one or more scenario configurations cscli upgrade scenario [config] [flags]","title":"Synopsis"},{"location":"cscli/cscli_upgrade_scenario/#examples","text":"- cscli upgrade scenario -all - cscli upgrade scenario crowdsec/http-404 --force","title":"Examples"},{"location":"cscli/cscli_upgrade_scenario/#options","text":"-h, --help help for scenario","title":"Options"},{"location":"cscli/cscli_upgrade_scenario/#options-inherited-from-parent-commands","text":"--all Upgrade all configuration in scope -c, --config string path to crowdsec config file (default \"/etc/crowdsec/config/default.yaml\") --debug Set logging to debug. --error Set logging to error. --force Overwrite existing files, even if tainted --info Set logging to info. -o, --output string Output format : human, json, raw. (default \"human\") --warning Set logging to warning.","title":"Options inherited from parent commands"},{"location":"cscli/cscli_upgrade_scenario/#see-also","text":"cscli upgrade - Upgrade configuration(s)","title":"SEE ALSO"},{"location":"getting_started/concepts/","text":"{{v0X.crowdsec.Name}}'s main goal is to crunch logs to detect things (duh). You will find below an introduction to the concepts that are frequently used within the documentation. Acquisition \u00b6 Acquistion configuration defines which streams of information {{v0X.crowdsec.name}} is going to process. At the time of writing, it's mostly files, but it should be more or less any kind of stream, such as a kafka topic or a cloudtrail. Acquisition configuration always contains a stream (ie. a file to tail) and a tag (ie. \"these are in syslog format\" \"these are non-syslog nginx logs\"). File acquisition configuration is defined as : filenames : #a list of file or regexp to read from (supports regular expressions) - /var/log/nginx/http_access.log - /var/log/nginx/https_access.log - /var/log/nginx/error.log labels : type : nginx --- filenames : - /var/log/auth.log labels : type : syslog The labels part is here to tag the incoming logs with a type. labels.type are used by the parsers to know which logs to process. Parsers [ reference ] \u00b6 For logs to be able to be exploited and analyzed, they need to be parsed and normalized, and this is where parsers are used. A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing. A parser usually has a specific scope. For example, if you are using nginx , you will probably want to use the crowdsecurity/nginx-logs which allows your {{v0X.crowdsec.name}} setup to parse nginx's access and error logs. Parsers are organized into stages to allow pipelines and branching in parsing. See the {{v0X.hub.name}} to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing You can as well write your own ! Stages \u00b6 Parsers are organized into \"stages\" to allow pipelines and branching in parsing. Each parser belongs to a stage, and can trigger next stage when successful. At the time of writing, the parsers are organized around 3 stages : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) The number and structure of stages can be altered by the user, the directory structure and their alphabetical order dictates in which order stages and parsers are processed. Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Thus a sshd log might follow this pipeline : s00-raw : be parsed by crowdsecurity/syslog-logs (will move event to the next stage) s01-raw : be parsed by crowdsecurity/sshd-logs (will move event to the next stage) s02-enrich : will be parsed by crowdsecurity/geoip-enrich and crowdsecurity/dateparse-enrich Enrichers \u00b6 Enrichment is the action of adding extra context to an event based on the information we already have, so that better decision can later be taken. In most cases, you should be able to find the relevant enrichers on our {{v0X.hub.htmlname}}. A common/simple type of enrichment would be geoip-enrich of an event (adding information such as : origin country, origin AS and origin IP range to an event). Once again, you should be able to find the ones you're looking for on the {{v0X.hub.htmlname}} ! Scenarios [ reference ] \u00b6 Scenarios is the expression of a heuristic that allows you to qualify a specific event (usually an attack).It is a YAML file that describes a set of events characterizing a scenario. Scenarios in {{v0X.crowdsec.name}} gravitate around the leaky bucket principle. A scenario description includes at least : Event eligibility rules. (For example if we're writing a ssh bruteforce detection we only focus on logs of type ssh_failed_auth ) Bucket configuration such as the leak speed or its capacity (in our same ssh bruteforce example, we might allow 1 failed auth per 10s and no more than 5 in a short amount of time: leakspeed: 10s capacity: 5 ) Aggregation rules : per source ip or per other criterias (in our ssh bruteforce example, we will group per source ip) The description allows for many other rules to be specified (blackhole, distinct filters etc.), to allow rather complex scenarios. See the {{v0X.hub.name}} to explore scenarios and their capabilities, or see below some examples : ssh bruteforce detection distinct http-404 scan iptables port scan You can as well write your own ! Collections \u00b6 To make user's life easier, \"collections\" are available, which are just a bundle of parsers and scenarios. In this way, if you want to cover basic use-cases of let's say \"nginx\", you can just install the crowdsecurity/nginx collection that is composed of crowdsecurity/nginx-logs parser, as well as generic http scenarios such as crowdsecurity/base-http-scenarios . As usual, those can be found on the {{v0X.hub.htmlname}} ! Event \u00b6 The objects that are processed within {{v0X.crowdsec.name}} are named \"Events\". An Event can be a log line, or an overflow result. This object layout evolves around a few important items : Parsed is an associative array that will be used during parsing to store temporary variables or processing results. Enriched , very similar to Parsed , is an associative array but is intended to be used for enrichment process. Overflow is a SignalOccurence structure that represents information about a triggered scenario, when applicable. Meta is an associative array that will be used to keep track of meta information about the event. Other fields omitted for clarity, see pkg/types/event.go for detailed definition Overflow or SignalOccurence \u00b6 This object holds the relevant information about a scenario that happened : who / when / where / what etc. Its most relevant fields are : Scenario : name of the scenario Alert_message : a humanly readable message about what happened Events_count : the number of individual events that lead to said overflow Start_at + Stop_at : timestamp of the first and last events that triggered the scenario Source : a binary representation of the source of the attack Source_[ip,range,AutonomousSystemNumber,AutonomousSystemOrganization,Country] : string representation of source information Labels : an associative array representing the scenario \"labels\" (see scenario definition) Other fields omitted for clarity, see pkg/types/signal_occurence.go for detailed definition PostOverflow \u00b6 A postoverflow is a parser that will be applied on overflows (scenario results) before the decision is written to local DB or pushed to API. Parsers in postoverflows are meant to be used for \"expensive\" enrichment/parsing process that you do not want to perform on all incoming events, but rather on decision that are about to be taken. An example could be slack/mattermost enrichment plugin that requires human confirmation before applying the decision or reverse-dns lookup operations.","title":"Concepts & Glossary"},{"location":"getting_started/concepts/#acquisition","text":"Acquistion configuration defines which streams of information {{v0X.crowdsec.name}} is going to process. At the time of writing, it's mostly files, but it should be more or less any kind of stream, such as a kafka topic or a cloudtrail. Acquisition configuration always contains a stream (ie. a file to tail) and a tag (ie. \"these are in syslog format\" \"these are non-syslog nginx logs\"). File acquisition configuration is defined as : filenames : #a list of file or regexp to read from (supports regular expressions) - /var/log/nginx/http_access.log - /var/log/nginx/https_access.log - /var/log/nginx/error.log labels : type : nginx --- filenames : - /var/log/auth.log labels : type : syslog The labels part is here to tag the incoming logs with a type. labels.type are used by the parsers to know which logs to process.","title":"Acquisition"},{"location":"getting_started/concepts/#parsers-reference","text":"For logs to be able to be exploited and analyzed, they need to be parsed and normalized, and this is where parsers are used. A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing. A parser usually has a specific scope. For example, if you are using nginx , you will probably want to use the crowdsecurity/nginx-logs which allows your {{v0X.crowdsec.name}} setup to parse nginx's access and error logs. Parsers are organized into stages to allow pipelines and branching in parsing. See the {{v0X.hub.name}} to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing You can as well write your own !","title":"Parsers [reference]"},{"location":"getting_started/concepts/#stages","text":"Parsers are organized into \"stages\" to allow pipelines and branching in parsing. Each parser belongs to a stage, and can trigger next stage when successful. At the time of writing, the parsers are organized around 3 stages : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) The number and structure of stages can be altered by the user, the directory structure and their alphabetical order dictates in which order stages and parsers are processed. Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Thus a sshd log might follow this pipeline : s00-raw : be parsed by crowdsecurity/syslog-logs (will move event to the next stage) s01-raw : be parsed by crowdsecurity/sshd-logs (will move event to the next stage) s02-enrich : will be parsed by crowdsecurity/geoip-enrich and crowdsecurity/dateparse-enrich","title":"Stages"},{"location":"getting_started/concepts/#enrichers","text":"Enrichment is the action of adding extra context to an event based on the information we already have, so that better decision can later be taken. In most cases, you should be able to find the relevant enrichers on our {{v0X.hub.htmlname}}. A common/simple type of enrichment would be geoip-enrich of an event (adding information such as : origin country, origin AS and origin IP range to an event). Once again, you should be able to find the ones you're looking for on the {{v0X.hub.htmlname}} !","title":"Enrichers"},{"location":"getting_started/concepts/#scenarios-reference","text":"Scenarios is the expression of a heuristic that allows you to qualify a specific event (usually an attack).It is a YAML file that describes a set of events characterizing a scenario. Scenarios in {{v0X.crowdsec.name}} gravitate around the leaky bucket principle. A scenario description includes at least : Event eligibility rules. (For example if we're writing a ssh bruteforce detection we only focus on logs of type ssh_failed_auth ) Bucket configuration such as the leak speed or its capacity (in our same ssh bruteforce example, we might allow 1 failed auth per 10s and no more than 5 in a short amount of time: leakspeed: 10s capacity: 5 ) Aggregation rules : per source ip or per other criterias (in our ssh bruteforce example, we will group per source ip) The description allows for many other rules to be specified (blackhole, distinct filters etc.), to allow rather complex scenarios. See the {{v0X.hub.name}} to explore scenarios and their capabilities, or see below some examples : ssh bruteforce detection distinct http-404 scan iptables port scan You can as well write your own !","title":"Scenarios [reference]"},{"location":"getting_started/concepts/#collections","text":"To make user's life easier, \"collections\" are available, which are just a bundle of parsers and scenarios. In this way, if you want to cover basic use-cases of let's say \"nginx\", you can just install the crowdsecurity/nginx collection that is composed of crowdsecurity/nginx-logs parser, as well as generic http scenarios such as crowdsecurity/base-http-scenarios . As usual, those can be found on the {{v0X.hub.htmlname}} !","title":"Collections"},{"location":"getting_started/concepts/#event","text":"The objects that are processed within {{v0X.crowdsec.name}} are named \"Events\". An Event can be a log line, or an overflow result. This object layout evolves around a few important items : Parsed is an associative array that will be used during parsing to store temporary variables or processing results. Enriched , very similar to Parsed , is an associative array but is intended to be used for enrichment process. Overflow is a SignalOccurence structure that represents information about a triggered scenario, when applicable. Meta is an associative array that will be used to keep track of meta information about the event. Other fields omitted for clarity, see pkg/types/event.go for detailed definition","title":"Event"},{"location":"getting_started/concepts/#overflow-or-signaloccurence","text":"This object holds the relevant information about a scenario that happened : who / when / where / what etc. Its most relevant fields are : Scenario : name of the scenario Alert_message : a humanly readable message about what happened Events_count : the number of individual events that lead to said overflow Start_at + Stop_at : timestamp of the first and last events that triggered the scenario Source : a binary representation of the source of the attack Source_[ip,range,AutonomousSystemNumber,AutonomousSystemOrganization,Country] : string representation of source information Labels : an associative array representing the scenario \"labels\" (see scenario definition) Other fields omitted for clarity, see pkg/types/signal_occurence.go for detailed definition","title":"Overflow or SignalOccurence"},{"location":"getting_started/concepts/#postoverflow","text":"A postoverflow is a parser that will be applied on overflows (scenario results) before the decision is written to local DB or pushed to API. Parsers in postoverflows are meant to be used for \"expensive\" enrichment/parsing process that you do not want to perform on all incoming events, but rather on decision that are about to be taken. An example could be slack/mattermost enrichment plugin that requires human confirmation before applying the decision or reverse-dns lookup operations.","title":"PostOverflow"},{"location":"getting_started/crowdsec-tour/","text":"List installed configurations \u00b6 List installed parsers/scenarios/collections/enricher {{ v0X.cli.bin }} list On the machine where you deployed {{v0X.crowdsec.name}}, type {{v0X.cli.bin}} list to see deployed configurations. This list represents the parsers, scenarios and/or collections that you deployed. They represent what your {{v0X.crowdsec.name}} setup can read (logs) and detect (scenarios). Check {{v0X.cli.name}} configuration management for more ! output example bui@sd:~$ {{ v0X.cli.bin }} list INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] PARSERS: -------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------------- crowdsec/nginx-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml crowdsec/sshd-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/sshd-logs.yaml crowdsec/syslog-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml crowdsec/whitelists \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/whitelists.yaml crowdsec/dateparse-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/dateparse-enrich.yaml crowdsec/iptables-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/iptables-logs.yaml crowdsec/naxsi-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/naxsi-logs.yaml crowdsec/http-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/http-logs.yaml crowdsec/geoip-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/geoip-enrich.yaml -------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] SCENARIOS: ----------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ----------------------------------------------------------------------------------------------------------------------------- crowdsec/http-crawl-non_statics \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-crawl-non_statics.yaml crowdsec/iptables-scan-multi_ports \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/iptables-scan-multi_ports.yaml crowdsec/http-scan-uniques_404 \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-scan-uniques_404.yaml crowdsec/ssh-bf \u2714\ufe0f enabled 0 .8 /etc/crowdsec/config/scenarios/ssh-bf.yaml ----------------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] COLLECTIONS: ------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------------------- crowdsec/base-http-scenarios \u2714\ufe0f enabled 0 .1 /etc/crowdsec/config/collections/base-http-scenarios.yaml crowdsec/iptables \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/iptables.yaml crowdsec/nginx \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/nginx.yaml crowdsec/sshd \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/sshd.yaml crowdsec/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/linux.yaml ------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] POSTOVERFLOWS: -------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------- -------------------------------------- Finding configurations \u00b6 {{v0X.crowdsec.Name}} efficiency is dictated by installed parsers and scenarios, so take a look at the {{v0X.hub.name}} to find the appropriated ones ! If you didn't perform the setup with the wizard, or if you are reading logs from other machines, you will have to pick the right {{v0X.collections.htmlname}}. This will ensure that {{v0X.crowdsec.name}} can parse the logs and has the corresponding scenarios. For example, if you're processing nginx logs, you might want to install the nginx collection . A collection can be installed by typing cscli install collection crowdsecurity/nginx , and provides all the necessary parsers and scenarios to handle said log source. systemctl reload crowdsec to ensure the new scenarios are loaded. In the same spirit, the crowdsecurity/sshd 's collection will fit most sshd setups ! While {{v0X.crowdsec.name}} is running, a quick look at cscli metrics should help you ensure that your log sources are correctly parsed. List existing bans \u00b6 List current bans {{ v0X.cli.bin }} ban list On the machine where you deployed {{v0X.crowdsec.name}}, type {{v0X.cli.bin}} ban list to see existing bans. If you just deployed {{v0X.crowdsec.name}}, the list might be empty, but don't worry, it simply means you haven't yet been attacked, congrats! Check {{v0X.cli.name}} ban management for more ! output example bui@sd:~$ {{ v0X.cli.bin }} ban list 7 local decisions: +--------+----------------+--------------------------------+------+--------+---------+--------------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+----------------+--------------------------------+------+--------+---------+--------------------------------+--------+------------+ | local | 103 .218.xxx.xx | crowdsecurity/ssh-bf | 4 | ban | HK | 59077 Shanghai UCloud | 24 | 3h28m24s | | | | | | | | Information Technology Company | | | | | | | | | | Limited | | | | local | 176 .174.x.xx | crowdsecurity/ssh-bf | 11 | ban | FR | 5410 Bouygues Telecom SA | 66 | 2h48m6s | | local | 37 .49.xxx.xxx | crowdsecurity/ssh-bf | 4 | ban | NL | 0 | 37 | 2h16m35s | | local | 37 .49.xxx.xx | crowdsecurity/ssh-bf_user-enum | 5 | ban | NL | 0 | 59 | 2h16m21s | | local | 92 .246.xx.xxx | crowdsecurity/ssh-bf_user-enum | 2 | ban | | 0 | 12 | 1h42m2s | | local | 23 .237.x.xx | crowdsecurity/ssh-bf | 8 | ban | US | 174 Cogent Communications | 48 | 1h7m48s | | local | 185 .153.xxx.xx | crowdsecurity/ssh-bf_user-enum | 59 | ban | MD | 49877 RM Engineering LLC | 449 | 12m54s | +--------+----------------+--------------------------------+------+--------+---------+--------------------------------+--------+------------+ And 64 records from API, 32 distinct AS, 19 distinct countries There are different bans sources: local : bans triggered locally api : bans fetched from the API as part of the global consensus cli : bans added via {{v0X.cli.bin}} ban add Monitor on-going activity (prometheus) \u00b6 List metrics {{ v0X.cli.bin }} metrics The metrics displayed are extracted from {{v0X.crowdsec.name}} prometheus. The indicators are grouped by scope : Buckets : Know which buckets are created and/or overflew (scenario efficiency) Acquisition : Know which file produce logs and if thy are parsed (or end up in bucket) Parser : Know how frequently the individual parsers are triggered and their success rate output example bui@sd:~$ {{ v0X.cli.bin }} metrics INFO [ 0000 ] Buckets Metrics: +---------------------------------+-----------+--------------+--------+---------+ | BUCKET | OVERFLOWS | INSTANTIATED | POURED | EXPIRED | +---------------------------------+-----------+--------------+--------+---------+ | crowdsec/http-scan-uniques_404 | 69 | 77 | 424 | 8 | | crowdsec/ssh-bf | 4 | 23 | 53 | 18 | | crowdsec/ssh-bf_user-enum | - | 21 | 23 | 20 | | crowdsec/http-crawl-non_statics | 9 | 14 | 425 | 5 | +---------------------------------+-----------+--------------+--------+---------+ INFO [ 0000 ] Acquisition Metrics: +------------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +------------------------------------------+------------+--------------+----------------+------------------------+ | /var/log/nginx/error.log | 496 | 496 | - | - | | /var/log/nginx/http.access.log | 472 | 465 | 7 | 847 | | /var/log/nginx/https.access.log | 1 | 1 | - | 2 | | /var/log/auth.log | 357 | 53 | 304 | 76 | | /var/log/kern.log | 2292 | - | 2292 | - | | /var/log/syslog | 2358 | - | 2358 | - | +------------------------------------------+------------+--------------+----------------+------------------------+ INFO [ 0000 ] Parser Metrics: +---------------------------+------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +---------------------------+------+--------+----------+ | crowdsec/syslog-logs | 5007 | 5007 | 0 | | crowdsec/whitelists | 1015 | 1015 | 0 | | crowdsec/dateparse-enrich | 1015 | 1015 | 0 | | crowdsec/geoip-enrich | 519 | 519 | 0 | | crowdsec/http-logs | 962 | 427 | 535 | | crowdsec/nginx-logs | 973 | 962 | 11 | | crowdsec/non-syslog | 969 | 969 | 0 | | crowdsec/sshd-logs | 350 | 53 | 297 | +---------------------------+------+--------+----------+ Monitor on-going activity (log files) \u00b6 The {{v0X.crowdsec.main_log}} file will tell you what is going on and when an IP is blocked. Check {{v0X.crowdsec.name}} monitoring for more ! output example bui@sd:~$ tail -f /var/log/crowdsec-agent.log time = \"14-04-2020 16:06:21\" level = warning msg = \"40 existing LeakyRoutine\" time = \"14-04-2020 16:14:07\" level = warning msg = \"1.2.3.4 triggered a 4h0m0s ip ban remediation for [crowdsec/ssh-bf]\" bucket_id = throbbing-forest event_time = \"2020-04-14 16:14:07.215101505 +0200 CEST m=+359659.646220115\" scenario = crowdsec/ssh-bf source_ip = 1 .2.3.4 time = \"14-04-2020 16:15:52\" level = info msg = \"api push signal: token renewed. Pushing signals\" time = \"14-04-2020 16:15:53\" level = info msg = \"api push signal: pushed 1 signals successfully\" time = \"14-04-2020 16:21:10\" level = warning msg = \"18 existing LeakyRoutine\" time = \"14-04-2020 16:30:01\" level = info msg = \"Flushed 1 expired entries from Ban Application\" time = \"14-04-2020 16:33:23\" level = warning msg = \"33 existing LeakyRoutine\" time = \"14-04-2020 16:35:58\" level = info msg = \"Flushed 1 expired entries from Ban Application\"","title":"Crowdsec Tour"},{"location":"getting_started/crowdsec-tour/#list-installed-configurations","text":"List installed parsers/scenarios/collections/enricher {{ v0X.cli.bin }} list On the machine where you deployed {{v0X.crowdsec.name}}, type {{v0X.cli.bin}} list to see deployed configurations. This list represents the parsers, scenarios and/or collections that you deployed. They represent what your {{v0X.crowdsec.name}} setup can read (logs) and detect (scenarios). Check {{v0X.cli.name}} configuration management for more ! output example bui@sd:~$ {{ v0X.cli.bin }} list INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] PARSERS: -------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------------- crowdsec/nginx-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml crowdsec/sshd-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/sshd-logs.yaml crowdsec/syslog-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml crowdsec/whitelists \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/whitelists.yaml crowdsec/dateparse-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/dateparse-enrich.yaml crowdsec/iptables-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/iptables-logs.yaml crowdsec/naxsi-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/naxsi-logs.yaml crowdsec/http-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/http-logs.yaml crowdsec/geoip-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/geoip-enrich.yaml -------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] SCENARIOS: ----------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ----------------------------------------------------------------------------------------------------------------------------- crowdsec/http-crawl-non_statics \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-crawl-non_statics.yaml crowdsec/iptables-scan-multi_ports \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/iptables-scan-multi_ports.yaml crowdsec/http-scan-uniques_404 \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-scan-uniques_404.yaml crowdsec/ssh-bf \u2714\ufe0f enabled 0 .8 /etc/crowdsec/config/scenarios/ssh-bf.yaml ----------------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] COLLECTIONS: ------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ------------------------------------------------------------------------------------------------------------------- crowdsec/base-http-scenarios \u2714\ufe0f enabled 0 .1 /etc/crowdsec/config/collections/base-http-scenarios.yaml crowdsec/iptables \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/iptables.yaml crowdsec/nginx \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/nginx.yaml crowdsec/sshd \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/sshd.yaml crowdsec/linux \u2714\ufe0f enabled 0 .2 /etc/crowdsec/config/collections/linux.yaml ------------------------------------------------------------------------------------------------------------------- INFO [ 0000 ] POSTOVERFLOWS: -------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------- --------------------------------------","title":"List installed configurations"},{"location":"getting_started/crowdsec-tour/#finding-configurations","text":"{{v0X.crowdsec.Name}} efficiency is dictated by installed parsers and scenarios, so take a look at the {{v0X.hub.name}} to find the appropriated ones ! If you didn't perform the setup with the wizard, or if you are reading logs from other machines, you will have to pick the right {{v0X.collections.htmlname}}. This will ensure that {{v0X.crowdsec.name}} can parse the logs and has the corresponding scenarios. For example, if you're processing nginx logs, you might want to install the nginx collection . A collection can be installed by typing cscli install collection crowdsecurity/nginx , and provides all the necessary parsers and scenarios to handle said log source. systemctl reload crowdsec to ensure the new scenarios are loaded. In the same spirit, the crowdsecurity/sshd 's collection will fit most sshd setups ! While {{v0X.crowdsec.name}} is running, a quick look at cscli metrics should help you ensure that your log sources are correctly parsed.","title":"Finding configurations"},{"location":"getting_started/crowdsec-tour/#list-existing-bans","text":"List current bans {{ v0X.cli.bin }} ban list On the machine where you deployed {{v0X.crowdsec.name}}, type {{v0X.cli.bin}} ban list to see existing bans. If you just deployed {{v0X.crowdsec.name}}, the list might be empty, but don't worry, it simply means you haven't yet been attacked, congrats! Check {{v0X.cli.name}} ban management for more ! output example bui@sd:~$ {{ v0X.cli.bin }} ban list 7 local decisions: +--------+----------------+--------------------------------+------+--------+---------+--------------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+----------------+--------------------------------+------+--------+---------+--------------------------------+--------+------------+ | local | 103 .218.xxx.xx | crowdsecurity/ssh-bf | 4 | ban | HK | 59077 Shanghai UCloud | 24 | 3h28m24s | | | | | | | | Information Technology Company | | | | | | | | | | Limited | | | | local | 176 .174.x.xx | crowdsecurity/ssh-bf | 11 | ban | FR | 5410 Bouygues Telecom SA | 66 | 2h48m6s | | local | 37 .49.xxx.xxx | crowdsecurity/ssh-bf | 4 | ban | NL | 0 | 37 | 2h16m35s | | local | 37 .49.xxx.xx | crowdsecurity/ssh-bf_user-enum | 5 | ban | NL | 0 | 59 | 2h16m21s | | local | 92 .246.xx.xxx | crowdsecurity/ssh-bf_user-enum | 2 | ban | | 0 | 12 | 1h42m2s | | local | 23 .237.x.xx | crowdsecurity/ssh-bf | 8 | ban | US | 174 Cogent Communications | 48 | 1h7m48s | | local | 185 .153.xxx.xx | crowdsecurity/ssh-bf_user-enum | 59 | ban | MD | 49877 RM Engineering LLC | 449 | 12m54s | +--------+----------------+--------------------------------+------+--------+---------+--------------------------------+--------+------------+ And 64 records from API, 32 distinct AS, 19 distinct countries There are different bans sources: local : bans triggered locally api : bans fetched from the API as part of the global consensus cli : bans added via {{v0X.cli.bin}} ban add","title":"List existing bans"},{"location":"getting_started/crowdsec-tour/#monitor-on-going-activity-prometheus","text":"List metrics {{ v0X.cli.bin }} metrics The metrics displayed are extracted from {{v0X.crowdsec.name}} prometheus. The indicators are grouped by scope : Buckets : Know which buckets are created and/or overflew (scenario efficiency) Acquisition : Know which file produce logs and if thy are parsed (or end up in bucket) Parser : Know how frequently the individual parsers are triggered and their success rate output example bui@sd:~$ {{ v0X.cli.bin }} metrics INFO [ 0000 ] Buckets Metrics: +---------------------------------+-----------+--------------+--------+---------+ | BUCKET | OVERFLOWS | INSTANTIATED | POURED | EXPIRED | +---------------------------------+-----------+--------------+--------+---------+ | crowdsec/http-scan-uniques_404 | 69 | 77 | 424 | 8 | | crowdsec/ssh-bf | 4 | 23 | 53 | 18 | | crowdsec/ssh-bf_user-enum | - | 21 | 23 | 20 | | crowdsec/http-crawl-non_statics | 9 | 14 | 425 | 5 | +---------------------------------+-----------+--------------+--------+---------+ INFO [ 0000 ] Acquisition Metrics: +------------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +------------------------------------------+------------+--------------+----------------+------------------------+ | /var/log/nginx/error.log | 496 | 496 | - | - | | /var/log/nginx/http.access.log | 472 | 465 | 7 | 847 | | /var/log/nginx/https.access.log | 1 | 1 | - | 2 | | /var/log/auth.log | 357 | 53 | 304 | 76 | | /var/log/kern.log | 2292 | - | 2292 | - | | /var/log/syslog | 2358 | - | 2358 | - | +------------------------------------------+------------+--------------+----------------+------------------------+ INFO [ 0000 ] Parser Metrics: +---------------------------+------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +---------------------------+------+--------+----------+ | crowdsec/syslog-logs | 5007 | 5007 | 0 | | crowdsec/whitelists | 1015 | 1015 | 0 | | crowdsec/dateparse-enrich | 1015 | 1015 | 0 | | crowdsec/geoip-enrich | 519 | 519 | 0 | | crowdsec/http-logs | 962 | 427 | 535 | | crowdsec/nginx-logs | 973 | 962 | 11 | | crowdsec/non-syslog | 969 | 969 | 0 | | crowdsec/sshd-logs | 350 | 53 | 297 | +---------------------------+------+--------+----------+","title":"Monitor on-going activity (prometheus)"},{"location":"getting_started/crowdsec-tour/#monitor-on-going-activity-log-files","text":"The {{v0X.crowdsec.main_log}} file will tell you what is going on and when an IP is blocked. Check {{v0X.crowdsec.name}} monitoring for more ! output example bui@sd:~$ tail -f /var/log/crowdsec-agent.log time = \"14-04-2020 16:06:21\" level = warning msg = \"40 existing LeakyRoutine\" time = \"14-04-2020 16:14:07\" level = warning msg = \"1.2.3.4 triggered a 4h0m0s ip ban remediation for [crowdsec/ssh-bf]\" bucket_id = throbbing-forest event_time = \"2020-04-14 16:14:07.215101505 +0200 CEST m=+359659.646220115\" scenario = crowdsec/ssh-bf source_ip = 1 .2.3.4 time = \"14-04-2020 16:15:52\" level = info msg = \"api push signal: token renewed. Pushing signals\" time = \"14-04-2020 16:15:53\" level = info msg = \"api push signal: pushed 1 signals successfully\" time = \"14-04-2020 16:21:10\" level = warning msg = \"18 existing LeakyRoutine\" time = \"14-04-2020 16:30:01\" level = info msg = \"Flushed 1 expired entries from Ban Application\" time = \"14-04-2020 16:33:23\" level = warning msg = \"33 existing LeakyRoutine\" time = \"14-04-2020 16:35:58\" level = info msg = \"Flushed 1 expired entries from Ban Application\"","title":"Monitor on-going activity (log files)"},{"location":"getting_started/installation/","text":"Installation \u00b6 Fetch {{v0X.crowdsec.name}}'s latest version here . tar xvzf crowdsec-release.tgz cd crowdsec-v0.X.X A {{v0X.wizard.name}} is provided to help you deploy {{v0X.crowdsec.name}} and {{v0X.cli.name}}. Using the interactive wizard \u00b6 sudo {{v0X.wizard.bin}} -i The {{v0X.wizard.name}} is going to guide you through the following steps : detect services that are present on your machine detect selected services logs suggest collections (parsers and scenarios) to deploy deploy & configure {{v0X.crowdsec.name}} in order to watch selected logs for selected scenarios The process should take less than a minute, please report if there are any issues . You are then ready to take a tour of your freshly deployed {{v0X.crowdsec.name}} ! Binary installation \u00b6 you of little faith sudo {{v0X.wizard.bin}} --bininstall This will deploy a valid/empty {{v0X.crowdsec.name}} configuration files and binaries. Beware, in this state, {{v0X.crowdsec.name}} won't monitor/detect anything unless configured. cscli install collection crowdsecurity/linux Installing at least the crowdsecurity/linux collection will provide you : syslog parser geoip enrichment date parsers You will need as well to configure your {{v0X.ref.acquis}} file to feed {{v0X.crowdsec.name}} some logs. From source \u00b6 Requirements Go v1.13+ git clone {{v0X.crowdsec.url}} jq Go in {{v0X.crowdsec.name}} folder and build the binaries : cd crowdsec make build {{v0X.crowdsec.name}} bin will be located in ./cmd/crowdsec/crowdsec and {{v0X.cli.name}} bin in cmd/crowdsec-cli/{{v0X.cli.bin}} Now, you can install either with interactive wizard or the unattended mode .","title":"Install Crowdsec"},{"location":"getting_started/installation/#installation","text":"Fetch {{v0X.crowdsec.name}}'s latest version here . tar xvzf crowdsec-release.tgz cd crowdsec-v0.X.X A {{v0X.wizard.name}} is provided to help you deploy {{v0X.crowdsec.name}} and {{v0X.cli.name}}.","title":"Installation"},{"location":"getting_started/installation/#using-the-interactive-wizard","text":"sudo {{v0X.wizard.bin}} -i The {{v0X.wizard.name}} is going to guide you through the following steps : detect services that are present on your machine detect selected services logs suggest collections (parsers and scenarios) to deploy deploy & configure {{v0X.crowdsec.name}} in order to watch selected logs for selected scenarios The process should take less than a minute, please report if there are any issues . You are then ready to take a tour of your freshly deployed {{v0X.crowdsec.name}} !","title":"Using the interactive wizard"},{"location":"getting_started/installation/#binary-installation","text":"you of little faith sudo {{v0X.wizard.bin}} --bininstall This will deploy a valid/empty {{v0X.crowdsec.name}} configuration files and binaries. Beware, in this state, {{v0X.crowdsec.name}} won't monitor/detect anything unless configured. cscli install collection crowdsecurity/linux Installing at least the crowdsecurity/linux collection will provide you : syslog parser geoip enrichment date parsers You will need as well to configure your {{v0X.ref.acquis}} file to feed {{v0X.crowdsec.name}} some logs.","title":"Binary installation"},{"location":"getting_started/installation/#from-source","text":"Requirements Go v1.13+ git clone {{v0X.crowdsec.url}} jq Go in {{v0X.crowdsec.name}} folder and build the binaries : cd crowdsec make build {{v0X.crowdsec.name}} bin will be located in ./cmd/crowdsec/crowdsec and {{v0X.cli.name}} bin in cmd/crowdsec-cli/{{v0X.cli.bin}} Now, you can install either with interactive wizard or the unattended mode .","title":"From source"},{"location":"guide/cscli/","text":"{{v0X.cli.bin}} is the utility that will help you to manage {{v0X.crowdsec.name}}. This tools has the following functionalities: manage bans backup and restore configuration display metrics install configurations remove configurations update configurations upgrade configurations list configurations interact with CrowdSec API manage simulation Take a look at the dedicated documentation Overview \u00b6 {{v0X.cli.name}} configuration location is /etc/crowdsec/cscli/ . In this folder, we store the {{v0X.cli.name}} configuration and the hub cache files. Config \u00b6 The {{v0X.cli.name}} configuration is light for now, stored in /etc/crowdsec/cscli/config . installdir : /etc/crowdsec/config # {{v0X.crowdsec.name}} configuration location backend : /etc/crowdsec/plugins/backend # path to the backend plugin used For {{v0X.cli.name}} to be able to pull the {{v0X.api.topX.htmlname}}, you need a valid API configuration in api.yaml . Hub cache \u00b6 .index.json : The file containing the metadata of all the existing {{v0X.collections.htmlname}}, {{v0X.parsers.htmlname}} and {{v0X.scenarios.htmlname}} stored in the {{v0X.hub.htmlname}}. hub/* : Folder containing all the {{v0X.collections.htmlname}}, {{v0X.parsers.htmlname}} and {{v0X.scenarios.htmlname}} stored in the {{v0X.hub.htmlname}}. This is used to manage configurations from the {{v0X.cli.name}}","title":"Cscli"},{"location":"guide/cscli/#overview","text":"{{v0X.cli.name}} configuration location is /etc/crowdsec/cscli/ . In this folder, we store the {{v0X.cli.name}} configuration and the hub cache files.","title":"Overview"},{"location":"guide/cscli/#config","text":"The {{v0X.cli.name}} configuration is light for now, stored in /etc/crowdsec/cscli/config . installdir : /etc/crowdsec/config # {{v0X.crowdsec.name}} configuration location backend : /etc/crowdsec/plugins/backend # path to the backend plugin used For {{v0X.cli.name}} to be able to pull the {{v0X.api.topX.htmlname}}, you need a valid API configuration in api.yaml .","title":"Config"},{"location":"guide/cscli/#hub-cache","text":".index.json : The file containing the metadata of all the existing {{v0X.collections.htmlname}}, {{v0X.parsers.htmlname}} and {{v0X.scenarios.htmlname}} stored in the {{v0X.hub.htmlname}}. hub/* : Folder containing all the {{v0X.collections.htmlname}}, {{v0X.parsers.htmlname}} and {{v0X.scenarios.htmlname}} stored in the {{v0X.hub.htmlname}}. This is used to manage configurations from the {{v0X.cli.name}}","title":"Hub cache"},{"location":"guide/overview/","text":"When talking about {{v0X.crowdsec.name}} or {{v0X.cli.name}} configurations, most of things are going to gravitate around {{v0X.parsers.htmlname}}, {{v0X.scenarios.htmlname}} and {{v0X.collections.htmlname}}. In most common setup, all these configurations should be found on the {{v0X.hub.htmlname}} and installed with {{v0X.cli.name}}. It is important to keep those configurations up-to-date via the {{v0X.cli.name}} upgrade command. See the {{v0X.cli.name}} list command to view the state of your deployed configurations.","title":"Overview"},{"location":"guide/crowdsec/acquisition/","text":"Info Please note that the {{v0X.config.acquis_path}} should be auto generated by the {{v0X.wizard.name}} in most case. The acquisition configuration specifies lists of files to monitor and associated \"labels\". The type label is mandatory as it's later used in the process to determine which parser(s) can handle lines coming from this source. Acquisition can be found in {{v0X.config.acquis_path}} , for example : Acquisition example filenames : - /var/log/nginx/access-*.log - /var/log/nginx/error.log labels : type : nginx --- filenames : - /var/log/auth.log labels : type : syslog Testing and viewing acquisition \u00b6 At startup \u00b6 At startup, you will see the monitored files in {{v0X.crowdsec.main_log}} : ... time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/nginx/http.access.log' (pattern:/var/log/nginx/http.access.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/nginx/https.access.log' (pattern:/var/log/nginx/https.access.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/nginx/error.log' (pattern:/var/log/nginx/error.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/auth.log' (pattern:/var/log/auth.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/syslog' (pattern:/var/log/syslog)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/kern.log' (pattern:/var/log/kern.log)\" ... At runtime \u00b6 {{v0X.cli.name}} allows you to view {{v0X.crowdsec.name}} metrics info via the metrics command. This allows you to see how many lines are coming from each source, and if they are parsed correctly. You can see those metrics with the following command: {{v0X.cli.bin}} metrics {{v0X.cli.name}} metrics example ## {{v0X.cli.bin}} metrics ... INFO [ 0000 ] Acquisition Metrics: +------------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +------------------------------------------+------------+--------------+----------------+------------------------+ | /var/log/nginx/http.access.log | 47 | 46 | 1 | 10 | | /var/log/nginx/https.access.log | 25 | 25 | - | 18 | | /var/log/kern.log | 297948 | 297948 | - | 69421 | | /var/log/syslog | 303868 | 297947 | 5921 | 71539 | | /var/log/auth.log | 63419 | 12896 | 50523 | 20463 | | /var/log/nginx/error.log | 65 | 65 | - | - | +------------------------------------------+------------+--------------+----------------+------------------------+ ... Info All these metrics are actually coming from {{v0X.crowdsec.name}}'s prometheus agent. See prometheus directly for more insights.","title":"Acquisition"},{"location":"guide/crowdsec/acquisition/#testing-and-viewing-acquisition","text":"","title":"Testing and viewing acquisition"},{"location":"guide/crowdsec/acquisition/#at-startup","text":"At startup, you will see the monitored files in {{v0X.crowdsec.main_log}} : ... time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/nginx/http.access.log' (pattern:/var/log/nginx/http.access.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/nginx/https.access.log' (pattern:/var/log/nginx/https.access.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/nginx/error.log' (pattern:/var/log/nginx/error.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/auth.log' (pattern:/var/log/auth.log)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/syslog' (pattern:/var/log/syslog)\" time=\"30-04-2020 08:57:25\" level=info msg=\"Opening file '/var/log/kern.log' (pattern:/var/log/kern.log)\" ...","title":"At startup"},{"location":"guide/crowdsec/acquisition/#at-runtime","text":"{{v0X.cli.name}} allows you to view {{v0X.crowdsec.name}} metrics info via the metrics command. This allows you to see how many lines are coming from each source, and if they are parsed correctly. You can see those metrics with the following command: {{v0X.cli.bin}} metrics {{v0X.cli.name}} metrics example ## {{v0X.cli.bin}} metrics ... INFO [ 0000 ] Acquisition Metrics: +------------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +------------------------------------------+------------+--------------+----------------+------------------------+ | /var/log/nginx/http.access.log | 47 | 46 | 1 | 10 | | /var/log/nginx/https.access.log | 25 | 25 | - | 18 | | /var/log/kern.log | 297948 | 297948 | - | 69421 | | /var/log/syslog | 303868 | 297947 | 5921 | 71539 | | /var/log/auth.log | 63419 | 12896 | 50523 | 20463 | | /var/log/nginx/error.log | 65 | 65 | - | - | +------------------------------------------+------------+--------------+----------------+------------------------+ ... Info All these metrics are actually coming from {{v0X.crowdsec.name}}'s prometheus agent. See prometheus directly for more insights.","title":"At runtime"},{"location":"guide/crowdsec/enrichers/","text":"Enrichers are basically {{v0X.parsers.htmlname}} that can rely on external methods to provide extra contextual information to the event. The enrichers are usually in the s02-enrich {{v0X.stage.htmlname}} (after most of the parsing happened). Enrichers functions should all accept a string as a parameter, and return an associative string array, that will be automatically merged into the Enriched map of the {{v0X.event.htmlname}}. Warning At the time of writing, enrichers plugin mechanism implementation is still ongoing (read: the list of available enrichment methods is currently hardcoded). As an example let's look into the geoip-enrich parser/enricher : It relies on the geolite2 data created by maxmind and the geoip2 golang module to provide the actual data. It exposes three methods : GeoIpCity GeoIpASN and IpToRange that are used by the crowdsecurity/geoip-enrich . Enrichers can be installed as any other parsers with the following command: {{v0X.cli.bin}} install parser crowdsecurity/geoip-enrich Take a tour at the {{v0X.hub.htmlname}} to find them !","title":"Enrichers"},{"location":"guide/crowdsec/overview/","text":"{{v0X.crowdsec.name}} configuration lives under {{v0X.config.crowdsec_dir}} and should be as : default.yaml \u00b6 This is the 'main' configuration file, it allows to specify parameters such as : logging (level and media) directories (config, data, runtime) API flag (on/off) prometheus (on/off) etc. Default configuration working_dir : /tmp/ data_dir : /var/lib/crowdsec/data config_dir : /etc/crowdsec/config pid_dir : /var/run log_dir : /var/log/ log_mode : file log_level : info profiling : false apimode : true daemon : true prometheus : true #for prometheus agent / golang debugging http_listen : 127.0.0.1:6060 plugin : backend : \"/etc/crowdsec/plugins/backend\" working_dir: \u00b6 The working directory where Prometheus will write metrics in text file. data_dir: \u00b6 Directory where {{v0X.crowdsec.Name}} will install its data ({{v0X.crowdsec.Name}} database for example). pid_dir: \u00b6 To specify where {{v0X.crowdsec.Name}} PID file will be stored. config_dir: \u00b6 To specify where {{v0X.crowdsec.Name}} configuration will be stored. log_dir: \u00b6 To specify where the logs should be stored. log_mode: \u00b6 To specify your selected logging mode, available modes are : file : to write logs in a file stdout : to write logs in STDOUT log_level: \u00b6 To specify the logging level, available levels: debug info warning error profiling: \u00b6 To enable or disable the profiling in {{v0X.crowdsec.Name}}. apimode: \u00b6 To enable or disable signals sending to the {{v0X.api.htmlname}}. daemon: \u00b6 To enable or disable {{v0X.crowdsec.Name}} daemon mode. prometheus: \u00b6 To enable or disable Prometheus metrics. prometheus_mode: \u00b6 If prometheus is enabled, and is set to aggregated , will restrict prometheus metrics to global ones. All metrics containing a source as a label will be unregistered. Meant to keep cardinality low when relevant. http_listen: \u00b6 To configure the Prometheus service listening address:port or {{v0X.crowdsec.Name}} profiling plugin: \u00b6 To specify the directories where {{v0X.ref.output}} plugins will be stored : * backend: : the path where all {{v0X.crowdsec.Name}} backend plugins (database output, ...) will be located. acquis.yaml \u00b6 This is the file that tells which streams (or files) {{v0X.crowdsec.name}} is reading, and their types (so that it knows how to parse them). If you're lucky, this file should be auto-generated by the wizard. You can find details on the configuration file format here . api.yaml \u00b6 Name is self-explanatory : it holds API configuration. This file should never be edited by a human : the wizard will deploy safe default for it, and {{v0X.cli.name}} will alter it on your behalf when you register or enroll your machine. You can look into it, and you should see : url endpoints login and password (auto-generated by your machine upon registration) To get new credentials : {{ v0X.cli.name }} api register Or if you loose your credentials: {{ v0X.cli.name }} api reset profiles.yaml \u00b6 The profiles is what allows you to decide how do you react when a scenario is triggered : do you notify yourself on mattermost/slack ? do you push the signal to a database so that your bouncers can stop the IP from continuing its attack ? do you want to avoid pushing this signal to the API ? Behind the scenes, the \"profiles\" system actually allows you to dispatch an event/overflow to various output plugins. You can find details on the configuration file format of {{v0X.ref.output}}. parsers/ \u00b6 This directory holds all the {{v0X.parsers.htmlname}} that are enabled on your system. The parsers are organized in {{v0X.stage.htmlname}} (which are just folders) and the {{v0X.parsers.htmlname}} themselves are yaml files. scenarios/ \u00b6 This directory holds all the {{v0X.scenarios.htmlname}} that are enabled on your system. The {{v0X.scenarios.htmlname}} are yaml files.","title":"Overview"},{"location":"guide/crowdsec/overview/#defaultyaml","text":"This is the 'main' configuration file, it allows to specify parameters such as : logging (level and media) directories (config, data, runtime) API flag (on/off) prometheus (on/off) etc. Default configuration working_dir : /tmp/ data_dir : /var/lib/crowdsec/data config_dir : /etc/crowdsec/config pid_dir : /var/run log_dir : /var/log/ log_mode : file log_level : info profiling : false apimode : true daemon : true prometheus : true #for prometheus agent / golang debugging http_listen : 127.0.0.1:6060 plugin : backend : \"/etc/crowdsec/plugins/backend\"","title":"default.yaml"},{"location":"guide/crowdsec/overview/#working_dir","text":"The working directory where Prometheus will write metrics in text file.","title":"working_dir:"},{"location":"guide/crowdsec/overview/#data_dir","text":"Directory where {{v0X.crowdsec.Name}} will install its data ({{v0X.crowdsec.Name}} database for example).","title":"data_dir:"},{"location":"guide/crowdsec/overview/#pid_dir","text":"To specify where {{v0X.crowdsec.Name}} PID file will be stored.","title":"pid_dir:"},{"location":"guide/crowdsec/overview/#config_dir","text":"To specify where {{v0X.crowdsec.Name}} configuration will be stored.","title":"config_dir:"},{"location":"guide/crowdsec/overview/#log_dir","text":"To specify where the logs should be stored.","title":"log_dir:"},{"location":"guide/crowdsec/overview/#log_mode","text":"To specify your selected logging mode, available modes are : file : to write logs in a file stdout : to write logs in STDOUT","title":"log_mode:"},{"location":"guide/crowdsec/overview/#log_level","text":"To specify the logging level, available levels: debug info warning error","title":"log_level:"},{"location":"guide/crowdsec/overview/#profiling","text":"To enable or disable the profiling in {{v0X.crowdsec.Name}}.","title":"profiling:"},{"location":"guide/crowdsec/overview/#apimode","text":"To enable or disable signals sending to the {{v0X.api.htmlname}}.","title":"apimode:"},{"location":"guide/crowdsec/overview/#daemon","text":"To enable or disable {{v0X.crowdsec.Name}} daemon mode.","title":"daemon:"},{"location":"guide/crowdsec/overview/#prometheus","text":"To enable or disable Prometheus metrics.","title":"prometheus:"},{"location":"guide/crowdsec/overview/#prometheus_mode","text":"If prometheus is enabled, and is set to aggregated , will restrict prometheus metrics to global ones. All metrics containing a source as a label will be unregistered. Meant to keep cardinality low when relevant.","title":"prometheus_mode:"},{"location":"guide/crowdsec/overview/#http_listen","text":"To configure the Prometheus service listening address:port or {{v0X.crowdsec.Name}} profiling","title":"http_listen:"},{"location":"guide/crowdsec/overview/#plugin","text":"To specify the directories where {{v0X.ref.output}} plugins will be stored : * backend: : the path where all {{v0X.crowdsec.Name}} backend plugins (database output, ...) will be located.","title":"plugin:"},{"location":"guide/crowdsec/overview/#acquisyaml","text":"This is the file that tells which streams (or files) {{v0X.crowdsec.name}} is reading, and their types (so that it knows how to parse them). If you're lucky, this file should be auto-generated by the wizard. You can find details on the configuration file format here .","title":"acquis.yaml"},{"location":"guide/crowdsec/overview/#apiyaml","text":"Name is self-explanatory : it holds API configuration. This file should never be edited by a human : the wizard will deploy safe default for it, and {{v0X.cli.name}} will alter it on your behalf when you register or enroll your machine. You can look into it, and you should see : url endpoints login and password (auto-generated by your machine upon registration) To get new credentials : {{ v0X.cli.name }} api register Or if you loose your credentials: {{ v0X.cli.name }} api reset","title":"api.yaml"},{"location":"guide/crowdsec/overview/#profilesyaml","text":"The profiles is what allows you to decide how do you react when a scenario is triggered : do you notify yourself on mattermost/slack ? do you push the signal to a database so that your bouncers can stop the IP from continuing its attack ? do you want to avoid pushing this signal to the API ? Behind the scenes, the \"profiles\" system actually allows you to dispatch an event/overflow to various output plugins. You can find details on the configuration file format of {{v0X.ref.output}}.","title":"profiles.yaml"},{"location":"guide/crowdsec/overview/#parsers","text":"This directory holds all the {{v0X.parsers.htmlname}} that are enabled on your system. The parsers are organized in {{v0X.stage.htmlname}} (which are just folders) and the {{v0X.parsers.htmlname}} themselves are yaml files.","title":"parsers/"},{"location":"guide/crowdsec/overview/#scenarios","text":"This directory holds all the {{v0X.scenarios.htmlname}} that are enabled on your system. The {{v0X.scenarios.htmlname}} are yaml files.","title":"scenarios/"},{"location":"guide/crowdsec/parsers/","text":"Listing installed parsers \u00b6 {{v0X.parsers.Htmlname}} are yaml files in {{v0X.config.crowdsec_dir}}parsers/<STAGE>/parser.yaml . Info Alphabetical file order dictates the order of {{v0X.stage.htmlname}} and the orders of parsers within stage. You can use the following command to view installed parsers: {{v0X.cli.bin}} list parsers {{v0X.cli.name}} list example # {{v0X.cli.name}} list parsers INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers -------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------------- crowdsec/iptables-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/iptables-logs.yaml crowdsec/dateparse-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/dateparse-enrich.yaml crowdsec/sshd-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/sshd-logs.yaml crowdsec/whitelists \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/whitelists.yaml crowdsec/http-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/http-logs.yaml crowdsec/nginx-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml crowdsec/syslog-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml crowdsec/geoip-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/geoip-enrich.yaml -------------------------------------------------------------------------------------------------------------------- Installing parsers \u00b6 From the hub \u00b6 {{v0X.hub.htmlname}} allows you to find needed parsers. # {{v0X.cli.name}} install parser crowdsec/nginx-logs INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] crowdsec/nginx-logs : OK INFO [ 0000 ] Enabled parsers : crowdsec/nginx-logs INFO [ 0000 ] Enabled crowdsec/nginx-logs # systemctl reload crowdsec Your own parsers \u00b6 Write your parser configuration and deploy yaml file in {{v0X.config.crowdsec_dir}}parsers/<STAGE>/ . Monitoring parsers behavior \u00b6 {{v0X.cli.name}} allows you to view {{v0X.crowdsec.name}} metrics info via the metrics command. This allows you to see how many logs were ingested and then parsed or unparsed by said parser. You can see those metrics with the following command: cscli metrics {{v0X.cli.name}} metrics example # {{v0X.cli.name}} metrics ... INFO [ 0000 ] Parser Metrics: +---------------------------+--------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +---------------------------+--------+--------+----------+ | crowdsec/sshd-logs | 62424 | 12922 | 49502 | | crowdsec/syslog-logs | 667417 | 667417 | 0 | | crowdsec/whitelists | 610901 | 610901 | 0 | | crowdsec/http-logs | 136 | 21 | 115 | | crowdsec/iptables-logs | 597843 | 597843 | 0 | | crowdsec/nginx-logs | 137 | 136 | 1 | | crowdsec/dateparse-enrich | 610901 | 610901 | 0 | | crowdsec/geoip-enrich | 610836 | 610836 | 0 | | crowdsec/non-syslog | 137 | 137 | 0 | +---------------------------+--------+--------+----------+ Going further \u00b6 If you're interested into understanding how parsers are made or writing your own, please have a look at this page .","title":"Parsers"},{"location":"guide/crowdsec/parsers/#listing-installed-parsers","text":"{{v0X.parsers.Htmlname}} are yaml files in {{v0X.config.crowdsec_dir}}parsers/<STAGE>/parser.yaml . Info Alphabetical file order dictates the order of {{v0X.stage.htmlname}} and the orders of parsers within stage. You can use the following command to view installed parsers: {{v0X.cli.bin}} list parsers {{v0X.cli.name}} list example # {{v0X.cli.name}} list parsers INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers -------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH -------------------------------------------------------------------------------------------------------------------- crowdsec/iptables-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/iptables-logs.yaml crowdsec/dateparse-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/dateparse-enrich.yaml crowdsec/sshd-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/sshd-logs.yaml crowdsec/whitelists \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/whitelists.yaml crowdsec/http-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/http-logs.yaml crowdsec/nginx-logs \u2714\ufe0f enabled 0 .3 /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml crowdsec/syslog-logs \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml crowdsec/geoip-enrich \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/parsers/s02-enrich/geoip-enrich.yaml --------------------------------------------------------------------------------------------------------------------","title":"Listing installed parsers"},{"location":"guide/crowdsec/parsers/#installing-parsers","text":"","title":"Installing parsers"},{"location":"guide/crowdsec/parsers/#from-the-hub","text":"{{v0X.hub.htmlname}} allows you to find needed parsers. # {{v0X.cli.name}} install parser crowdsec/nginx-logs INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] crowdsec/nginx-logs : OK INFO [ 0000 ] Enabled parsers : crowdsec/nginx-logs INFO [ 0000 ] Enabled crowdsec/nginx-logs # systemctl reload crowdsec","title":"From the hub"},{"location":"guide/crowdsec/parsers/#your-own-parsers","text":"Write your parser configuration and deploy yaml file in {{v0X.config.crowdsec_dir}}parsers/<STAGE>/ .","title":"Your own parsers"},{"location":"guide/crowdsec/parsers/#monitoring-parsers-behavior","text":"{{v0X.cli.name}} allows you to view {{v0X.crowdsec.name}} metrics info via the metrics command. This allows you to see how many logs were ingested and then parsed or unparsed by said parser. You can see those metrics with the following command: cscli metrics {{v0X.cli.name}} metrics example # {{v0X.cli.name}} metrics ... INFO [ 0000 ] Parser Metrics: +---------------------------+--------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +---------------------------+--------+--------+----------+ | crowdsec/sshd-logs | 62424 | 12922 | 49502 | | crowdsec/syslog-logs | 667417 | 667417 | 0 | | crowdsec/whitelists | 610901 | 610901 | 0 | | crowdsec/http-logs | 136 | 21 | 115 | | crowdsec/iptables-logs | 597843 | 597843 | 0 | | crowdsec/nginx-logs | 137 | 136 | 1 | | crowdsec/dateparse-enrich | 610901 | 610901 | 0 | | crowdsec/geoip-enrich | 610836 | 610836 | 0 | | crowdsec/non-syslog | 137 | 137 | 0 | +---------------------------+--------+--------+----------+","title":"Monitoring parsers behavior"},{"location":"guide/crowdsec/parsers/#going-further","text":"If you're interested into understanding how parsers are made or writing your own, please have a look at this page .","title":"Going further"},{"location":"guide/crowdsec/scenarios/","text":"Scenarios are yaml files that define \"buckets\". Most of the scenarios currently rely on the leaky bucket concept. Scenarios lead to the instantiation, and sometime the overflow, of buckets. When a bucket \"overflows\", the scenario is considered as having been realized. This event leads to the creation of a new {{v0X.event.htmlname}} that describes the scenario that just happened (via a {{v0X.signal.htmlname}}). Listing installed scenarios \u00b6 scenarios are yaml files in {{v0X.config.crowdsec_dir}}scenarios/<scenario>.yaml . You can view installed scenarios with the following command: {{v0X.cli.bin}} list scenarios {{v0X.cli.name}} list example # {{v0X.cli.name}} list scenarios INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers ----------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ----------------------------------------------------------------------------------------------------------------------------- crowdsec/http-scan-uniques_404 \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-scan-uniques_404.yaml crowdsec/ssh-bf \u2714\ufe0f enabled 0 .8 /etc/crowdsec/config/scenarios/ssh-bf.yaml crowdsec/http-crawl-non_statics \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-crawl-non_statics.yaml crowdsec/iptables-scan-multi_ports \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/iptables-scan-multi_ports.yaml ----------------------------------------------------------------------------------------------------------------------------- Installing scenarios \u00b6 From the hub \u00b6 {{v0X.hub.htmlname}} allows you to find needed scenarios. # {{v0X.cli.name}} install scenario crowdsec/ssh-bf INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] crowdsec/ssh-bf : OK INFO [ 0000 ] Enabled scenarios : crowdsec/ssh-bf INFO [ 0000 ] Enabled crowdsec/ssh-bf # systemctl reload crowdsec Your own scenarios \u00b6 Write your scenario configuration and deploy yaml file in {{v0X.config.crowdsec_dir}}scenarios/<scenario.yaml> . Monitoring scenarios behavior \u00b6 {{v0X.cli.name}} allows you to view {{v0X.crowdsec.name}} metrics info via the metrics command. This allows you to see how many \"buckets\" associated to each scenario have been created (an event eligible from said scenario has arrived), poured (how many subsequent events have been pushed to said bucket), overflowed (the scenario happened) or underflow (there was not enough event to make the bucket overflow, and it thus expired after a while). You can see those metrics with the following command: {{v0X.cli.bin}} metrics {{v0X.cli.name}} metrics example # {{v0X.cli.name}} metrics INFO [ 0000 ] Buckets Metrics: +------------------------------------+-----------+--------------+--------+---------+ | BUCKET | OVERFLOWS | INSTANTIATED | POURED | EXPIRED | +------------------------------------+-----------+--------------+--------+---------+ | crowdsec/http-crawl-non_statics | - | 9 | 14 | 9 | | crowdsec/http-scan-uniques_404 | - | 11 | 14 | 11 | | crowdsec/iptables-scan-multi_ports | 13 | 125681 | 141601 | 125650 | | crowdsec/ssh-bf | 669 | 3721 | 12925 | 3046 | | crowdsec/ssh-bf_user-enum | 136 | 4093 | 7587 | 3956 | +------------------------------------+-----------+--------------+--------+---------+","title":"Scenarios"},{"location":"guide/crowdsec/scenarios/#listing-installed-scenarios","text":"scenarios are yaml files in {{v0X.config.crowdsec_dir}}scenarios/<scenario>.yaml . You can view installed scenarios with the following command: {{v0X.cli.bin}} list scenarios {{v0X.cli.name}} list example # {{v0X.cli.name}} list scenarios INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers ----------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ----------------------------------------------------------------------------------------------------------------------------- crowdsec/http-scan-uniques_404 \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-scan-uniques_404.yaml crowdsec/ssh-bf \u2714\ufe0f enabled 0 .8 /etc/crowdsec/config/scenarios/ssh-bf.yaml crowdsec/http-crawl-non_statics \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/http-crawl-non_statics.yaml crowdsec/iptables-scan-multi_ports \u2714\ufe0f enabled 0 .4 /etc/crowdsec/config/scenarios/iptables-scan-multi_ports.yaml -----------------------------------------------------------------------------------------------------------------------------","title":"Listing installed scenarios"},{"location":"guide/crowdsec/scenarios/#installing-scenarios","text":"","title":"Installing scenarios"},{"location":"guide/crowdsec/scenarios/#from-the-hub","text":"{{v0X.hub.htmlname}} allows you to find needed scenarios. # {{v0X.cli.name}} install scenario crowdsec/ssh-bf INFO [ 0000 ] Loaded 9 collecs, 14 parsers, 12 scenarios, 1 post-overflow parsers INFO [ 0000 ] crowdsec/ssh-bf : OK INFO [ 0000 ] Enabled scenarios : crowdsec/ssh-bf INFO [ 0000 ] Enabled crowdsec/ssh-bf # systemctl reload crowdsec","title":"From the hub"},{"location":"guide/crowdsec/scenarios/#your-own-scenarios","text":"Write your scenario configuration and deploy yaml file in {{v0X.config.crowdsec_dir}}scenarios/<scenario.yaml> .","title":"Your own scenarios"},{"location":"guide/crowdsec/scenarios/#monitoring-scenarios-behavior","text":"{{v0X.cli.name}} allows you to view {{v0X.crowdsec.name}} metrics info via the metrics command. This allows you to see how many \"buckets\" associated to each scenario have been created (an event eligible from said scenario has arrived), poured (how many subsequent events have been pushed to said bucket), overflowed (the scenario happened) or underflow (there was not enough event to make the bucket overflow, and it thus expired after a while). You can see those metrics with the following command: {{v0X.cli.bin}} metrics {{v0X.cli.name}} metrics example # {{v0X.cli.name}} metrics INFO [ 0000 ] Buckets Metrics: +------------------------------------+-----------+--------------+--------+---------+ | BUCKET | OVERFLOWS | INSTANTIATED | POURED | EXPIRED | +------------------------------------+-----------+--------------+--------+---------+ | crowdsec/http-crawl-non_statics | - | 9 | 14 | 9 | | crowdsec/http-scan-uniques_404 | - | 11 | 14 | 11 | | crowdsec/iptables-scan-multi_ports | 13 | 125681 | 141601 | 125650 | | crowdsec/ssh-bf | 669 | 3721 | 12925 | 3046 | | crowdsec/ssh-bf_user-enum | 136 | 4093 | 7587 | 3956 | +------------------------------------+-----------+--------------+--------+---------+","title":"Monitoring scenarios behavior"},{"location":"guide/crowdsec/simulation/","text":"You can tag some (or all) scenarios as being in simulation mode , which is especially useful if : You have one/multiple scenario that might trigger false positives : You can keep track of decisions while not applying automated counter-measures You want only specific scenarios to trigger counter-measures Simulation vs Whitelists Simulation and Whitelists are not to be mixed. Whitelists allows you to purely discard an overflow or a log, while simulation will only \"cancel\" the action against a peer, while keeping track of events and overflows. When this happens, the scenarios are still triggered, but the action is prefixed with simulation: , which means that bouncers won't take action against the peer(s) that triggered the scenario. Simulation can be managed with cscli simulation command, and allows you to have settings such as \"all in simulation except scenarios X,Y,Z\" or \"only scenarios X,Y,Z in simulation mode\" : cscli simulation enable : Globally enables simulation (all scenarios will be in simulation mode) cscli simulation enable author/my_scenario : Enables simulation only for a specific scenario $ cscli simulation enable crowdsecurity/http-probing INFO [ 0000 ] simulation mode for 'crowdsecurity/http-probing' enabled $ cscli simulation status INFO [ 0000 ] global simulation: disabled INFO [ 0000 ] Scenarios in simulation mode : INFO [ 0000 ] - crowdsecurity/http-probing $ tail -f /var/log/crowdsec.log ... WARN [ 21 -07-2020 11 :29:01 ] 127 .0.0.1 triggered a 4h0m0s ip simulation:ban remediation for [ crowdsecurity/http-probing ] bucket_id = restless-sound event_time = \"2020-07-21 11:29:01.817545253 +0200 CEST m=+3.794547062\" scenario = crowdsecurity/http-probing source_ip = 127 .0.0.1 $ cscliban list 1 local decisions: +--------+-----------+----------------------------+------+----------------+---------+----+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+-----------+----------------------------+------+----------------+---------+----+--------+------------+ | local | 127 .0.0.1 | crowdsecurity/http-probing | 2 | simulation:ban | | 0 | 22 | 3h59m24s | +--------+-----------+----------------------------+------+----------------+---------+----+--------+------------+ The simulation settings can be found in the simulation.yaml file of your configuration directory : #if simulation is false, exclusions are the only ones in learning, #if simulation is true, exclusions are the only ones *not* in learning simulation : false exclusions : - crowdsecurity/http-crawl-non_statics - crowdsecurity/http-probing","title":"Simulation Mode"},{"location":"observability/command_line/","text":"{{ v0X.cli.name }} metrics This command provides an overview of {{v0X.crowdsec.name}} statistics provided by prometheus client . By default it assumes that the {{v0X.crowdsec.name}} is installed on the same machine. The metrics are split in 3 main sections : Acquisition metrics : How many lines were read from which sources, how many were successfully or unsuccessfully parsed, and how many of those lines ultimately ended up being poured to a bucket. Parser metrics : How many lines were fed (eligible) to each parser, and how many of those were successfully or unsuccessfully parsed. Bucket metrics : How many time each scenario lead to a bucket instantiation, and for each of those : how many times it overflowed how many times it expired (underflows) how many subsequent events were poured to said bucket Hint These metrics should help you identify potential configuration errors. For example, if you have a source that has mostly unparsed logs, you know you might be missing some parsers. As well, if you have scenarios that are never instantiated, it might be a hint that they are not relevant to your configuration. {{v0X.cli.name}} metrics example INFO [ 0000 ] Buckets Metrics: +-----------------------------------------+-----------+--------------+--------+---------+ | BUCKET | OVERFLOWS | INSTANTIATED | POURED | EXPIRED | +-----------------------------------------+-----------+--------------+--------+---------+ | crowdsecurity/http-scan-uniques_404 | - | 8 | 9 | 8 | | crowdsecurity/iptables-scan-multi_ports | 1 | 8306 | 9097 | 8288 | | crowdsecurity/ssh-bf | 42 | 281 | 1434 | 238 | | crowdsecurity/ssh-bf_user-enum | 13 | 659 | 777 | 646 | | crowdsecurity/http-crawl-non_statics | - | 10 | 12 | 10 | +-----------------------------------------+-----------+--------------+--------+---------+ INFO [ 0000 ] Acquisition Metrics: +------------------------------------------+------------+--------------+----------------+------------------------+ | SOURCE | LINES READ | LINES PARSED | LINES UNPARSED | LINES POURED TO BUCKET | +------------------------------------------+------------+--------------+----------------+------------------------+ | /var/log/nginx/https.access.log | 25 | 25 | - | 7 | | /var/log/kern.log | 18078 | 18078 | - | 4066 | | /var/log/syslog | 18499 | 18078 | 421 | 5031 | | /var/log/auth.log | 6086 | 1434 | 4652 | 2211 | | /var/log/nginx/error.log | 170243 | 169632 | 611 | - | | /var/log/nginx/http.access.log | 44 | 44 | - | 14 | +------------------------------------------+------------+--------------+----------------+------------------------+ INFO [ 0000 ] Parser Metrics: +--------------------------------+--------+--------+----------+ | PARSERS | HITS | PARSED | UNPARSED | +--------------------------------+--------+--------+----------+ | crowdsecurity/geoip-enrich | 37659 | 37659 | 0 | | crowdsecurity/http-logs | 169701 | 27 | 169674 | | crowdsecurity/iptables-logs | 36156 | 36156 | 0 | | crowdsecurity/nginx-logs | 170316 | 169701 | 615 | | crowdsecurity/non-syslog | 170312 | 170312 | 0 | | crowdsecurity/sshd-logs | 6053 | 1434 | 4619 | | crowdsecurity/syslog-logs | 42663 | 42663 | 0 | | crowdsecurity/dateparse-enrich | 207291 | 207291 | 0 | +--------------------------------+--------+--------+----------+","title":"Command line"},{"location":"observability/dashboard/","text":"SQLite & MySQL The default database of {{v0X.crowdsec.Name}} is SQLite. While MySQL is supported as well (>= 0.3.0), it is not in the scope of this documentation. The {{v0X.cli.name}} command {{v0X.cli.bin}} dashboard setup will use docker to install metabase docker image and fetch our metabase template to have a configured and ready dashboard. Deployment \u00b6 The metabase dashboard can be setup with : {{ v0X.cli.bin }} dashboard setup --listen and --port options allow you to control on which address / port will the docker be binded. {{v0X.cli.name}} dashboard setup output INFO [ 0000 ] /var/lib/crowdsec/data/metabase.db exists, skip. INFO [ 0000 ] Downloaded metabase DB INFO [ 0000 ] Pulling docker image metabase/metabase ... INFO [ 0001 ] Creating container INFO [ 0001 ] Starting container INFO [ 0002 ] Started metabase INFO [ 0002 ] Waiting for metabase API to be up ( can take up to a minute ) ........... INFO [ 0034 ] Metabase API is up INFO [ 0034 ] Successfully authenticated INFO [ 0034 ] Changed password ! INFO [ 0034 ] Setup finished INFO [ 0034 ] url : http://127.0.0.1:3000 INFO [ 0034 ] username: metabase@crowdsec.net INFO [ 0034 ] password: W1XJb8iw1A02U5nW7xxxxXXXxxXXXxXXxxXXXxxxXxXxXxXPdbvQdLlshqqPg8pf Protip the dashboard setup command will output generated credentials for metabase. Don't forget to save those ! Now you can connect to your dashboard, sign-in with your saved credentials then click on {{v0X.crowdsec.Name}} Dashboard to get this: Dashboard docker image can be managed by {{v0X.cli.name}} and docker cli also. Look at the {{v0X.cli.name}} help command using {{ v0X.cli.bin }} dashboard -h","title":"Dashboard"},{"location":"observability/dashboard/#deployment","text":"The metabase dashboard can be setup with : {{ v0X.cli.bin }} dashboard setup --listen and --port options allow you to control on which address / port will the docker be binded. {{v0X.cli.name}} dashboard setup output INFO [ 0000 ] /var/lib/crowdsec/data/metabase.db exists, skip. INFO [ 0000 ] Downloaded metabase DB INFO [ 0000 ] Pulling docker image metabase/metabase ... INFO [ 0001 ] Creating container INFO [ 0001 ] Starting container INFO [ 0002 ] Started metabase INFO [ 0002 ] Waiting for metabase API to be up ( can take up to a minute ) ........... INFO [ 0034 ] Metabase API is up INFO [ 0034 ] Successfully authenticated INFO [ 0034 ] Changed password ! INFO [ 0034 ] Setup finished INFO [ 0034 ] url : http://127.0.0.1:3000 INFO [ 0034 ] username: metabase@crowdsec.net INFO [ 0034 ] password: W1XJb8iw1A02U5nW7xxxxXXXxxXXXxXXxxXXXxxxXxXxXxXPdbvQdLlshqqPg8pf Protip the dashboard setup command will output generated credentials for metabase. Don't forget to save those ! Now you can connect to your dashboard, sign-in with your saved credentials then click on {{v0X.crowdsec.Name}} Dashboard to get this: Dashboard docker image can be managed by {{v0X.cli.name}} and docker cli also. Look at the {{v0X.cli.name}} help command using {{ v0X.cli.bin }} dashboard -h","title":"Deployment"},{"location":"observability/logs/","text":"Logs concern everything that happens to {{v0X.crowdsec.Name}} itself (startup, configuration, events like IP ban or an alert, shutdown, and so on). By default, logs are written to {{v0X.crowdsec.main_log}} , in text format. Logs example time = \"12-05-2020 15:34:21\" level = info msg = \"setting loglevel to info\" time = \"12-05-2020 15:34:21\" level = info msg = \"Crowdsec v0.0.19-9ae496aa9cfd008513976a096accc7cfc43f2d9b\" time = \"12-05-2020 15:34:21\" level = warning msg = \"Loading prometheus collectors\" time = \"12-05-2020 15:34:23\" level = warning msg = \"no version in /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml, assuming '1.0'\" time = \"12-05-2020 15:34:23\" level = warning msg = \"Starting profiling and http server\" time = \"12-05-2020 15:34:24\" level = warning msg = \"no version in /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml, assuming '1.0'\" time = \"12-05-2020 15:34:24\" level = info msg = \"Node has no name,author or description. Skipping.\" time = \"12-05-2020 15:34:24\" level = info msg = \"Loading 2 parser nodes\" file = /etc/crowdsec/config/parsers/s00-raw/syslog-logs.yaml time = \"12-05-2020 15:34:24\" level = warning msg = \"no version in /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml, assuming '1.0'\" time = \"12-05-2020 15:34:24\" level = info msg = \"Loading 3 parser nodes\" file = /etc/crowdsec/config/parsers/s01-parse/nginx-logs.yaml time = \"12-05-2020 15:34:24\" level = warning msg = \"no version in /etc/crowdsec/config/parsers/s01-parse/sshd-logs.yaml, assuming '1.0'\" time = \"13-05-2020 17:42:53\" level = warning msg = \"24 existing LeakyRoutine\" time = \"13-05-2020 18:02:51\" level = info msg = \"Flushed 1 expired entries from Ban Application\" time = \"13-05-2020 18:12:46\" level = info msg = \"Flushed 1 expired entries from Ban Application\" time = \"13-05-2020 18:20:29\" level = warning msg = \"11.11.11.11 triggered a 4h0m0s ip ban remediation for [crowdsecurity/ssh-bf]\" bucket_id = winter-shadow event_time = \"2020-05-13 18:20:29.855776892 +0200 CEST m=+96112.558589990\" scenario = crowdsecurity/ssh-bf source_ip = 11 .11.11.11 time = \"13-05-2020 18:31:26\" level = warning msg = \"22.22.22.22 triggered a 4h0m0s ip ban remediation for [crowdsecurity/ssh-bf]\" bucket_id = dry-mountain event_time = \"2020-05-13 18:31:26.989769738 +0200 CEST m=+96769.692582872\" scenario = crowdsecurity/ssh-bf source_ip = 22 .22.22.22 time = \"13-05-2020 18:41:10\" level = warning msg = \"16 existing LeakyRoutine\" time = \"13-05-2020 18:46:19\" level = warning msg = \"33.33.33.33 triggered a 4h0m0s ip ban remediation for [crowdsecurity/iptables-scan-multi_ports]\" bucket_id = holy-paper event_time = \"2020-05-13 18:46:19.825693323 +0200 CEST m=+97662.528506421\" scenario = crowdsecurity/iptables-scan-multi_ports source_ip = 33 .33.33.33","title":"Logs"},{"location":"observability/overview/","text":"Observability Overview \u00b6 Observability in security software is crucial, especially when this software might take important decision such as blocking IP addresses. We attempt to provide good observability of {{v0X.crowdsec.name}}'s behavior : {{v0X.crowdsec.name}} itself exposes a prometheus instrumentation {{v0X.cli.Name}} allows you to view part of prometheus metrics in cli ( {{v0X.cli.bin}} metrics ) {{v0X.crowdsec.name}} logging is contextualized for easy processing for humans , {{v0X.cli.name}} allows you to trivially start a service exposing dashboards (using metabase ) Furthermore, most of {{v0X.crowdsec.name}} configuration should allow you to enable partial debug (ie. per-scenario, per-parser etc.)","title":"Overview"},{"location":"observability/overview/#observability-overview","text":"Observability in security software is crucial, especially when this software might take important decision such as blocking IP addresses. We attempt to provide good observability of {{v0X.crowdsec.name}}'s behavior : {{v0X.crowdsec.name}} itself exposes a prometheus instrumentation {{v0X.cli.Name}} allows you to view part of prometheus metrics in cli ( {{v0X.cli.bin}} metrics ) {{v0X.crowdsec.name}} logging is contextualized for easy processing for humans , {{v0X.cli.name}} allows you to trivially start a service exposing dashboards (using metabase ) Furthermore, most of {{v0X.crowdsec.name}} configuration should allow you to enable partial debug (ie. per-scenario, per-parser etc.)","title":"Observability Overview"},{"location":"observability/prometheus/","text":"{{v0X.crowdsec.name}} can expose a {{v0X.prometheus.htmlname}} endpoint for collection (on http://127.0.0.1:6060/metrics by default). The goal of this endpoint, besides the usual resources consumption monitoring, aims at offering a view of {{v0X.crowdsec.name}} \"applicative\" behavior : is it processing a lot of logs ? is it parsing them successfully ? are a lot of scenarios being triggered ? are a lot of IPs banned ? etc. All the counters are \"since {{v0X.crowdsec.name}} start\". Metrics details \u00b6 Scenarios \u00b6 cs_buckets : number of scenario that currently exist cs_bucket_created_total : total number of instantiation of each scenario cs_bucket_overflowed_total : total number of overflow of each scenario cs_bucket_underflowed_total : total number of underflow of each scenario (bucket was created but expired because of lack of events) cs_bucket_poured_total : total number of event poured to each scenario with source as complementary key example #2030 lines from `/var/log/nginx/access.log` were poured to `crowdsecurity/http-scan-uniques_404` scenario cs_bucket_poured_total{name=\"crowdsecurity/http-scan-uniques_404\",source=\"/var/log/nginx/access.log\"} 2030 Parsers \u00b6 cs_node_hits_total : how many time an event from a specific source was processed by a parser node : example # 235 lines from `auth.log` were processed by the `crowdsecurity/dateparse-enrich` parser cs_node_hits_total{name=\"crowdsecurity/dateparse-enrich\",source=\"/var/log/auth.log\"} 235 cs_node_hits_ko_total : how many times an event from a specific was unsuccessfully parsed by a specific parser example # 2112 lines from `error.log` failed to be parsed by `crowdsecurity/http-logs` cs_node_hits_ko_total{name=\"crowdsecurity/http-logs\",source=\"/var/log/nginx/error.log\"} 2112 cs_node_hits_ok_total : how many times an event from a specific source was successfully parsed by a specific parser cs_parser_hits_total : how many times an event from a source has hit the parser cs_parser_hits_ok_total : how many times an event from a source was successfully parsed cs_parser_hits_ko_total : how many times an event from a source was unsuccessfully parsed Acquisition \u00b6 cs_reader_hits_total : how many events were read from a specific source Info \u00b6 cs_info : Information about {{v0X.crowdsec.name}} (software version) Exploitation with prometheus server & grafana \u00b6 Those metrics can be scaped by prometheus server and visualized with grafana . They can be downloaded here :","title":"Prometheus"},{"location":"observability/prometheus/#metrics-details","text":"","title":"Metrics details"},{"location":"observability/prometheus/#scenarios","text":"cs_buckets : number of scenario that currently exist cs_bucket_created_total : total number of instantiation of each scenario cs_bucket_overflowed_total : total number of overflow of each scenario cs_bucket_underflowed_total : total number of underflow of each scenario (bucket was created but expired because of lack of events) cs_bucket_poured_total : total number of event poured to each scenario with source as complementary key example #2030 lines from `/var/log/nginx/access.log` were poured to `crowdsecurity/http-scan-uniques_404` scenario cs_bucket_poured_total{name=\"crowdsecurity/http-scan-uniques_404\",source=\"/var/log/nginx/access.log\"} 2030","title":"Scenarios"},{"location":"observability/prometheus/#parsers","text":"cs_node_hits_total : how many time an event from a specific source was processed by a parser node : example # 235 lines from `auth.log` were processed by the `crowdsecurity/dateparse-enrich` parser cs_node_hits_total{name=\"crowdsecurity/dateparse-enrich\",source=\"/var/log/auth.log\"} 235 cs_node_hits_ko_total : how many times an event from a specific was unsuccessfully parsed by a specific parser example # 2112 lines from `error.log` failed to be parsed by `crowdsecurity/http-logs` cs_node_hits_ko_total{name=\"crowdsecurity/http-logs\",source=\"/var/log/nginx/error.log\"} 2112 cs_node_hits_ok_total : how many times an event from a specific source was successfully parsed by a specific parser cs_parser_hits_total : how many times an event from a source has hit the parser cs_parser_hits_ok_total : how many times an event from a source was successfully parsed cs_parser_hits_ko_total : how many times an event from a source was unsuccessfully parsed","title":"Parsers"},{"location":"observability/prometheus/#acquisition","text":"cs_reader_hits_total : how many events were read from a specific source","title":"Acquisition"},{"location":"observability/prometheus/#info","text":"cs_info : Information about {{v0X.crowdsec.name}} (software version)","title":"Info"},{"location":"observability/prometheus/#exploitation-with-prometheus-server-grafana","text":"Those metrics can be scaped by prometheus server and visualized with grafana . They can be downloaded here :","title":"Exploitation with prometheus server &amp; grafana"},{"location":"references/output/","text":"Output \u00b6 The output mechanism is composed of plugins. In order to store the bans for {{v0X.bouncers.htmlname}}, at least one backend plugin must be loaded. Else, bans will not be stored and decisions cannot be applied. Currently the supported backends are SQLite (default) and MySQL. In order to filter which signals will be sent to which plugin, {{v0X.crowdsec.name}} use a system of profile that can allow to granularly process your bans and signals. Profile \u00b6 Here is a sample of a profile configuration: profile : <profile_name> filter : \"<filter_expression>\" api : true # default true : send signal to crowdsec API outputs : # here choose your output plugins for this profile - plugin : plugin1 custom_config : <config> - plugin : plugin2 The default configuration that is deployed with {{v0X.crowdsec.name}} is the following one: profile : default_remediation filter : \"sig.Labels.remediation == 'true'\" api : true # If no api: specified, will use the default config in default.yaml remediation : ban : true slow : true captcha : true duration : 4h outputs : - plugin : database --- profile : default_notification filter : \"sig.Labels.remediation != 'true'\" #remediation is empty, it means non taken api : false outputs : - plugin : database # If we do not want to push, we can remove this line and the next one store : false Here we can use {{v0X.filter.htmlname}} like in parsers and scenarios with the {{v0X.signal.htmlname}} object to choose which signal will be process by which plugin. Backend database configuration \u00b6 The /etc/crowdsec/plugins/backend/database.yaml file allows you to configure to which backend database you'd like to write. {{v0X.crowdsec.Name}} support SQLite and MySQL via gorm . name : database path : /usr/local/lib/crowdsec/plugins/backend/database.so config : ## DB type supported (mysql, sqlite) ## By default it using sqlite type : sqlite ## mysql options # db_host: localhost # db_username: crowdsec # db_password: password # db_name: crowdsec ## sqlite options db_path : /var/lib/crowdsec/data/crowdsec.db ## Other options flush : true # debug: true SQLite \u00b6 SQLite is the default backend database, so you don't have to touch anything. MySQL \u00b6 If you want to use MySQL as a backend database (which is suitable to distributed architectures), you need to have root privileges (ie. mysql -u root -p ) on you MySQL database to type the following commands : #create the database for crowdsec CREATE database crowdsec #create the dedicated user CREATE USER 'crowdsec' @ 'localhost' IDENTIFIED BY 'verybadpassword' ; #grant the privileges GRANT ALL PRIVILEGES ON crowdsec.* TO 'crowdsec' @ 'localhost' ; #allow backward compatibility for mysql >= 5.7 SET GLOBAL sql_mode =( SELECT REPLACE ( @@sql_mode, 'ONLY_FULL_GROUP_BY' , '' )) ; Then, configure accordingly your /etc/crowdsec/plugins/backend/database.yaml : name : database path : /usr/local/lib/crowdsec/plugins/backend/database.so config : ## DB type supported (mysql, sqlite) ## By default it using sqlite type : mysql ## mysql options db_host : localhost db_username : crowdsec db_password : verybadpassword db_name : crowdsec ## sqlite options #db_path: /var/lib/crowdsec/data/crowdsec.db ## Other options flush : true # debug: true Plugins \u00b6 Plugins configuration file are stored in {{v0X.plugins.configpath}} . {{v0X.crowdsec.Name}} will scan this folder to load all the plugins. Each configuration file should provide the path to the plugin binary. By default they are stored in {{v0X.plugins.binpath}} . Info If you want crowdsec to not load a plugin, mv or rm its configuration file in {{v0X.plugins.configpath}} Here is a sample of a plugin configuration file stored in {{v0X.plugins.configpath}} : name : <plugin_name> path : <path_to_plugin_binary> # config : <plugin_config> # in a form of key(string)/value(string) For the plugin database, here is its configuration file: name : database path : /usr/local/lib/crowdsec/plugins/backend/database.so config : db_path : /var/lib/crowdsec/data/crowdsec.db flush : true","title":"Outputs format"},{"location":"references/output/#output","text":"The output mechanism is composed of plugins. In order to store the bans for {{v0X.bouncers.htmlname}}, at least one backend plugin must be loaded. Else, bans will not be stored and decisions cannot be applied. Currently the supported backends are SQLite (default) and MySQL. In order to filter which signals will be sent to which plugin, {{v0X.crowdsec.name}} use a system of profile that can allow to granularly process your bans and signals.","title":"Output"},{"location":"references/output/#profile","text":"Here is a sample of a profile configuration: profile : <profile_name> filter : \"<filter_expression>\" api : true # default true : send signal to crowdsec API outputs : # here choose your output plugins for this profile - plugin : plugin1 custom_config : <config> - plugin : plugin2 The default configuration that is deployed with {{v0X.crowdsec.name}} is the following one: profile : default_remediation filter : \"sig.Labels.remediation == 'true'\" api : true # If no api: specified, will use the default config in default.yaml remediation : ban : true slow : true captcha : true duration : 4h outputs : - plugin : database --- profile : default_notification filter : \"sig.Labels.remediation != 'true'\" #remediation is empty, it means non taken api : false outputs : - plugin : database # If we do not want to push, we can remove this line and the next one store : false Here we can use {{v0X.filter.htmlname}} like in parsers and scenarios with the {{v0X.signal.htmlname}} object to choose which signal will be process by which plugin.","title":"Profile"},{"location":"references/output/#backend-database-configuration","text":"The /etc/crowdsec/plugins/backend/database.yaml file allows you to configure to which backend database you'd like to write. {{v0X.crowdsec.Name}} support SQLite and MySQL via gorm . name : database path : /usr/local/lib/crowdsec/plugins/backend/database.so config : ## DB type supported (mysql, sqlite) ## By default it using sqlite type : sqlite ## mysql options # db_host: localhost # db_username: crowdsec # db_password: password # db_name: crowdsec ## sqlite options db_path : /var/lib/crowdsec/data/crowdsec.db ## Other options flush : true # debug: true","title":"Backend database configuration"},{"location":"references/output/#sqlite","text":"SQLite is the default backend database, so you don't have to touch anything.","title":"SQLite"},{"location":"references/output/#mysql","text":"If you want to use MySQL as a backend database (which is suitable to distributed architectures), you need to have root privileges (ie. mysql -u root -p ) on you MySQL database to type the following commands : #create the database for crowdsec CREATE database crowdsec #create the dedicated user CREATE USER 'crowdsec' @ 'localhost' IDENTIFIED BY 'verybadpassword' ; #grant the privileges GRANT ALL PRIVILEGES ON crowdsec.* TO 'crowdsec' @ 'localhost' ; #allow backward compatibility for mysql >= 5.7 SET GLOBAL sql_mode =( SELECT REPLACE ( @@sql_mode, 'ONLY_FULL_GROUP_BY' , '' )) ; Then, configure accordingly your /etc/crowdsec/plugins/backend/database.yaml : name : database path : /usr/local/lib/crowdsec/plugins/backend/database.so config : ## DB type supported (mysql, sqlite) ## By default it using sqlite type : mysql ## mysql options db_host : localhost db_username : crowdsec db_password : verybadpassword db_name : crowdsec ## sqlite options #db_path: /var/lib/crowdsec/data/crowdsec.db ## Other options flush : true # debug: true","title":"MySQL"},{"location":"references/output/#plugins","text":"Plugins configuration file are stored in {{v0X.plugins.configpath}} . {{v0X.crowdsec.Name}} will scan this folder to load all the plugins. Each configuration file should provide the path to the plugin binary. By default they are stored in {{v0X.plugins.binpath}} . Info If you want crowdsec to not load a plugin, mv or rm its configuration file in {{v0X.plugins.configpath}} Here is a sample of a plugin configuration file stored in {{v0X.plugins.configpath}} : name : <plugin_name> path : <path_to_plugin_binary> # config : <plugin_config> # in a form of key(string)/value(string) For the plugin database, here is its configuration file: name : database path : /usr/local/lib/crowdsec/plugins/backend/database.so config : db_path : /var/lib/crowdsec/data/crowdsec.db flush : true","title":"Plugins"},{"location":"references/parsers/","text":"Understanding parsers \u00b6 A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing, or use specific {{v0X.expr.htmlname}} feature to perform parsing on specific data, such as JSON. Parsers are organized into stages to allow pipelines and branching in parsing. See the {{v0X.hub.name}} to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing Stages \u00b6 Stages concept is central to data parsing in {{v0X.crowdsec.name}}, as it allows to have various \"steps\" of parsing. All parsers belong to a given stage. While users can add or modify the stages order, the following stages exist : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Thus a sshd log might follow this pipeline : s00-raw : be parsed by crowdsecurity/syslog-logs (will move event to the next stage) s01-raw : be parsed by crowdsecurity/sshd-logs (will move event to the next stage) s02-enrich : will be parsed by crowdsecurity/geoip-enrich and crowdsecurity/dateparse-enrich Parser configuration format \u00b6 A parser node might look like : #if 'onsuccess' is 'next_stage', the event will make it to next stage if this node succeed onsuccess : next_stage #a 'debug' (bool) flag allow to enable node level debug in any node to enable local debug debug : true #a filter to decide if the Event is elligible for this parser node filter : \"evt.Parsed.program == 'kernel'\" #a unique name to allow easy debug & logging name : crowdsecurity/demo-iptables #this is for humans description : \"Parse iptables drop logs\" #we can define named capture groups (a-la-grok) pattern_syntax : MYCAP : \".*\" #an actual grok pattern (regular expression with named capture groupe) grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ #we define on which field the regular expression must be applied apply_on : evt.Parsed.some_field #statics are transformations that are applied on the event if the node is considered \"successfull\" statics : - parsed : something expression : JsonExtract(evt.Event.extracted_value, \"nested.an_array[0]\") #to which field the value will be written (here -> evt.Meta.log_type) - meta : log_type #and here a static value value : parsed_testlog #another one - meta : source_ip #here the value stored is the result of a dynamic expression expression : \"evt.Parsed.src_ip\" The parser nodes are processed sequentially based on the alphabetical order of {{v0X.stage.htmlname}} and subsequent files. If the node is considered successful (grok is present and returned data or no grok is present) and \"onsuccess\" equals to next_stage , then the {{v0X.event.name}} is moved to the next stage. Parser trees \u00b6 A parser node can contain sub-nodes, to provide proper branching (on top of stages). It can be useful when you want to apply different parsing based on different criterias, or when you have a set of candidates parsers that you want to apply to an event : #This first node will capture/extract some value filter : \"evt.Line.Labels.type == 'type1'\" name : tests/base-grok-root pattern_syntax : MYCAP : \".*\" grok : pattern : ^... %{MYCAP:extracted_value} ...$ apply_on : Line.Raw statics : - meta : state value : root-done - meta : state_sub expression : evt.Parsed.extracted_value --- #and this node will apply different patterns to it filter : \"evt.Line.Labels.type == 'type1' && evt.Meta.state == 'root-done'\" name : tests/base-grok-leafs onsuccess : next_stage #the sub-nodes will process the result of the master node nodes : - filter : \"evt.Parsed.extracted_value == 'VALUE1'\" debug : true statics : - meta : final_state value : leaf1 - filter : \"evt.Parsed.extracted_value == 'VALUE2'\" debug : true statics : - meta : final_state value : leaf2 The logic is that the tests/base-grok-root node will be processed first and will alter the event (here mostly by extracting some text from the Line.Raw field into Parsed thanks to the grok pattern and the statics directive). The event will then continue its life and be parsed by the the following tests/base-grok-leafs node. This node has onsuccess set to next_stage which means that if the node is successful, the event will be moved to the next stage. This node consists actually of two sub-nodes that have different conditions (branching) to allow differential treatment of said event. A real-life example can be seen when it comes to parsing HTTP logs. HTTP ACCESS and ERROR logs often have different formats, and thus our \"nginx\" parser needs to handle both formats filter : \"evt.Parsed.program == 'nginx'\" onsuccess : next_stage name : crowdsecurity/nginx-logs nodes : - grok : #this is the access log name : NGINXACCESS apply_on : message statics : - meta : log_type value : http_access-log - target : evt.StrTime expression : evt.Parsed.time_local - grok : # and this one the error log name : NGINXERROR apply_on : message statics : - meta : log_type value : http_error-log - target : evt.StrTime expression : evt.Parsed.time # these ones apply for both grok patterns statics : - meta : service value : http - meta : source_ip expression : \"evt.Parsed.remote_addr\" - meta : http_status expression : \"evt.Parsed.status\" - meta : http_path expression : \"evt.Parsed.request\" Parser directives \u00b6 debug \u00b6 debug : true|false default: false If set to to true , enabled node level debugging. It is meant to help understanding parser node behavior by providing contextual logging : assignments made by statics DEBU[31-07-2020 16:36:28] + Processing 4 statics id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[service] = 'http' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[source_ip] = '127.0.0.1' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_status] = '200' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_path] = '/' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse assignments made by grok pattern DEBU[31-07-2020 16:36:28] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['time_local'] = '21/Jul/2020:16:13:05 +0200' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['method'] = 'GET' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['request'] = '/' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['http_user_agent'] = 'curl/7.58.0' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['remote_addr'] = '127.0.0.1' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse debug of filters and expression results DEBU[31-07-2020 16:36:28] eval(evt.Parsed.program == 'nginx') = TRUE id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] eval variables: id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] evt.Parsed.program = 'nginx' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse filter \u00b6 filter : expression filter must be a valid {{v0X.expr.htmlname}} expression that will be evaluated against the {{v0X.event.htmlname}}. If filter evaluation returns true or is absent, node will be processed. If filter returns false or a non-boolean, node won't be processed. Here is the expr documentation . Examples : filter: \"evt.Meta.foo == 'test'\" filter: \"evt.Meta.bar == 'test' && evt.Meta.foo == 'test2' grok \u00b6 grok : name : NAMED_EXISTING_PATTERN apply_on : source_field grok : pattern : ^a valid RE2 expression with %{CAPTURE:field}$ apply_on : source_field The grok structure in a node represent a regular expression with capture group (grok pattern) that must be applied on a field of {{v0X.event.name}}. The pattern can : be imported by name (if present within the core of {{v0X.crowdsec.name}}) defined in place In both case, the pattern must be a valid RE2 expression. The field(s) returned by the regular expression are going to be merged into the Parsed associative array of the Event . name \u00b6 name : explicit_string The mandatory name of the node. If not present, node will be skipped at runtime. It is used for example in debug log to help you track things. nodes \u00b6 nodes : - filter : ... grok : ... nodes is a list of parser nodes, allowing you to build trees. Each subnode must be valid, and if any of the subnodes succeed, the whole node is considered successful. onsuccess \u00b6 onsuccess: next_stage|continue default: continue if set to next_stage and the node is considered successful, the {{v0X.event.name}} will be moved directly to next stage without processing other nodes in the current stage. pattern_syntax \u00b6 pattern_syntax : CAPTURE_NAME : VALID_RE2_EXPRESSION pattern_syntax allows user to define named capture group expressions for future use in grok patterns. Regexp must be a valid RE2 expression. pattern_syntax : MYCAP : \".*\" grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ apply_on : Line.Raw statics \u00b6 statics : - target : evt.Meta.target_field value : static_value - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression' - enriched : target_field value : static_value statics is a list of directives that will be executed when the node is considered successful. Each entry of the list is composed of a target (where to write) and a source (what data to write). Target The target aims at being any part of the {{v0X.event.htmlname}} object, and can be expressed in different ways : - `meta: <target_field>` - `parsed: <target_field>` - `enriched: <target_field>` - a dynamic target (please note that the **current** event is accessible via the `evt.` variable) : - `target: evt.Meta.foobar` - `target: Meta.foobar` - `target: evt.StrTime` Source The source itself can be either a static value, or an {{v0X.expr.htmlname}} result : statics : - meta : target_field value : static_value - meta : target_field expression : evt.Meta.another_field - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression' data \u00b6 data: - source_url: https://URL/TO/FILE dest_file: LOCAL_FILENAME [type: (regexp|string)] data allows user to specify an external source of data. This section is only relevant when cscli is used to install parser from hub, as it will download the source_url and store it to dest_file . When the parser is not installed from the hub, {{v0X.crowdsec.name}} won't download the URL, but the file must exist for the parser to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string Parser concepts \u00b6 Success and failure \u00b6 A parser is considered \"successful\" if : A grok pattern was present and successfully matched No grok pattern was present","title":"Parsers format"},{"location":"references/parsers/#understanding-parsers","text":"A parser is a YAML configuration file that describes how a string is being parsed. Said string can be a log line, or a field extracted from a previous parser. While a lot of parsers rely on the GROK approach (a.k.a regular expression named capture groups), parsers can as well reference enrichment modules to allow specific data processing, or use specific {{v0X.expr.htmlname}} feature to perform parsing on specific data, such as JSON. Parsers are organized into stages to allow pipelines and branching in parsing. See the {{v0X.hub.name}} to explore parsers, or see below some examples : apache2 access/error log parser iptables logs parser http logs post-processing","title":"Understanding parsers"},{"location":"references/parsers/#stages","text":"Stages concept is central to data parsing in {{v0X.crowdsec.name}}, as it allows to have various \"steps\" of parsing. All parsers belong to a given stage. While users can add or modify the stages order, the following stages exist : s00-raw : low level parser, such as syslog s01-parse : most of the services parsers (ssh, nginx etc.) s02-enrich : enrichment that requires parsed events (ie. geoip-enrichment) or generic parsers that apply on parsed logs (ie. second stage http parser) Every event starts in the first stage, and will move to the next stage once it has been successfully processed by a parser that has the onsuccess directive set to next_stage , and so on until it reaches the last stage, when it's going to start to be matched against scenarios. Thus a sshd log might follow this pipeline : s00-raw : be parsed by crowdsecurity/syslog-logs (will move event to the next stage) s01-raw : be parsed by crowdsecurity/sshd-logs (will move event to the next stage) s02-enrich : will be parsed by crowdsecurity/geoip-enrich and crowdsecurity/dateparse-enrich","title":"Stages"},{"location":"references/parsers/#parser-configuration-format","text":"A parser node might look like : #if 'onsuccess' is 'next_stage', the event will make it to next stage if this node succeed onsuccess : next_stage #a 'debug' (bool) flag allow to enable node level debug in any node to enable local debug debug : true #a filter to decide if the Event is elligible for this parser node filter : \"evt.Parsed.program == 'kernel'\" #a unique name to allow easy debug & logging name : crowdsecurity/demo-iptables #this is for humans description : \"Parse iptables drop logs\" #we can define named capture groups (a-la-grok) pattern_syntax : MYCAP : \".*\" #an actual grok pattern (regular expression with named capture groupe) grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ #we define on which field the regular expression must be applied apply_on : evt.Parsed.some_field #statics are transformations that are applied on the event if the node is considered \"successfull\" statics : - parsed : something expression : JsonExtract(evt.Event.extracted_value, \"nested.an_array[0]\") #to which field the value will be written (here -> evt.Meta.log_type) - meta : log_type #and here a static value value : parsed_testlog #another one - meta : source_ip #here the value stored is the result of a dynamic expression expression : \"evt.Parsed.src_ip\" The parser nodes are processed sequentially based on the alphabetical order of {{v0X.stage.htmlname}} and subsequent files. If the node is considered successful (grok is present and returned data or no grok is present) and \"onsuccess\" equals to next_stage , then the {{v0X.event.name}} is moved to the next stage.","title":"Parser configuration format"},{"location":"references/parsers/#parser-trees","text":"A parser node can contain sub-nodes, to provide proper branching (on top of stages). It can be useful when you want to apply different parsing based on different criterias, or when you have a set of candidates parsers that you want to apply to an event : #This first node will capture/extract some value filter : \"evt.Line.Labels.type == 'type1'\" name : tests/base-grok-root pattern_syntax : MYCAP : \".*\" grok : pattern : ^... %{MYCAP:extracted_value} ...$ apply_on : Line.Raw statics : - meta : state value : root-done - meta : state_sub expression : evt.Parsed.extracted_value --- #and this node will apply different patterns to it filter : \"evt.Line.Labels.type == 'type1' && evt.Meta.state == 'root-done'\" name : tests/base-grok-leafs onsuccess : next_stage #the sub-nodes will process the result of the master node nodes : - filter : \"evt.Parsed.extracted_value == 'VALUE1'\" debug : true statics : - meta : final_state value : leaf1 - filter : \"evt.Parsed.extracted_value == 'VALUE2'\" debug : true statics : - meta : final_state value : leaf2 The logic is that the tests/base-grok-root node will be processed first and will alter the event (here mostly by extracting some text from the Line.Raw field into Parsed thanks to the grok pattern and the statics directive). The event will then continue its life and be parsed by the the following tests/base-grok-leafs node. This node has onsuccess set to next_stage which means that if the node is successful, the event will be moved to the next stage. This node consists actually of two sub-nodes that have different conditions (branching) to allow differential treatment of said event. A real-life example can be seen when it comes to parsing HTTP logs. HTTP ACCESS and ERROR logs often have different formats, and thus our \"nginx\" parser needs to handle both formats filter : \"evt.Parsed.program == 'nginx'\" onsuccess : next_stage name : crowdsecurity/nginx-logs nodes : - grok : #this is the access log name : NGINXACCESS apply_on : message statics : - meta : log_type value : http_access-log - target : evt.StrTime expression : evt.Parsed.time_local - grok : # and this one the error log name : NGINXERROR apply_on : message statics : - meta : log_type value : http_error-log - target : evt.StrTime expression : evt.Parsed.time # these ones apply for both grok patterns statics : - meta : service value : http - meta : source_ip expression : \"evt.Parsed.remote_addr\" - meta : http_status expression : \"evt.Parsed.status\" - meta : http_path expression : \"evt.Parsed.request\"","title":"Parser trees"},{"location":"references/parsers/#parser-directives","text":"","title":"Parser directives"},{"location":"references/parsers/#debug","text":"debug : true|false default: false If set to to true , enabled node level debugging. It is meant to help understanding parser node behavior by providing contextual logging : assignments made by statics DEBU[31-07-2020 16:36:28] + Processing 4 statics id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[service] = 'http' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[source_ip] = '127.0.0.1' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_status] = '200' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Meta[http_path] = '/' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse assignments made by grok pattern DEBU[31-07-2020 16:36:28] + Grok 'NGINXACCESS' returned 10 entries to merge in Parsed id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['time_local'] = '21/Jul/2020:16:13:05 +0200' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['method'] = 'GET' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['request'] = '/' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['http_user_agent'] = 'curl/7.58.0' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] .Parsed['remote_addr'] = '127.0.0.1' id=dark-glitter name=child-crowdsecurity/nginx-logs stage=s01-parse debug of filters and expression results DEBU[31-07-2020 16:36:28] eval(evt.Parsed.program == 'nginx') = TRUE id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] eval variables: id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse DEBU[31-07-2020 16:36:28] evt.Parsed.program = 'nginx' id=withered-rain name=crowdsecurity/nginx-logs stage=s01-parse","title":"debug"},{"location":"references/parsers/#filter","text":"filter : expression filter must be a valid {{v0X.expr.htmlname}} expression that will be evaluated against the {{v0X.event.htmlname}}. If filter evaluation returns true or is absent, node will be processed. If filter returns false or a non-boolean, node won't be processed. Here is the expr documentation . Examples : filter: \"evt.Meta.foo == 'test'\" filter: \"evt.Meta.bar == 'test' && evt.Meta.foo == 'test2'","title":"filter"},{"location":"references/parsers/#grok","text":"grok : name : NAMED_EXISTING_PATTERN apply_on : source_field grok : pattern : ^a valid RE2 expression with %{CAPTURE:field}$ apply_on : source_field The grok structure in a node represent a regular expression with capture group (grok pattern) that must be applied on a field of {{v0X.event.name}}. The pattern can : be imported by name (if present within the core of {{v0X.crowdsec.name}}) defined in place In both case, the pattern must be a valid RE2 expression. The field(s) returned by the regular expression are going to be merged into the Parsed associative array of the Event .","title":"grok"},{"location":"references/parsers/#name","text":"name : explicit_string The mandatory name of the node. If not present, node will be skipped at runtime. It is used for example in debug log to help you track things.","title":"name"},{"location":"references/parsers/#nodes","text":"nodes : - filter : ... grok : ... nodes is a list of parser nodes, allowing you to build trees. Each subnode must be valid, and if any of the subnodes succeed, the whole node is considered successful.","title":"nodes"},{"location":"references/parsers/#onsuccess","text":"onsuccess: next_stage|continue default: continue if set to next_stage and the node is considered successful, the {{v0X.event.name}} will be moved directly to next stage without processing other nodes in the current stage.","title":"onsuccess"},{"location":"references/parsers/#pattern_syntax","text":"pattern_syntax : CAPTURE_NAME : VALID_RE2_EXPRESSION pattern_syntax allows user to define named capture group expressions for future use in grok patterns. Regexp must be a valid RE2 expression. pattern_syntax : MYCAP : \".*\" grok : pattern : ^xxheader %{MYCAP:extracted_value} trailing stuff$ apply_on : Line.Raw","title":"pattern_syntax"},{"location":"references/parsers/#statics","text":"statics : - target : evt.Meta.target_field value : static_value - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression' - enriched : target_field value : static_value statics is a list of directives that will be executed when the node is considered successful. Each entry of the list is composed of a target (where to write) and a source (what data to write). Target The target aims at being any part of the {{v0X.event.htmlname}} object, and can be expressed in different ways : - `meta: <target_field>` - `parsed: <target_field>` - `enriched: <target_field>` - a dynamic target (please note that the **current** event is accessible via the `evt.` variable) : - `target: evt.Meta.foobar` - `target: Meta.foobar` - `target: evt.StrTime` Source The source itself can be either a static value, or an {{v0X.expr.htmlname}} result : statics : - meta : target_field value : static_value - meta : target_field expression : evt.Meta.another_field - meta : target_field expression : evt.Meta.target_field + ' this_is' + ' a dynamic expression'","title":"statics"},{"location":"references/parsers/#data","text":"data: - source_url: https://URL/TO/FILE dest_file: LOCAL_FILENAME [type: (regexp|string)] data allows user to specify an external source of data. This section is only relevant when cscli is used to install parser from hub, as it will download the source_url and store it to dest_file . When the parser is not installed from the hub, {{v0X.crowdsec.name}} won't download the URL, but the file must exist for the parser to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string","title":"data"},{"location":"references/parsers/#parser-concepts","text":"","title":"Parser concepts"},{"location":"references/parsers/#success-and-failure","text":"A parser is considered \"successful\" if : A grok pattern was present and successfully matched No grok pattern was present","title":"Success and failure"},{"location":"references/plugins_api/","text":"Foreword \u00b6 Output plugins handle Signal Occurences resulting from bucket overflows. This allows to either make a simple notification/alerting plugin or fully manage a backend (this is what {{v0X.crowdsec.name}} uses to manage SQLite and MySQL). You can create your own plugins to perform specific actions when a scenario is triggered. The plugin itself will be compiled into a .so and will have its dedicated configuration. Interface \u00b6 Plugins are created in golang and must conform to the following interface : type Backend interface { Insert ( types . SignalOccurence ) error ReadAT ( time . Time ) ([] map [ string ] string , error ) Delete ( string ) ( int , error ) Init ( map [ string ] string ) error Flush () error Shutdown () error DeleteAll () error StartAutoCommit () error } Startup/shutdown methods Init : called at startup time and receives the custom configuration as a string map. Errors aren't fatal, but plugin will be discarded. Shutdown : called when {{v0X.crowdsec.Name}} is shutting down or restarting Writing/Deleting events Insert : called every time an overflow happens, receives the SignalOccurence as a single parameter. Returned errors are non-fatal and will be logged in warning level. Delete : called to delete existing bans. Receives the exact ip_text (ban target) to delete. Only used by cscli ban del , only relevant for read/write plugins such as database ones. DeleteAll : called to delete all existing bans. Only used by cscli ban flush , only relevant for read/write plugins such as database ones) Reading events ReadAT : returns the list of bans that where active at the given time. The following keys are relevant in the list returned : source, iptext, reason, bancount, action, cn, as, events_count, until. Only used by cscli ban list , only relevant for read/write plugins such as database ones) Backend Flush is called regulary by crowdsec for each plugin that received events. For example it will be called after each write in cscli (as it's one-shot) and every few hundreds of ms / few events in {{v0X.crowdsec.name}} itself. It might be a good place to deal with slower write operations. Configurations \u00b6 Each plugin has its own configuration file : $ cat config/plugins/backend/dummy.yaml # name of the plugin, is used by profiles.yaml name: dummy # path to the .so path: ./plugins/backend/dummy.so # your plugin specific configuration config: some_parameter: some value other_parameter: more data token: fooobarjajajajaja Dummy plugin \u00b6 package main import ( \"time\" \"github.com/crowdsecurity/crowdsec/pkg/types\" log \"github.com/sirupsen/logrus\" ) //This is where you would hold your plugin-specific context type pluginDummy struct { //some persistent data } func ( p * pluginDummy ) Shutdown () error { return nil } func ( p * pluginDummy ) StartAutoCommit () error { return nil } func ( p * pluginDummy ) Init ( config map [ string ] string ) error { log . Infof ( \"pluginDummy config : %+v \" , config ) return nil } func ( p * pluginDummy ) Delete ( target string ) ( int , error ) { return 0 , nil } func ( p * pluginDummy ) DeleteAll () error { return nil } func ( p * pluginDummy ) Insert ( sig types . SignalOccurence ) error { log . Infof ( \"insert signal : %+v\" , sig ) return nil } func ( p * pluginDummy ) Flush () error { return nil } func ( p * pluginDummy ) ReadAT ( timeAT time . Time ) ([] map [ string ] string , error ) { return nil , nil } // New is used by the plugin system to get the context func New () interface {} { return & pluginDummy {} } // empty main function is mandatory since we are in a main package func main () {} Building plugin \u00b6 $ go build -buildmode = plugin -o dummy.so Testing plugin \u00b6 Get a test env from fresh crowdsec release $ cd crowdsec-v0.3.0 $ ./test_env.sh $ cd tests $ cp ../../plugins/backend/dummy/dummy.so ./plugins/backend/ $ cat > config/plugins/backend/dummy.yaml name: dummy path: ./plugins/backend/dummy.so config: some_parameter: some value other_parameter: more data token: fooobarjajajajaja $ ./crowdsec -c dev.yaml -file test.log -type mylog ... INFO [ 06 -08-2020 17 :21:30 ] pluginDummy config : map [ flush:false max_records:10000 max_records_age:720h other_parameter:more data some_parameter:some value token:fooobarjajajajaja ] ... INFO [ 06 -08-2020 17 :21:30 ] Starting processing routines ... INFO [ 06 -08-2020 17 :21:30 ] Processing Overflow ... INFO [ 06 -08-2020 17 :21:30 ] insert signal : { Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } MapKey:97872dfae02c523577eff8ec8e19706eec5fa21e Scenario:trigger on stuff Bucket_id:summer-field Alert_message:0.0.0.0 performed 'trigger on stuff' ( 1 events over 59ns ) at 2020 -08-06 17 :21:30.491000439 +0200 CEST m = +0.722674306 Events_count:1 Events_sequence: [{ Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } Time:2020-08-06 17 :21:30.491000368 +0200 CEST m = +0.722674247 Source: { Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } Ip:0.0.0.0 Range: { IP:<nil> Mask:<nil> } AutonomousSystemNumber:0 AutonomousSystemOrganization: Country: Latitude:0 Longitude:0 Flags:map []} Source_ip:0.0.0.0 Source_range: Source_AutonomousSystemNumber:0 Source_AutonomousSystemOrganization: Source_Country: SignalOccurenceID:0 Serialized: { \"ASNNumber\" : \"0\" , \"IsInEU\" : \"false\" , \"command\" : \"...\" , \"cwd\" : \"...\" : \"...\" , \"orig_uid\" : \"...\" , \"orig_user\" : \"...\" , \"parent\" : \"bash\" , \"service\" : \"...\" , \"source_ip\" : \"...\" , \"user\" : \"...\" }}] Start_at:2020-08-06 17 :21:30.491000368 +0200 CEST m = +0.722674247 BanApplications: [] Stop_at:2020-08-06 17 :21:30.491000439 +0200 CEST m = +0.722674306 Source:0xc000248410 Source_ip:0.0.0.0 Source_range:<nil> Source_AutonomousSystemNumber:0 Source_AutonomousSystemOrganization: Source_Country: Source_Latitude:0 Source_Longitude:0 Sources:map [ 0 .0.0.0: { Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } Ip:0.0.0.0 Range: { IP:<nil> Mask:<nil> } AutonomousSystemNumber:0 AutonomousSystemOrganization: Country: Latitude:0 Longitude:0 Flags:map []}] Dest_ip: Capacity:0 Leak_speed:0s Whitelisted:false Simulation:false Reprocess:false Labels:map [ type:foobar ]} ... Notes \u00b6 All the calls to the plugin methods are blocking. If you need to perform long running operations, it's the plugin's task to handle the background processing with tombs or such. Due to a golang limitation you might have to build crowdsec in the same environment as the plugins.","title":"Writing Output Plugins"},{"location":"references/plugins_api/#foreword","text":"Output plugins handle Signal Occurences resulting from bucket overflows. This allows to either make a simple notification/alerting plugin or fully manage a backend (this is what {{v0X.crowdsec.name}} uses to manage SQLite and MySQL). You can create your own plugins to perform specific actions when a scenario is triggered. The plugin itself will be compiled into a .so and will have its dedicated configuration.","title":"Foreword"},{"location":"references/plugins_api/#interface","text":"Plugins are created in golang and must conform to the following interface : type Backend interface { Insert ( types . SignalOccurence ) error ReadAT ( time . Time ) ([] map [ string ] string , error ) Delete ( string ) ( int , error ) Init ( map [ string ] string ) error Flush () error Shutdown () error DeleteAll () error StartAutoCommit () error } Startup/shutdown methods Init : called at startup time and receives the custom configuration as a string map. Errors aren't fatal, but plugin will be discarded. Shutdown : called when {{v0X.crowdsec.Name}} is shutting down or restarting Writing/Deleting events Insert : called every time an overflow happens, receives the SignalOccurence as a single parameter. Returned errors are non-fatal and will be logged in warning level. Delete : called to delete existing bans. Receives the exact ip_text (ban target) to delete. Only used by cscli ban del , only relevant for read/write plugins such as database ones. DeleteAll : called to delete all existing bans. Only used by cscli ban flush , only relevant for read/write plugins such as database ones) Reading events ReadAT : returns the list of bans that where active at the given time. The following keys are relevant in the list returned : source, iptext, reason, bancount, action, cn, as, events_count, until. Only used by cscli ban list , only relevant for read/write plugins such as database ones) Backend Flush is called regulary by crowdsec for each plugin that received events. For example it will be called after each write in cscli (as it's one-shot) and every few hundreds of ms / few events in {{v0X.crowdsec.name}} itself. It might be a good place to deal with slower write operations.","title":"Interface"},{"location":"references/plugins_api/#configurations","text":"Each plugin has its own configuration file : $ cat config/plugins/backend/dummy.yaml # name of the plugin, is used by profiles.yaml name: dummy # path to the .so path: ./plugins/backend/dummy.so # your plugin specific configuration config: some_parameter: some value other_parameter: more data token: fooobarjajajajaja","title":"Configurations"},{"location":"references/plugins_api/#dummy-plugin","text":"package main import ( \"time\" \"github.com/crowdsecurity/crowdsec/pkg/types\" log \"github.com/sirupsen/logrus\" ) //This is where you would hold your plugin-specific context type pluginDummy struct { //some persistent data } func ( p * pluginDummy ) Shutdown () error { return nil } func ( p * pluginDummy ) StartAutoCommit () error { return nil } func ( p * pluginDummy ) Init ( config map [ string ] string ) error { log . Infof ( \"pluginDummy config : %+v \" , config ) return nil } func ( p * pluginDummy ) Delete ( target string ) ( int , error ) { return 0 , nil } func ( p * pluginDummy ) DeleteAll () error { return nil } func ( p * pluginDummy ) Insert ( sig types . SignalOccurence ) error { log . Infof ( \"insert signal : %+v\" , sig ) return nil } func ( p * pluginDummy ) Flush () error { return nil } func ( p * pluginDummy ) ReadAT ( timeAT time . Time ) ([] map [ string ] string , error ) { return nil , nil } // New is used by the plugin system to get the context func New () interface {} { return & pluginDummy {} } // empty main function is mandatory since we are in a main package func main () {}","title":"Dummy plugin"},{"location":"references/plugins_api/#building-plugin","text":"$ go build -buildmode = plugin -o dummy.so","title":"Building plugin"},{"location":"references/plugins_api/#testing-plugin","text":"Get a test env from fresh crowdsec release $ cd crowdsec-v0.3.0 $ ./test_env.sh $ cd tests $ cp ../../plugins/backend/dummy/dummy.so ./plugins/backend/ $ cat > config/plugins/backend/dummy.yaml name: dummy path: ./plugins/backend/dummy.so config: some_parameter: some value other_parameter: more data token: fooobarjajajajaja $ ./crowdsec -c dev.yaml -file test.log -type mylog ... INFO [ 06 -08-2020 17 :21:30 ] pluginDummy config : map [ flush:false max_records:10000 max_records_age:720h other_parameter:more data some_parameter:some value token:fooobarjajajajaja ] ... INFO [ 06 -08-2020 17 :21:30 ] Starting processing routines ... INFO [ 06 -08-2020 17 :21:30 ] Processing Overflow ... INFO [ 06 -08-2020 17 :21:30 ] insert signal : { Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } MapKey:97872dfae02c523577eff8ec8e19706eec5fa21e Scenario:trigger on stuff Bucket_id:summer-field Alert_message:0.0.0.0 performed 'trigger on stuff' ( 1 events over 59ns ) at 2020 -08-06 17 :21:30.491000439 +0200 CEST m = +0.722674306 Events_count:1 Events_sequence: [{ Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } Time:2020-08-06 17 :21:30.491000368 +0200 CEST m = +0.722674247 Source: { Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } Ip:0.0.0.0 Range: { IP:<nil> Mask:<nil> } AutonomousSystemNumber:0 AutonomousSystemOrganization: Country: Latitude:0 Longitude:0 Flags:map []} Source_ip:0.0.0.0 Source_range: Source_AutonomousSystemNumber:0 Source_AutonomousSystemOrganization: Source_Country: SignalOccurenceID:0 Serialized: { \"ASNNumber\" : \"0\" , \"IsInEU\" : \"false\" , \"command\" : \"...\" , \"cwd\" : \"...\" : \"...\" , \"orig_uid\" : \"...\" , \"orig_user\" : \"...\" , \"parent\" : \"bash\" , \"service\" : \"...\" , \"source_ip\" : \"...\" , \"user\" : \"...\" }}] Start_at:2020-08-06 17 :21:30.491000368 +0200 CEST m = +0.722674247 BanApplications: [] Stop_at:2020-08-06 17 :21:30.491000439 +0200 CEST m = +0.722674306 Source:0xc000248410 Source_ip:0.0.0.0 Source_range:<nil> Source_AutonomousSystemNumber:0 Source_AutonomousSystemOrganization: Source_Country: Source_Latitude:0 Source_Longitude:0 Sources:map [ 0 .0.0.0: { Model: { ID:0 CreatedAt:0001-01-01 00 :00:00 +0000 UTC UpdatedAt:0001-01-01 00 :00:00 +0000 UTC DeletedAt:<nil> } Ip:0.0.0.0 Range: { IP:<nil> Mask:<nil> } AutonomousSystemNumber:0 AutonomousSystemOrganization: Country: Latitude:0 Longitude:0 Flags:map []}] Dest_ip: Capacity:0 Leak_speed:0s Whitelisted:false Simulation:false Reprocess:false Labels:map [ type:foobar ]} ...","title":"Testing plugin"},{"location":"references/plugins_api/#notes","text":"All the calls to the plugin methods are blocking. If you need to perform long running operations, it's the plugin's task to handle the background processing with tombs or such. Due to a golang limitation you might have to build crowdsec in the same environment as the plugins.","title":"Notes"},{"location":"references/scenarios/","text":"Understanding scenarios \u00b6 Scenarios are YAML files that allow to detect and qualify a specific behavior, usually an attack. Scenarios receive {{v0X.event.htmlname}}(s) and can produce {{v0X.overflow.htmlname}}(s) using the leaky bucket algorithm. As an {{v0X.event.htmlname}} can be the representation of a log line, or an overflow, it allows scenarios to process both logs or overflows to allow inference. Scenarios can be of different types (leaky, trigger, counter), and are based on various factors, such as : the speed/frequency of the leaky bucket the capacity of the leaky bucket the characteristic(s) of eligible {{v0X.event.htmlname}}(s) : \"log type XX with field YY set to ZZ\" various filters/directives that can alter the bucket's behavior, such as groupby , distinct or blackhole Behind the scenes, {{v0X.crowdsec.name}} is going to create one or more buckets when events with matching characteristics arrive to the scenario. When any of these buckets overflows, the scenario has been triggered. Bucket partitioning : One scenario usually leads to many buckets creation, as each bucket is only tracking a specific subset of events. For example, if we are tracking brute-force, each \"offending peer\" get its own bucket. A way to detect a http scanner might be to track the number of distinct non-existing pages it's requesting, and the scenario might look like this : #the bucket type : leaky, trigger, counter type : leaky #name and description for humans name : crowdsecurity/http-scan-uniques_404 description : \"Detect multiple unique 404 from a single ip\" #a filter to know which events are eligible filter : \"evt.Meta.service == 'http' && evt.Meta.http_status in ['404', '403', '400']\" #how we are going to partition buckets groupby : \"evt.Meta.source_ip\" #we are only interested into counting UNIQUE/DISTINCT requested URLs distinct : \"evt.Meta.http_path\" #we specify the bucket capacity and leak speed capacity : 5 leakspeed : \"10s\" #this will prevent the same bucket from overflowing more often than every 5 minutes blackhole : 5m #some labels to give context to the overflow labels : service : http type : scan #yes we want to ban people triggering this remediation : true Scenario concepts \u00b6 TimeMachine \u00b6 {{v0X.crowdsec.name}} can be used not only to process live logs, but as well to process \"cold\" logs (think forensics). For this to be able to work, the date/time from the log must have been properly parsed for the scenario temporal aspect to be able to work properly. This relies on the dateparser enrichment Scenario directives \u00b6 type \u00b6 type : leaky|trigger|counter Defines the type of the bucket. Currently three types are supported : leaky : a leaky bucket that must be configured with a {{v0X.capacity.htmlname}} and a {{v0X.leakspeed.htmlname}} trigger : a bucket that overflows as soon as an event is poured (it's like a leaky bucket is a capacity of 0) counter : a bucket that only overflows every {{v0X.duration.htmlname}}. It's especially useful to count things. name & description \u00b6 name : my_author_name/my_scenario_name description : A scenario that detect XXXX behavior Mandatory name and description for said scenario. The name must be unique (and will define the scenario's name in the hub), and the description must be a quick sentence describing what it detects. filter \u00b6 filter : expression filter must be a valid {{v0X.expr.htmlname}} expression that will be evaluated against the {{v0X.event.htmlname}}. If filter evaluation returns true or is absent, event will be pour in the bucket. If filter returns false or a non-boolean, the event will be skip for this bucket. Here is the expr documentation . Examples : evt.Meta.log_type == 'telnet_new_session' evt.Meta.log_type in ['http_access-log', 'http_error-log'] && evt.Parsed.static_ressource == 'false' evt.Meta.log_type == 'ssh_failed-auth' duration \u00b6 duration : 45s duration : 10m (applicable to counter buckets only) A duration after which the bucket will overflow. The format must be compatible with golang ParseDuration format Examples : type : counter name : crowdsecurity/ban-reports-ssh_bf_report description : \"Count unique ips performing ssh bruteforce\" filter : \"evt.Overflow.Scenario == 'ssh_bruteforce'\" distinct : \"evt.Overflow.Source_ip\" capacity : -1 duration : 10m labels : service : ssh groupby \u00b6 groupby : evt.Meta.source_ip an {{v0X.expr.htmlname}} that must return a string. This string will be used as to partition the buckets. Examples : Here, each source_ip will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip ... Here, each unique combo of source_ip + target_username will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip + '--' + evt.Parsed.target_username ... distinct \u00b6 distinct : evt.Meta.http_path an {{v0X.expr.htmlname}} that must return a string. The event will be poured only if the string is not already present in the bucket. Examples : This will ensure that events that keep triggering the same .Meta.http_path will be poured only once. type : leaky ... distinct : \"evt.Meta.http_path\" ... In the logs, you can see it like this (for example from the iptables-logs portscan detection) : DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ok buck.. DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ko, discard event buck.. The first event has been poured (value 7681 ) was not yet present in the events, while the second time, the event got discarded because the value was already present in the bucket. capacity \u00b6 capacity : 5 (Applies only to leaky buckets) A positive integer representing the bucket capacity. If there are more than capacity item in the bucket, it will overflow. leakspeed \u00b6 leakspeed : \"10s\" (Applies only to leaky buckets) A duration that represent how often an event will be leaking from the bucket. Must be compatible with golang ParseDuration format . Example: Here the bucket will leak one item every 10 seconds, and can hold up to 5 items before overflowing. type : leaky ... leakspeed : \"10s\" capacity : 5 ... labels \u00b6 labels : service : ssh type : bruteforce remediation : true Labels is a list of label: values that provide context to an overflow. The labels are (currently) not stored in the database, nor they are sent to the API. Special labels : The remediation label, if set to true indicate the the originating IP should be ban. The scope label, can be set to ip or range when remediation is set to true, and indicate to which scope should the decision apply. If you set a scenario with remediation to true and scope to range and the range of the IP could have been determined by the GeoIP library, the whole range to which the IP belongs will be banned. Example : The IP that triggered the overflow ( .Meta.source_ip ) will be banned. type : leaky ... labels : service : ssh type : bruteforce remediation : true The range to which the offending IP belong ( .Meta.source_ip ) will be banned. type : leaky ... labels : type : distributed_attack remediation : true scope : range blackhole \u00b6 blackhole : 10m A duration for which a bucket will be \"silenced\" after overflowing. This is intended to limit / avoid spam of buckets that might be very rapidly triggered. The blackhole only applies to the individual bucket rather than the whole scenario. Must be compatible with golang ParseDuration format . Example : The same source_ip won't be able to trigger this overflow more than once every 10 minutes. The potential overflows in the meanwhile will be discarded (but will still appear in logs as being blackholed). type : trigger ... blackhole : 10m groupby : evt.Meta.source_ip debug \u00b6 debug : true|false default: false If set to to true , enabled scenario level debugging. It is meant to help understanding scenario behavior by providing contextual logging : debug of filters and expression results DEBU[31-07-2020 16:34:58] eval(evt.Meta.log_type in [\"http_access-log\", \"http_error-log\"] && any(File(\"bad_user_agents.txt\"), {evt.Parsed.http_user_agent contains #})) = TRUE cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] eval variables: cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Meta.log_type = 'http_access-log' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Parsed.http_user_agent = 'Mozilla/5.00 (Nikto/2.1.5) (Evasions:None) (Test:002810)' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent reprocess \u00b6 reprocess : true|false default: false If set to true , the resulting overflow will be sent again in the scenario/parsing pipeline. It is useful when you want to have further scenarios that will rely on past-overflows to take decisions. cache_size \u00b6 cache_size : 5 By default, a bucket holds {{v0X.capacity.htmlname}} events \"in memory\". However, for a number of cases, you don't want this, as it might lead to excessive memory consumption. By setting cache_size to a positive integer, we can control the maximum in-memory cache size of the bucket, without changing its capacity and such. This is especially useful when using counter buckets on long duration that might end up counting (and this storing in memory) an important number of events. overflow_filter \u00b6 overflow_filter : any(queue.Queue, { .Enriched.IsInEU == \"true\" }) overflow_filter is an {{v0X.expr.htmlname}} that is run when the bucket overflows. If this expression is present and returns false, the overflow will be discarded. data \u00b6 data: - source_url: https://URL/TO/FILE dest_file: LOCAL_FILENAME [type: (regexp|string)] data allows user to specify an external source of data. This section is only relevant when cscli is used to install scenario from hub, as ill download the source_url and store it to dest_file . When the scenario is not installed from the hub, {{v0X.crowdsec.name}} won't download the URL, but the file must exist for the scenario to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string","title":"Scenarios format"},{"location":"references/scenarios/#understanding-scenarios","text":"Scenarios are YAML files that allow to detect and qualify a specific behavior, usually an attack. Scenarios receive {{v0X.event.htmlname}}(s) and can produce {{v0X.overflow.htmlname}}(s) using the leaky bucket algorithm. As an {{v0X.event.htmlname}} can be the representation of a log line, or an overflow, it allows scenarios to process both logs or overflows to allow inference. Scenarios can be of different types (leaky, trigger, counter), and are based on various factors, such as : the speed/frequency of the leaky bucket the capacity of the leaky bucket the characteristic(s) of eligible {{v0X.event.htmlname}}(s) : \"log type XX with field YY set to ZZ\" various filters/directives that can alter the bucket's behavior, such as groupby , distinct or blackhole Behind the scenes, {{v0X.crowdsec.name}} is going to create one or more buckets when events with matching characteristics arrive to the scenario. When any of these buckets overflows, the scenario has been triggered. Bucket partitioning : One scenario usually leads to many buckets creation, as each bucket is only tracking a specific subset of events. For example, if we are tracking brute-force, each \"offending peer\" get its own bucket. A way to detect a http scanner might be to track the number of distinct non-existing pages it's requesting, and the scenario might look like this : #the bucket type : leaky, trigger, counter type : leaky #name and description for humans name : crowdsecurity/http-scan-uniques_404 description : \"Detect multiple unique 404 from a single ip\" #a filter to know which events are eligible filter : \"evt.Meta.service == 'http' && evt.Meta.http_status in ['404', '403', '400']\" #how we are going to partition buckets groupby : \"evt.Meta.source_ip\" #we are only interested into counting UNIQUE/DISTINCT requested URLs distinct : \"evt.Meta.http_path\" #we specify the bucket capacity and leak speed capacity : 5 leakspeed : \"10s\" #this will prevent the same bucket from overflowing more often than every 5 minutes blackhole : 5m #some labels to give context to the overflow labels : service : http type : scan #yes we want to ban people triggering this remediation : true","title":"Understanding scenarios"},{"location":"references/scenarios/#scenario-concepts","text":"","title":"Scenario concepts"},{"location":"references/scenarios/#timemachine","text":"{{v0X.crowdsec.name}} can be used not only to process live logs, but as well to process \"cold\" logs (think forensics). For this to be able to work, the date/time from the log must have been properly parsed for the scenario temporal aspect to be able to work properly. This relies on the dateparser enrichment","title":"TimeMachine"},{"location":"references/scenarios/#scenario-directives","text":"","title":"Scenario directives"},{"location":"references/scenarios/#type","text":"type : leaky|trigger|counter Defines the type of the bucket. Currently three types are supported : leaky : a leaky bucket that must be configured with a {{v0X.capacity.htmlname}} and a {{v0X.leakspeed.htmlname}} trigger : a bucket that overflows as soon as an event is poured (it's like a leaky bucket is a capacity of 0) counter : a bucket that only overflows every {{v0X.duration.htmlname}}. It's especially useful to count things.","title":"type"},{"location":"references/scenarios/#name-description","text":"name : my_author_name/my_scenario_name description : A scenario that detect XXXX behavior Mandatory name and description for said scenario. The name must be unique (and will define the scenario's name in the hub), and the description must be a quick sentence describing what it detects.","title":"name &amp; description"},{"location":"references/scenarios/#filter","text":"filter : expression filter must be a valid {{v0X.expr.htmlname}} expression that will be evaluated against the {{v0X.event.htmlname}}. If filter evaluation returns true or is absent, event will be pour in the bucket. If filter returns false or a non-boolean, the event will be skip for this bucket. Here is the expr documentation . Examples : evt.Meta.log_type == 'telnet_new_session' evt.Meta.log_type in ['http_access-log', 'http_error-log'] && evt.Parsed.static_ressource == 'false' evt.Meta.log_type == 'ssh_failed-auth'","title":"filter"},{"location":"references/scenarios/#duration","text":"duration : 45s duration : 10m (applicable to counter buckets only) A duration after which the bucket will overflow. The format must be compatible with golang ParseDuration format Examples : type : counter name : crowdsecurity/ban-reports-ssh_bf_report description : \"Count unique ips performing ssh bruteforce\" filter : \"evt.Overflow.Scenario == 'ssh_bruteforce'\" distinct : \"evt.Overflow.Source_ip\" capacity : -1 duration : 10m labels : service : ssh","title":"duration"},{"location":"references/scenarios/#groupby","text":"groupby : evt.Meta.source_ip an {{v0X.expr.htmlname}} that must return a string. This string will be used as to partition the buckets. Examples : Here, each source_ip will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip ... Here, each unique combo of source_ip + target_username will get its own bucket. type : leaky ... groupby : evt.Meta.source_ip + '--' + evt.Parsed.target_username ...","title":"groupby"},{"location":"references/scenarios/#distinct","text":"distinct : evt.Meta.http_path an {{v0X.expr.htmlname}} that must return a string. The event will be poured only if the string is not already present in the bucket. Examples : This will ensure that events that keep triggering the same .Meta.http_path will be poured only once. type : leaky ... distinct : \"evt.Meta.http_path\" ... In the logs, you can see it like this (for example from the iptables-logs portscan detection) : DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ok buck.. DEBU [ 2020 -05-13T11:29:51+02:00 ] Uniq ( 7681 ) : ko, discard event buck.. The first event has been poured (value 7681 ) was not yet present in the events, while the second time, the event got discarded because the value was already present in the bucket.","title":"distinct"},{"location":"references/scenarios/#capacity","text":"capacity : 5 (Applies only to leaky buckets) A positive integer representing the bucket capacity. If there are more than capacity item in the bucket, it will overflow.","title":"capacity"},{"location":"references/scenarios/#leakspeed","text":"leakspeed : \"10s\" (Applies only to leaky buckets) A duration that represent how often an event will be leaking from the bucket. Must be compatible with golang ParseDuration format . Example: Here the bucket will leak one item every 10 seconds, and can hold up to 5 items before overflowing. type : leaky ... leakspeed : \"10s\" capacity : 5 ...","title":"leakspeed"},{"location":"references/scenarios/#labels","text":"labels : service : ssh type : bruteforce remediation : true Labels is a list of label: values that provide context to an overflow. The labels are (currently) not stored in the database, nor they are sent to the API. Special labels : The remediation label, if set to true indicate the the originating IP should be ban. The scope label, can be set to ip or range when remediation is set to true, and indicate to which scope should the decision apply. If you set a scenario with remediation to true and scope to range and the range of the IP could have been determined by the GeoIP library, the whole range to which the IP belongs will be banned. Example : The IP that triggered the overflow ( .Meta.source_ip ) will be banned. type : leaky ... labels : service : ssh type : bruteforce remediation : true The range to which the offending IP belong ( .Meta.source_ip ) will be banned. type : leaky ... labels : type : distributed_attack remediation : true scope : range","title":"labels"},{"location":"references/scenarios/#blackhole","text":"blackhole : 10m A duration for which a bucket will be \"silenced\" after overflowing. This is intended to limit / avoid spam of buckets that might be very rapidly triggered. The blackhole only applies to the individual bucket rather than the whole scenario. Must be compatible with golang ParseDuration format . Example : The same source_ip won't be able to trigger this overflow more than once every 10 minutes. The potential overflows in the meanwhile will be discarded (but will still appear in logs as being blackholed). type : trigger ... blackhole : 10m groupby : evt.Meta.source_ip","title":"blackhole"},{"location":"references/scenarios/#debug","text":"debug : true|false default: false If set to to true , enabled scenario level debugging. It is meant to help understanding scenario behavior by providing contextual logging : debug of filters and expression results DEBU[31-07-2020 16:34:58] eval(evt.Meta.log_type in [\"http_access-log\", \"http_error-log\"] && any(File(\"bad_user_agents.txt\"), {evt.Parsed.http_user_agent contains #})) = TRUE cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] eval variables: cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Meta.log_type = 'http_access-log' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent DEBU[31-07-2020 16:34:58] evt.Parsed.http_user_agent = 'Mozilla/5.00 (Nikto/2.1.5) (Evasions:None) (Test:002810)' cfg=still-feather file=config/scenarios/http-bad-user-agent.yaml name=crowdsecurity/http-bad-user-agent","title":"debug"},{"location":"references/scenarios/#reprocess","text":"reprocess : true|false default: false If set to true , the resulting overflow will be sent again in the scenario/parsing pipeline. It is useful when you want to have further scenarios that will rely on past-overflows to take decisions.","title":"reprocess"},{"location":"references/scenarios/#cache_size","text":"cache_size : 5 By default, a bucket holds {{v0X.capacity.htmlname}} events \"in memory\". However, for a number of cases, you don't want this, as it might lead to excessive memory consumption. By setting cache_size to a positive integer, we can control the maximum in-memory cache size of the bucket, without changing its capacity and such. This is especially useful when using counter buckets on long duration that might end up counting (and this storing in memory) an important number of events.","title":"cache_size"},{"location":"references/scenarios/#overflow_filter","text":"overflow_filter : any(queue.Queue, { .Enriched.IsInEU == \"true\" }) overflow_filter is an {{v0X.expr.htmlname}} that is run when the bucket overflows. If this expression is present and returns false, the overflow will be discarded.","title":"overflow_filter"},{"location":"references/scenarios/#data","text":"data: - source_url: https://URL/TO/FILE dest_file: LOCAL_FILENAME [type: (regexp|string)] data allows user to specify an external source of data. This section is only relevant when cscli is used to install scenario from hub, as ill download the source_url and store it to dest_file . When the scenario is not installed from the hub, {{v0X.crowdsec.name}} won't download the URL, but the file must exist for the scenario to be loaded correctly. The type is mandatory if you want to evaluate the data in the file, and should be regex for valid (re2) regular expression per line or string for string per line. The regexps will be compiled, the strings will be loaded into a list and both will be kept in memory. Without specifying a type , the file will be downloaded and stored as file and not in memory. name : crowdsecurity/cdn-whitelist ... data : - source_url : https://www.cloudflare.com/ips-v4 dest_file : cloudflare_ips.txt type : string","title":"data"},{"location":"write_configurations/acquisition/","text":"Write the acquisition file (optional for test) \u00b6 In order for your log to be processed by the good parser, it must match the filter that you will configure in your parser file. There are two options: Your logs are written by a syslog server, so you just have to install the syslog parser Your logs are read from a log file. Please add this kind of configuration in your acquis.yaml file: \u24d8 the type will be matched by the parsers's filter in stage s01-parse . --- filename : <PATH_TO_YOUR_LOG_FILE> labels : type : <PROGRAM_NAME> Here an example: Nginx acquisition --- filename : /var/log/nginx/access.log labels : type : nginx Nginx parser filter --- filter : evt.Parsed.program == 'nginx'","title":"Acquisition"},{"location":"write_configurations/acquisition/#write-the-acquisition-file-optional-for-test","text":"In order for your log to be processed by the good parser, it must match the filter that you will configure in your parser file. There are two options: Your logs are written by a syslog server, so you just have to install the syslog parser Your logs are read from a log file. Please add this kind of configuration in your acquis.yaml file: \u24d8 the type will be matched by the parsers's filter in stage s01-parse . --- filename : <PATH_TO_YOUR_LOG_FILE> labels : type : <PROGRAM_NAME> Here an example: Nginx acquisition --- filename : /var/log/nginx/access.log labels : type : nginx Nginx parser filter --- filter : evt.Parsed.program == 'nginx'","title":"Write the acquisition file (optional for test)"},{"location":"write_configurations/expressions/","text":"Expressions \u00b6 antonmedv/expr - Expression evaluation engine for Go: fast, non-Turing complete, dynamic typing, static typing Several places of {{v0X.crowdsec.name}}'s configuration use expr , notably : {{v0X.filter.Htmlname}} that are used to determine events eligibility in {{v0X.parsers.htmlname}} and {{v0X.scenarios.htmlname}} or profiles {{v0X.statics.Htmlname}} use expr in the expression directive, to compute complex values {{v0X.whitelists.Htmlname}} rely on expression directive to allow more complex whitelists filters To learn more about expr , check the github page of the project . When {{v0X.crowdsec.name}} relies on expr , a context is provided to let the expression access relevant objects : evt. is the representation of the current {{v0X.event.htmlname}} and is the most relevant object in profiles , {{v0X.signal.htmlname}} is accessible via the sig. object If the debug is enabled (in the scenario or parser where expr is used), additional debug will be displayed regarding evaluated expressions. Helpers \u00b6 In order to makes its use in {{v0X.crowdsec.name}} more efficient, we added a few helpers that are documented bellow. Atof(string) float64 \u00b6 Parses a string representation of a float number to an actual float number (binding on strconv.ParseFloat ) Atof(evt.Parsed.tcp_port) JsonExtract(JsonBlob, FieldName) string \u00b6 Extract the FieldName from the JsonBlob and returns it as a string. (binding on jsonparser ) JsonExtract(evt.Parsed.some_json_blob, \"foo.bar[0].one_item\") File(FileName) []string \u00b6 Returns the content of FileName as an array of string, while providing cache mechanism. evt.Parsed.some_field in File('some_patterns.txt') any(File('rdns_seo_bots.txt'), { evt.Enriched.reverse_dns endsWith #}) RegexpInFile(StringToMatch, FileName) bool \u00b6 Returns true if the StringToMatch is matched by one of the expressions contained in FileName (uses RE2 regexp engine). RegexpInFile( evt.Enriched.reverse_dns, 'my_legit_seo_whitelists.txt') Upper(string) string \u00b6 Returns the uppercase version of the string Upper(\"yop\") IpInRange(IPStr, RangeStr) bool \u00b6 Returns true if the IP IPStr is contained in the IP range RangeStr (uses net.ParseCIDR ) IpInRange(\"1.2.3.4\", \"1.2.3.0/24\")","title":"Expressions"},{"location":"write_configurations/expressions/#expressions","text":"antonmedv/expr - Expression evaluation engine for Go: fast, non-Turing complete, dynamic typing, static typing Several places of {{v0X.crowdsec.name}}'s configuration use expr , notably : {{v0X.filter.Htmlname}} that are used to determine events eligibility in {{v0X.parsers.htmlname}} and {{v0X.scenarios.htmlname}} or profiles {{v0X.statics.Htmlname}} use expr in the expression directive, to compute complex values {{v0X.whitelists.Htmlname}} rely on expression directive to allow more complex whitelists filters To learn more about expr , check the github page of the project . When {{v0X.crowdsec.name}} relies on expr , a context is provided to let the expression access relevant objects : evt. is the representation of the current {{v0X.event.htmlname}} and is the most relevant object in profiles , {{v0X.signal.htmlname}} is accessible via the sig. object If the debug is enabled (in the scenario or parser where expr is used), additional debug will be displayed regarding evaluated expressions.","title":"Expressions"},{"location":"write_configurations/expressions/#helpers","text":"In order to makes its use in {{v0X.crowdsec.name}} more efficient, we added a few helpers that are documented bellow.","title":"Helpers"},{"location":"write_configurations/expressions/#atofstring-float64","text":"Parses a string representation of a float number to an actual float number (binding on strconv.ParseFloat ) Atof(evt.Parsed.tcp_port)","title":"Atof(string) float64"},{"location":"write_configurations/expressions/#jsonextractjsonblob-fieldname-string","text":"Extract the FieldName from the JsonBlob and returns it as a string. (binding on jsonparser ) JsonExtract(evt.Parsed.some_json_blob, \"foo.bar[0].one_item\")","title":"JsonExtract(JsonBlob, FieldName) string"},{"location":"write_configurations/expressions/#filefilename-string","text":"Returns the content of FileName as an array of string, while providing cache mechanism. evt.Parsed.some_field in File('some_patterns.txt') any(File('rdns_seo_bots.txt'), { evt.Enriched.reverse_dns endsWith #})","title":"File(FileName) []string"},{"location":"write_configurations/expressions/#regexpinfilestringtomatch-filename-bool","text":"Returns true if the StringToMatch is matched by one of the expressions contained in FileName (uses RE2 regexp engine). RegexpInFile( evt.Enriched.reverse_dns, 'my_legit_seo_whitelists.txt')","title":"RegexpInFile(StringToMatch, FileName) bool"},{"location":"write_configurations/expressions/#upperstring-string","text":"Returns the uppercase version of the string Upper(\"yop\")","title":"Upper(string) string"},{"location":"write_configurations/expressions/#ipinrangeipstr-rangestr-bool","text":"Returns true if the IP IPStr is contained in the IP range RangeStr (uses net.ParseCIDR ) IpInRange(\"1.2.3.4\", \"1.2.3.0/24\")","title":"IpInRange(IPStr, RangeStr) bool"},{"location":"write_configurations/parsers/","text":"Writing {{v0X.crowdsec.Name}} parser \u00b6 Parser dependency The crowdsecurity/syslog-logs parsers is needed by the core parsing engine. Deletion or modification of this could result of {{v0X.crowdsec.name}} being unable to parse logs, so this should be done very carefully. In the current example, we'll write a parser for the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new parsers. Base parser file \u00b6 The most simple parser can be defined as : filter : 1 == 1 debug : true onsuccess : next_stage name : me/myparser description : a cool parser for my service grok : #our grok pattern : capture .* pattern : ^%{DATA:some_data}$ #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes a {{v0X.filter.htmlname}} : if the expression is true , the event will enter the parser, otherwise, it won't a {{v0X.onsuccess.htmlname}} : defines what happens when the {{v0X.event.htmlname}} was successfully parsed : shall we continue ? shall we move to next stage ? etc. a name & a description some {{v0X.statics.htmlname}} that will modify the {{v0X.event.htmlname}} a debug flag that allows to enable local debugging information. We are going to use to following sample log as an example : May 11 16 :23:43 sd-126005 kernel: [ 47615895 .771900 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x00 PREC = 0x00 TTL = 245 ID = 51006 PROTO = TCP SPT = 45225 DPT = 8888 WINDOW = 1024 RES = 0x00 SYN URGP = 0 May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0 Trying our mock parser \u00b6 Warning Your yaml file must be in the config/parsers/s01-parser/ directory. For example it can be ~/crowdsec-v0.0.19/tests/config/parsers/s01-parser/myparser.yaml , or /etc/crowdsec/config/parsers/s01-parser/myparser.yaml . The {{v0X.stage.htmlname}} directory might not exist, don't forget to create it. (deployment is assuming you're using a test environment ) Setting up our new parser : cd crowdsec-v0.X.Y/tests mkdir -p config/parsers/s01-parser cp myparser.yaml config/parsers/s01-parser/ ./crowdsec -c ./dev.yaml -file ./x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 15 :48:28 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] + Grok '' returned 1 entries to merge in Parsed id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] .Parsed [ 'some_data' ] = 'May 11 16:23:41 sd-126005 kernel: [47615893.721616] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=54555 PROTO=TCP SPT=45225 DPT=8080 WINDOW=1024 RES=0x00 SYN URGP=0 ' id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] + Processing 1 statics id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] Event leaving node : ok id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] move Event from stage s01-parser to s02-enrich id = dark-water name = me/myparser stage = s01-parser ... We can see our \"mock\" parser is working, let's see what happened : The event enter the node The filter returned true ( 1 == 1 ) so the {{v0X.event.htmlname}} will be processed Our grok pattern (just a .* capture) \"worked\" and captured data (the whole line actually) The grok captures (under the name \"some_data\") are merged into the .Parsed map of the {{v0X.event.htmlname}} The {{v0X.statics.htmlname}} section is processed, and .Parsed[is_my_service] is set to yes The {{v0X.event.htmlname}} leaves the parser successfully, and because \"next_stage\" is set, we move the event to the next \"stage\" Writing the GROK pattern \u00b6 We are going to write a parser for iptables logs, they look like this : May 11 16:23:43 sd-126005 kernel: [47615895.771900] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=51006 PROTO=TCP SPT=45225 DPT=8888 WINDOW=1024 RES=0x00 SYN URGP=0 May 11 16:23:50 sd-126005 kernel: [47615902.763137] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=44.44.44.44 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=49 ID=17451 DF PROTO=TCP SPT=53668 DPT=80 WINDOW=14600 RES=0x00 SYN URGP=0 Using an online grok debugger or an online regex debugger , we come up with the following grok pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* Warning Check if the pattern you are looking for is not already present in patterns configuration . Test our new pattern \u00b6 Now, let's integrate our GROK pattern within our YAML : #let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"1 == 1\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes ./crowdsec -c ./dev.yaml -file ./x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 16 :18:58 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8080' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '99.99.99.99' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Processing 1 statics id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] Event leaving node : ok id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] move Event from stage s01-parser to s02-enrich id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser ... What changed ? We can now see that the fragment captured by the GROK pattern are merged in the Parsed array ! We now have parsed data, only a few more changes and we will be done :) Finalizing our parser \u00b6 #let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"evt.Parsed.program == 'kernel'\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - meta : log_type value : iptables_drop - meta : service expression : \"evt.Parsed.proto == 'TCP' ? 'tcp' : 'unknown'\" - meta : source_ip expression : \"evt.Parsed.src_ip\" filter \u00b6 We changed the {{v0X.filter.htmlname}} to correctly filter on the program name. In the current example, our logs are produced by the kernel (netfilter), and thus the program is kernel : tail -f /var/log/kern.log May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0 statics \u00b6 We are setting various entries to static or dynamic values to give \"context\" to the log : .Meta.log_type is set to iptables_drop (so that we later can filter events coming from this) .Meta.source_ip is set the the source ip captured .Parsed.src_ip .Meta.service is set the the result of an expression that relies on the GROK output ( proto field) Look into dedicated {{v0X.statics.htmlname}} documentation to know more about its possibilities. Testing our finalized parser \u00b6 ./crowdsec -c ./dev.yaml -file ./x.log -type kernel Expected output ... DEBU [ 0000 ] Event entering node id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] eval ( TRUE ) 'evt.Parsed.program == ' kernel '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8118' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Processing 3 statics id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Meta [ log_type ] = 'iptables_drop' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Meta [ service ] = 'tcp' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Meta [ source_ip ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] Event leaving node : ok id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] move Event from stage s01-parser to s02-enrich id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser ... Closing word \u00b6 We have now a fully functional parser for {{v0X.crowdsec.name}} ! We can either deploy it to our production systems to do stuff, or even better, contribute to the {{v0X.hub.htmlname}} ! If you want to know more about directives and possibilities, take a look at the parser reference documentation !","title":"Parsers"},{"location":"write_configurations/parsers/#writing-v0xcrowdsecname-parser","text":"Parser dependency The crowdsecurity/syslog-logs parsers is needed by the core parsing engine. Deletion or modification of this could result of {{v0X.crowdsec.name}} being unable to parse logs, so this should be done very carefully. In the current example, we'll write a parser for the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new parsers.","title":"Writing {{v0X.crowdsec.Name}} parser"},{"location":"write_configurations/parsers/#base-parser-file","text":"The most simple parser can be defined as : filter : 1 == 1 debug : true onsuccess : next_stage name : me/myparser description : a cool parser for my service grok : #our grok pattern : capture .* pattern : ^%{DATA:some_data}$ #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes a {{v0X.filter.htmlname}} : if the expression is true , the event will enter the parser, otherwise, it won't a {{v0X.onsuccess.htmlname}} : defines what happens when the {{v0X.event.htmlname}} was successfully parsed : shall we continue ? shall we move to next stage ? etc. a name & a description some {{v0X.statics.htmlname}} that will modify the {{v0X.event.htmlname}} a debug flag that allows to enable local debugging information. We are going to use to following sample log as an example : May 11 16 :23:43 sd-126005 kernel: [ 47615895 .771900 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x00 PREC = 0x00 TTL = 245 ID = 51006 PROTO = TCP SPT = 45225 DPT = 8888 WINDOW = 1024 RES = 0x00 SYN URGP = 0 May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0","title":"Base parser file"},{"location":"write_configurations/parsers/#trying-our-mock-parser","text":"Warning Your yaml file must be in the config/parsers/s01-parser/ directory. For example it can be ~/crowdsec-v0.0.19/tests/config/parsers/s01-parser/myparser.yaml , or /etc/crowdsec/config/parsers/s01-parser/myparser.yaml . The {{v0X.stage.htmlname}} directory might not exist, don't forget to create it. (deployment is assuming you're using a test environment ) Setting up our new parser : cd crowdsec-v0.X.Y/tests mkdir -p config/parsers/s01-parser cp myparser.yaml config/parsers/s01-parser/ ./crowdsec -c ./dev.yaml -file ./x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 15 :48:28 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] + Grok '' returned 1 entries to merge in Parsed id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] .Parsed [ 'some_data' ] = 'May 11 16:23:41 sd-126005 kernel: [47615893.721616] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=54555 PROTO=TCP SPT=45225 DPT=8080 WINDOW=1024 RES=0x00 SYN URGP=0 ' id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] + Processing 1 statics id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] Event leaving node : ok id = dark-water name = me/myparser stage = s01-parser DEBU [ 0000 ] move Event from stage s01-parser to s02-enrich id = dark-water name = me/myparser stage = s01-parser ... We can see our \"mock\" parser is working, let's see what happened : The event enter the node The filter returned true ( 1 == 1 ) so the {{v0X.event.htmlname}} will be processed Our grok pattern (just a .* capture) \"worked\" and captured data (the whole line actually) The grok captures (under the name \"some_data\") are merged into the .Parsed map of the {{v0X.event.htmlname}} The {{v0X.statics.htmlname}} section is processed, and .Parsed[is_my_service] is set to yes The {{v0X.event.htmlname}} leaves the parser successfully, and because \"next_stage\" is set, we move the event to the next \"stage\"","title":"Trying our mock parser"},{"location":"write_configurations/parsers/#writing-the-grok-pattern","text":"We are going to write a parser for iptables logs, they look like this : May 11 16:23:43 sd-126005 kernel: [47615895.771900] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=99.99.99.99 DST=127.0.0.1 LEN=40 TOS=0x00 PREC=0x00 TTL=245 ID=51006 PROTO=TCP SPT=45225 DPT=8888 WINDOW=1024 RES=0x00 SYN URGP=0 May 11 16:23:50 sd-126005 kernel: [47615902.763137] IN=enp1s0 OUT= MAC=00:08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC=44.44.44.44 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=49 ID=17451 DF PROTO=TCP SPT=53668 DPT=80 WINDOW=14600 RES=0x00 SYN URGP=0 Using an online grok debugger or an online regex debugger , we come up with the following grok pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* Warning Check if the pattern you are looking for is not already present in patterns configuration .","title":"Writing the GROK pattern"},{"location":"write_configurations/parsers/#test-our-new-pattern","text":"Now, let's integrate our GROK pattern within our YAML : #let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"1 == 1\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - parsed : is_my_service value : yes ./crowdsec -c ./dev.yaml -file ./x.log -type foobar Expected output INFO [ 0000 ] setting loglevel to info INFO [ 11 -05-2020 16 :18:58 ] Crowdsec v0.0.18-6b1281ba76819fed4b89247a5a673c592a3a9f88 ... DEBU [ 0000 ] Event entering node id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] eval ( TRUE ) '1 == 1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8080' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '99.99.99.99' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Processing 1 statics id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ is_my_service ] = 'yes' id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] Event leaving node : ok id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] move Event from stage s01-parser to s02-enrich id = lingering-breeze name = crowdsecurity/iptables-logs stage = s01-parser ... What changed ? We can now see that the fragment captured by the GROK pattern are merged in the Parsed array ! We now have parsed data, only a few more changes and we will be done :)","title":"Test our new pattern"},{"location":"write_configurations/parsers/#finalizing-our-parser","text":"#let's set onsuccess to \"next_stage\" : if the log is parsed, we can consider it has been dealt with onsuccess : next_stage #debug, for reasons (don't do this in production) debug : true #as seen in our sample log, those logs are processed by the system and have a progname set to 'kernel' filter : \"evt.Parsed.program == 'kernel'\" #name and description: name : crowdsecurity/iptables-logs description : \"Parse iptables drop logs\" grok : #our grok pattern pattern : \\[%{DATA}\\]+.*(%{WORD:action})? IN=%{WORD:int_eth} OUT= MAC=%{IP}:%{MAC} SRC=%{IP:src_ip} DST=%{IP:dst_ip} LEN=%{INT:length}.*PROTO=%{WORD:proto} SPT=%{INT:src_port} DPT=%{INT:dst_port}.* #the field to which we apply the grok pattern : the log message itself apply_on : message statics : - meta : log_type value : iptables_drop - meta : service expression : \"evt.Parsed.proto == 'TCP' ? 'tcp' : 'unknown'\" - meta : source_ip expression : \"evt.Parsed.src_ip\"","title":"Finalizing our parser"},{"location":"write_configurations/parsers/#filter","text":"We changed the {{v0X.filter.htmlname}} to correctly filter on the program name. In the current example, our logs are produced by the kernel (netfilter), and thus the program is kernel : tail -f /var/log/kern.log May 11 16 :23:50 sd-126005 kernel: [ 47615902 .763137 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 60 TOS = 0x00 PREC = 0x00 TTL = 49 ID = 17451 DF PROTO = TCP SPT = 53668 DPT = 80 WINDOW = 14600 RES = 0x00 SYN URGP = 0","title":"filter"},{"location":"write_configurations/parsers/#statics","text":"We are setting various entries to static or dynamic values to give \"context\" to the log : .Meta.log_type is set to iptables_drop (so that we later can filter events coming from this) .Meta.source_ip is set the the source ip captured .Parsed.src_ip .Meta.service is set the the result of an expression that relies on the GROK output ( proto field) Look into dedicated {{v0X.statics.htmlname}} documentation to know more about its possibilities.","title":"statics"},{"location":"write_configurations/parsers/#testing-our-finalized-parser","text":"./crowdsec -c ./dev.yaml -file ./x.log -type kernel Expected output ... DEBU [ 0000 ] Event entering node id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] eval ( TRUE ) 'evt.Parsed.program == ' kernel '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] no ip in event, cidr/ip whitelists not checked id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Grok '' returned 8 entries to merge in Parsed id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_port' ] = '45225' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_port' ] = '8118' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'action' ] = '' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'int_eth' ] = 'enp1s0' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'src_ip' ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'dst_ip' ] = '127.0.0.1' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'length' ] = '40' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Parsed [ 'proto' ] = 'TCP' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] + Processing 3 statics id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Meta [ log_type ] = 'iptables_drop' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Meta [ service ] = 'tcp' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] .Meta [ source_ip ] = '44.44.44.44' id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] Event leaving node : ok id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser DEBU [ 0000 ] move Event from stage s01-parser to s02-enrich id = shy-forest name = crowdsecurity/iptables-logs stage = s01-parser ...","title":"Testing our finalized parser"},{"location":"write_configurations/parsers/#closing-word","text":"We have now a fully functional parser for {{v0X.crowdsec.name}} ! We can either deploy it to our production systems to do stuff, or even better, contribute to the {{v0X.hub.htmlname}} ! If you want to know more about directives and possibilities, take a look at the parser reference documentation !","title":"Closing word"},{"location":"write_configurations/requirements/","text":"Requirements \u00b6 Some requirements are needed in order to be able to write your own end-to-end configurations. During all this documentation, we are going to show as an exemple how we wrote a full port scan detection scenario (from acqusition to scenario, including parser) Create the test environment \u00b6 First of all, please download the latest release of {{v0X.crowdsec.name}} . Then run the following commands: tar xzvf crowdsec-release.tgz cd ./crowdsec-vX.Y/ ./test_env.sh # the -o is facultative, default is \"./tests/\" cd ./tests/ The ./test_env.sh script creates a local (non privileged) working environement for {{v0X.crowdsec.name}} and {{v0X.cli.name}}. The deployed environment is intended to write and test parsers and scenarios easily. Example $ tar xzvf ./crowdsec-release.tgz $ cd ./crowdsec-v0.0.18/ $ ./test_env.sh [ 09 /05/2020:20:02:19 ][ INFO ] Creating test arboresence in /tmp/crowdsec-v0.0.18/tests [ 09 /05/2020:20:02:19 ][ INFO ] Arboresence created [ 09 /05/2020:20:02:19 ][ INFO ] Copying needed files for tests environment [ 09 /05/2020:20:02:19 ][ INFO ] Files copied [ 09 /05/2020:20:02:19 ][ INFO ] Setting up configurations INFO [ 0000 ] Failed to open config /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config : open /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config: no such file or directory WARN [ 0000 ] creating skeleton! INFO [ 0000 ] wrote config to /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config INFO [ 0000 ] wrote config to /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config INFO [ 0000 ] Wrote new 45625 bytes index to /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK INFO [ 0000 ] crowdsecurity/dateparse-enrich : OK INFO [ 0001 ] crowdsecurity/linux : OK INFO [ 0001 ] /tmp/crowdsec-v0.0.18/tests/config/collections doesn \\' t exist, create INFO [ 0001 ] /tmp/crowdsec-v0.0.18/tests/config/parsers/s00-raw doesn \\' t exist, create INFO [ 0001 ] Enabled parsers : crowdsecurity/syslog-logs INFO [ 0001 ] /tmp/crowdsec-v0.0.18/tests/config/parsers/s02-enrich doesn \\' t exist, create INFO [ 0001 ] Enabled parsers : crowdsecurity/geoip-enrich INFO [ 0001 ] Enabled parsers : crowdsecurity/dateparse-enrich INFO [ 0001 ] Enabled collections : crowdsecurity/linux INFO [ 0001 ] Enabled crowdsecurity/linux [ 09 /05/2020:20:02:20 ][ INFO ] Environment is ready in /tmp/crowdsec-v0.0.18/tests \u24d8 Reminder \u00b6 Logs parsing is divided into stage, and each stage can contain one or more parser. Stages are named using a \"sXX- \" convention, and are processed in the alphabetical order. When a log is successfully parsed by a node that is configured to go in next_stage , the event is forwarded to the next stage (and the remaining parsers of the current stage aren't parsed). Stages and parsers are being processed alphabetically, thus the expected order would be : s00-raw/syslog.yaml s01-parse/apache.yaml s01-parse/nginx.yaml s02-enrich/geoip.yaml s02-enrich/rdns.yaml Default stages \u00b6 The preliminary stage ( s00-raw ) is mostly the one that will parse the structure of the log. This is where syslog-logs are parsed for example. Such a parser will parse the syslog header to detect the program source. The main stage ( s01-parse ) is the one that will parse actual applications logs and output parsed data and static assigned values. There is one parser for each type of software. To parse the logs, regexp or GROK pattern are used. If the parser is configured to go to the next_stage , then it will be process by the enrichment stage. The enrichment ( s02-enrich ) stage is the one that will enrich the normalized log (we call it an event now that it is normalized) in order to get more information for the heuristic process. This stage can be composed of grok patterns and so on, but as well of plugins that can be writen by the community (geiop enrichment, rdns ...) for example geoip-enrich . You can now jump to the next step : writing our own parser ! Custom stage \u00b6 It is possible to write custom stage. If you want some specific parsing or enrichment to be done after the s02-enrich stage, it is possible by creating a new folder s03-<custom_stage> (and so on). The configuration that will be created in this folder will process the logs configured to go to next_stage in the s02-enrich stage.","title":"Requirements"},{"location":"write_configurations/requirements/#requirements","text":"Some requirements are needed in order to be able to write your own end-to-end configurations. During all this documentation, we are going to show as an exemple how we wrote a full port scan detection scenario (from acqusition to scenario, including parser)","title":"Requirements"},{"location":"write_configurations/requirements/#create-the-test-environment","text":"First of all, please download the latest release of {{v0X.crowdsec.name}} . Then run the following commands: tar xzvf crowdsec-release.tgz cd ./crowdsec-vX.Y/ ./test_env.sh # the -o is facultative, default is \"./tests/\" cd ./tests/ The ./test_env.sh script creates a local (non privileged) working environement for {{v0X.crowdsec.name}} and {{v0X.cli.name}}. The deployed environment is intended to write and test parsers and scenarios easily. Example $ tar xzvf ./crowdsec-release.tgz $ cd ./crowdsec-v0.0.18/ $ ./test_env.sh [ 09 /05/2020:20:02:19 ][ INFO ] Creating test arboresence in /tmp/crowdsec-v0.0.18/tests [ 09 /05/2020:20:02:19 ][ INFO ] Arboresence created [ 09 /05/2020:20:02:19 ][ INFO ] Copying needed files for tests environment [ 09 /05/2020:20:02:19 ][ INFO ] Files copied [ 09 /05/2020:20:02:19 ][ INFO ] Setting up configurations INFO [ 0000 ] Failed to open config /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config : open /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config: no such file or directory WARN [ 0000 ] creating skeleton! INFO [ 0000 ] wrote config to /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config INFO [ 0000 ] wrote config to /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/config INFO [ 0000 ] Wrote new 45625 bytes index to /tmp/crowdsec-v0.0.18/tests/config/crowdsec-cli/.index.json INFO [ 0000 ] crowdsecurity/syslog-logs : OK INFO [ 0000 ] crowdsecurity/geoip-enrich : OK INFO [ 0000 ] crowdsecurity/dateparse-enrich : OK INFO [ 0001 ] crowdsecurity/linux : OK INFO [ 0001 ] /tmp/crowdsec-v0.0.18/tests/config/collections doesn \\' t exist, create INFO [ 0001 ] /tmp/crowdsec-v0.0.18/tests/config/parsers/s00-raw doesn \\' t exist, create INFO [ 0001 ] Enabled parsers : crowdsecurity/syslog-logs INFO [ 0001 ] /tmp/crowdsec-v0.0.18/tests/config/parsers/s02-enrich doesn \\' t exist, create INFO [ 0001 ] Enabled parsers : crowdsecurity/geoip-enrich INFO [ 0001 ] Enabled parsers : crowdsecurity/dateparse-enrich INFO [ 0001 ] Enabled collections : crowdsecurity/linux INFO [ 0001 ] Enabled crowdsecurity/linux [ 09 /05/2020:20:02:20 ][ INFO ] Environment is ready in /tmp/crowdsec-v0.0.18/tests","title":"Create the test environment"},{"location":"write_configurations/requirements/#reminder","text":"Logs parsing is divided into stage, and each stage can contain one or more parser. Stages are named using a \"sXX- \" convention, and are processed in the alphabetical order. When a log is successfully parsed by a node that is configured to go in next_stage , the event is forwarded to the next stage (and the remaining parsers of the current stage aren't parsed). Stages and parsers are being processed alphabetically, thus the expected order would be : s00-raw/syslog.yaml s01-parse/apache.yaml s01-parse/nginx.yaml s02-enrich/geoip.yaml s02-enrich/rdns.yaml","title":"&#9432; Reminder"},{"location":"write_configurations/requirements/#default-stages","text":"The preliminary stage ( s00-raw ) is mostly the one that will parse the structure of the log. This is where syslog-logs are parsed for example. Such a parser will parse the syslog header to detect the program source. The main stage ( s01-parse ) is the one that will parse actual applications logs and output parsed data and static assigned values. There is one parser for each type of software. To parse the logs, regexp or GROK pattern are used. If the parser is configured to go to the next_stage , then it will be process by the enrichment stage. The enrichment ( s02-enrich ) stage is the one that will enrich the normalized log (we call it an event now that it is normalized) in order to get more information for the heuristic process. This stage can be composed of grok patterns and so on, but as well of plugins that can be writen by the community (geiop enrichment, rdns ...) for example geoip-enrich . You can now jump to the next step : writing our own parser !","title":"Default stages"},{"location":"write_configurations/requirements/#custom-stage","text":"It is possible to write custom stage. If you want some specific parsing or enrichment to be done after the s02-enrich stage, it is possible by creating a new folder s03-<custom_stage> (and so on). The configuration that will be created in this folder will process the logs configured to go to next_stage in the s02-enrich stage.","title":"Custom stage"},{"location":"write_configurations/scenarios/","text":"Writing {{v0X.crowdsec.Name}} scenarios \u00b6 Info Please ensure that you have working env or setup test environment before writing your scenario. Ensure that your logs are properly parsed . Have some sample logs at hand reach to test your scenario as you progress. In the current example, we'll write a scenario to detect port scans relying on the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new scenarios. If you're writing scenario for existing logs, take a look at the taxonomy to find your way ! Base scenario file \u00b6 A rudimentary scenario can be defined as : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : evt.Meta.log_type == 'iptables_drop' capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test a {{v0X.filter.htmlname}} : if the expression is true , the event will enter the scenario, otherwise, it won't a name & a description a capacity for our Leaky Bucket a leak speed for our Leaky Bucket a blackhole duration (it will prevent the same bucket from overflowing too often to limit spam) some labels to qualify the events that just happen a debug flag that allows to enable local debugging information. We are going to use the following sample log in our example : May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 66 .66.66.66 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929245 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 Let's try our mock scenario \u00b6 Info This assumes that you've followed the previous tutorial and that your iptables logs are properly parsed ./crowdsec -c ./dev.yaml -file ./x.log -type syslog Expected output DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow ( start: 2020 -05-12 09 :40:15 +0000 UTC, end: 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Adding overflow to blackhole ( 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] Bucket ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 found dead, cleanup the body bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 WARN [ 04 -08-2020 10 :44:26 ] read 4 lines file = ./x.log ... INFO [ 04 -08-2020 10 :44:26 ] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' ( 2 events over 0s ) at 2020 -05-12 09 :40:15 +0000 UTC bucket_id = sparkling-thunder event_time = \"2020-05-12 09:40:15 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 66 .66.66.66 ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow discarded, still blackholed for 59s bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Overflow has been discard ( *leakybucket.Blackhole ) bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 ... We can see our \"mock\" scenario is working, let's see what happened : The first event (parsed line) is processed : The filter returned true ( evt.Meta.log_type == 'iptables_drop' ) so the {{v0X.event.htmlname}} will be processed by our bucket The bucket is instantiated in {{v0X.timeMachine.htmlname}} mode, and its creation date is set to the timestamp from the first log The {{v0X.event.htmlname}} is poured in the actual bucket The second event is processed The filter is still true, and the event is poured As our bucket's capacity is 1 , pouring this second overflow leads to an {{v0X.overflow.htmlname}} Because we set a blackhole directive of 1 minute , we remember to prevent this bucket to overflowing again for the next minute The overflow itself is produced and we get this message : INFO[12-05-2020 11:22:17] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' (2 events over 0s) at 2020-05-12 09:40:15 +0000 UTC bucket_id=withered-brook event_time=\"2020-05-12 09:40:15 +0000 UTC\" scenario=me/my-cool-scenario source_ip=66.66.66.66 Warning While it \"worked\" we can see the first issue : the offending IP is reported to be 66.66.66.66 but there are actually 3 IPs involved ( 66.66.66.66 , 99.99.99.99 and 44.44.44.44 ). To make sense our \"detect port scans\" should detect events coming from a single IP ! One step forward : peer attribution \u00b6 Let's evolve our scenario to be closer to something meaningful : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test What did we change ? we added a meaningful filter : we are only going to look into iptables_drop events, and only take care of tcp ones (see the parser we wrote in the previous step ) we added a groupby directive : it's going to ensure that each offending peer get its own bucket Let's try again ! ./crowdsec -c ./dev.yaml -file ./x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = cold-lake capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Instanciating TimeMachine bucket cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = muddy-haze capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 6236f134d0f34d0061748c065bdcb64d8ac6dc54 ... INFO [ 12 -05-2020 11 :25:20 ] node warning : no remediation bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 INFO [ 12 -05-2020 11 :25:20 ] Processing Overflow with no decisions 99 .99.99.99 performed 'me/my-cool-scenario' ( 2 events over 1s ) at 2020 -05-12 09 :40:16 +0000 UTC bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 ... Let's see what happened : Thanks to our groupby key, we now see two different partition keys appearing ( partition=... ). It means that each peer will get its own bucket, and a \"unique key\" is derived from the groupby field value (here : the source IP) We see that we only have one overflow, and it correctly concerns 99.99.99.99 (it's the one that actually triggered two events). This is again thanks to the groupby key One step forward : unique ports \u00b6 Is it done ? not yet, but we're getting close ! To really qualify a port-scan, we want to rely on the number of unique probed ports. Let's arbitrarily decide that a port-scan is : \"One peer trying to probe AT LEAST 15 different ports within a few seconds\" Our evolved scenario is now : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp What did we changed : We add a distinct directive on the evt.Parsed.dst_port . It allows the bucket to discard any event with an already seen evt.Parsed.dst_port . (yes, like in SQL) We changed capacity and leakspeed to be more relevant to our target We fixed the labels so that the event makes sense ! Let's see what it changes : ./crowdsec -c ./dev.yaml -file ./x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:49:01+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Instantiating TimeMachine bucket cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Leaky routine starting, lifetime : 1m20s bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq 'evt.Parsed.dst_port' -> '7681' bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq ( 7681 ) : false, discard bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Pouring event bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... We can see that the second event was discarded, because it had a destination port similar to the first one No overflow were produced Is it really working \u00b6 Ok, fingers crossed our thing should be working. Let's grab some real-life logs ! $ wc -l kern.log 78215 kern.log $ head -n1 kern.log May 11 06 :25:20 sd-126005 kernel: ... $ tail -n1 kern.log May 12 12 :09:00 sd-126005 kernel: ... We have around 80k lines averaging about 24h of logs, let's try ! ./crowdsec -c ./dev.yaml -file ./kern.log -type syslog Expected output INFO [ 0000 ] setting loglevel to info INFO [ 12 -05-2020 11 :50:38 ] Crowdsec v0.0.18-f672dbb4aec29ca2b24080a33d4d92eb9d4441cc ... INFO [ 12 -05-2020 11 :50:42 ] node warning : no remediation bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx INFO [ 12 -05-2020 11 :50:42 ] Processing Overflow with no decisions xx.xx.xx.xx performed 'me/my-cool-scenario' ( 16 events over 0s ) at 2020 -05-11 10 :41:45 +0000 UTC bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx ... INFO [ 12 -05-2020 11 :50:43 ] node warning : no remediation bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy INFO [ 12 -05-2020 11 :50:43 ] Processing Overflow with no decisions yy.yy.yy.yy performed 'me/my-cool-scenario' ( 16 events over 2s ) at 2020 -05-11 11 :34:11 +0000 UTC bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy ... WARN [ 12 -05-2020 11 :51:05 ] read 78215 lines file = ./kern.log ... It seems to work correctly ! Hold my beer and watch this \u00b6 Once I have acquire confidence in my scenario and I want it to trigger some bans, we can simply add : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp remediation : true scope : ip Adding remediation: true into the labels tells {{v0X.crowdsec.name}} that we should write a ban for the IP when the scenario is triggered ! Let's try : I copied the yaml file to a production system ( /etc/crowdsec/crowdsec/scenarios/mytest.yaml ) I restart {{v0X.crowdsec.name}} ( systemctl reload crowdsec ) Let's check if it seems correctly enabled : $ {{ v0X.cli.bin }} list ... INFO [ 0000 ] SCENARIOS: ---------------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ---------------------------------------------------------------------------------------------------------------------------------- ... mytest.yaml \ud83d\udeab enabled,local /etc/crowdsec/config/scenarios/mytest.yaml ... Let's launch (from an external machine, as {{v0X.crowdsec.name}} ignores events from private IPs by default) a real port-scan with a good old nmap : sudo nmap -sS xx.xx.xx.xx and on our server : $ tail -f /var/log/crowdsec.log ... time = \"12-05-2020 12:31:43\" level = warning msg = \"xx.xx.16.6 triggered a 4h0m0s ip ban remediation for [me/my-cool-scenario]\" bucket_id = wispy-breeze event_time = \"2020-05-12 12:31:43.953498645 +0200 CEST m=+64.533521568\" scenario = me/my-cool-scenario source_ip = xx.xx.16.6 ... ^C $ {{ v0X.cli.bin }} ban list INFO [ 0000 ] backend plugin 'database' loaded 8 local decisions: +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | local | xx.xx.xx.xx | me/my-cool-scenario | 4 | ban | FR | 21502 SFR SA | 79 | 3h58m27s | ... It worked !!!","title":"Scenarios"},{"location":"write_configurations/scenarios/#writing-v0xcrowdsecname-scenarios","text":"Info Please ensure that you have working env or setup test environment before writing your scenario. Ensure that your logs are properly parsed . Have some sample logs at hand reach to test your scenario as you progress. In the current example, we'll write a scenario to detect port scans relying on the logs produced by iptables (netfilter) with the -j LOG target. This document aims at detailing the process of writing and testing new scenarios. If you're writing scenario for existing logs, take a look at the taxonomy to find your way !","title":"Writing {{v0X.crowdsec.Name}} scenarios"},{"location":"write_configurations/scenarios/#base-scenario-file","text":"A rudimentary scenario can be defined as : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : evt.Meta.log_type == 'iptables_drop' capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test a {{v0X.filter.htmlname}} : if the expression is true , the event will enter the scenario, otherwise, it won't a name & a description a capacity for our Leaky Bucket a leak speed for our Leaky Bucket a blackhole duration (it will prevent the same bucket from overflowing too often to limit spam) some labels to qualify the events that just happen a debug flag that allows to enable local debugging information. We are going to use the following sample log in our example : May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 66 .66.66.66 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:15 sd-126005 kernel: [ 47678084 .929245 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 99 .99.99.99 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0 May 12 09 :40:16 sd-126005 kernel: [ 47678084 .929208 ] IN = enp1s0 OUT = MAC = 00 :08:a2:0c:1f:12:00:c8:8b:e2:d6:87:08:00 SRC = 44 .44.44.44 DST = 127 .0.0.1 LEN = 40 TOS = 0x08 PREC = 0x20 TTL = 244 ID = 54321 PROTO = TCP SPT = 42403 DPT = 7681 WINDOW = 65535 RES = 0x00 SYN URGP = 0","title":"Base scenario file"},{"location":"write_configurations/scenarios/#lets-try-our-mock-scenario","text":"Info This assumes that you've followed the previous tutorial and that your iptables logs are properly parsed ./crowdsec -c ./dev.yaml -file ./x.log -type syslog Expected output DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow ( start: 2020 -05-12 09 :40:15 +0000 UTC, end: 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Adding overflow to blackhole ( 2020 -05-12 09 :40:15 +0000 UTC ) bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] eval ( evt.Meta.log_type == 'iptables_drop' ) = TRUE cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] eval variables: cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] evt.Meta.log_type = 'iptables_drop' cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario DEBU [ 04 -08-2020 10 :44:26 ] Bucket ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 found dead, cleanup the body bucket_id = sparkling-thunder capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 WARN [ 04 -08-2020 10 :44:26 ] read 4 lines file = ./x.log ... INFO [ 04 -08-2020 10 :44:26 ] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' ( 2 events over 0s ) at 2020 -05-12 09 :40:15 +0000 UTC bucket_id = sparkling-thunder event_time = \"2020-05-12 09:40:15 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 66 .66.66.66 ... DEBU [ 04 -08-2020 10 :44:26 ] Overflow discarded, still blackholed for 59s bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 DEBU [ 04 -08-2020 10 :44:26 ] Overflow has been discard ( *leakybucket.Blackhole ) bucket_id = long-pine capacity = 1 cfg = shy-dust file = config/scenarios/iptables-scan.yaml name = me/my-cool-scenario partition = ea2fed6bf8bb70d462ef8acacc4c96f5f8754413 ... We can see our \"mock\" scenario is working, let's see what happened : The first event (parsed line) is processed : The filter returned true ( evt.Meta.log_type == 'iptables_drop' ) so the {{v0X.event.htmlname}} will be processed by our bucket The bucket is instantiated in {{v0X.timeMachine.htmlname}} mode, and its creation date is set to the timestamp from the first log The {{v0X.event.htmlname}} is poured in the actual bucket The second event is processed The filter is still true, and the event is poured As our bucket's capacity is 1 , pouring this second overflow leads to an {{v0X.overflow.htmlname}} Because we set a blackhole directive of 1 minute , we remember to prevent this bucket to overflowing again for the next minute The overflow itself is produced and we get this message : INFO[12-05-2020 11:22:17] Processing Overflow with no decisions 2 IPs performed 'me/my-cool-scenario' (2 events over 0s) at 2020-05-12 09:40:15 +0000 UTC bucket_id=withered-brook event_time=\"2020-05-12 09:40:15 +0000 UTC\" scenario=me/my-cool-scenario source_ip=66.66.66.66 Warning While it \"worked\" we can see the first issue : the offending IP is reported to be 66.66.66.66 but there are actually 3 IPs involved ( 66.66.66.66 , 99.99.99.99 and 44.44.44.44 ). To make sense our \"detect port scans\" should detect events coming from a single IP !","title":"Let's try our mock scenario"},{"location":"write_configurations/scenarios/#one-step-forward-peer-attribution","text":"Let's evolve our scenario to be closer to something meaningful : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip capacity : 1 leakspeed : 1m blackhole : 1m labels : type : my_test What did we change ? we added a meaningful filter : we are only going to look into iptables_drop events, and only take care of tcp ones (see the parser we wrote in the previous step ) we added a groupby directive : it's going to ensure that each offending peer get its own bucket Let's try again ! ./crowdsec -c ./dev.yaml -file ./x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = cold-lake capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... DEBU [ 2020 -05-12T11:25:20+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Instanciating TimeMachine bucket cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:25:20+02:00 ] Leaky routine starting, lifetime : 2m0s bucket_id = muddy-haze capacity = 1 cfg = holy-breeze file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 6236f134d0f34d0061748c065bdcb64d8ac6dc54 ... INFO [ 12 -05-2020 11 :25:20 ] node warning : no remediation bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 INFO [ 12 -05-2020 11 :25:20 ] Processing Overflow with no decisions 99 .99.99.99 performed 'me/my-cool-scenario' ( 2 events over 1s ) at 2020 -05-12 09 :40:16 +0000 UTC bucket_id = muddy-haze event_time = \"2020-05-12 09:40:16 +0000 UTC\" scenario = me/my-cool-scenario source_ip = 99 .99.99.99 ... Let's see what happened : Thanks to our groupby key, we now see two different partition keys appearing ( partition=... ). It means that each peer will get its own bucket, and a \"unique key\" is derived from the groupby field value (here : the source IP) We see that we only have one overflow, and it correctly concerns 99.99.99.99 (it's the one that actually triggered two events). This is again thanks to the groupby key","title":"One step forward : peer attribution"},{"location":"write_configurations/scenarios/#one-step-forward-unique-ports","text":"Is it done ? not yet, but we're getting close ! To really qualify a port-scan, we want to rely on the number of unique probed ports. Let's arbitrarily decide that a port-scan is : \"One peer trying to probe AT LEAST 15 different ports within a few seconds\" Our evolved scenario is now : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp What did we changed : We add a distinct directive on the evt.Parsed.dst_port . It allows the bucket to discard any event with an already seen evt.Parsed.dst_port . (yes, like in SQL) We changed capacity and leakspeed to be more relevant to our target We fixed the labels so that the event makes sense ! Let's see what it changes : ./crowdsec -c ./dev.yaml -file ./x.log -type syslog Expected output ... DEBU [ 2020 -05-12T11:49:01+02:00 ] eval ( TRUE ) evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp' cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Instantiating TimeMachine bucket cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario DEBU [ 2020 -05-12T11:49:01+02:00 ] Leaky routine starting, lifetime : 1m20s bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq 'evt.Parsed.dst_port' -> '7681' bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Uniq ( 7681 ) : false, discard bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 DEBU [ 2020 -05-12T11:49:01+02:00 ] Pouring event bucket_id = nameless-feather capacity = 15 cfg = dark-pond file = config/scenarios/mytest.yaml name = me/my-cool-scenario partition = 2308799e2cc5b57331df10eb93a495aff7725922 ... We can see that the second event was discarded, because it had a destination port similar to the first one No overflow were produced","title":"One step forward : unique ports"},{"location":"write_configurations/scenarios/#is-it-really-working","text":"Ok, fingers crossed our thing should be working. Let's grab some real-life logs ! $ wc -l kern.log 78215 kern.log $ head -n1 kern.log May 11 06 :25:20 sd-126005 kernel: ... $ tail -n1 kern.log May 12 12 :09:00 sd-126005 kernel: ... We have around 80k lines averaging about 24h of logs, let's try ! ./crowdsec -c ./dev.yaml -file ./kern.log -type syslog Expected output INFO [ 0000 ] setting loglevel to info INFO [ 12 -05-2020 11 :50:38 ] Crowdsec v0.0.18-f672dbb4aec29ca2b24080a33d4d92eb9d4441cc ... INFO [ 12 -05-2020 11 :50:42 ] node warning : no remediation bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx INFO [ 12 -05-2020 11 :50:42 ] Processing Overflow with no decisions xx.xx.xx.xx performed 'me/my-cool-scenario' ( 16 events over 0s ) at 2020 -05-11 10 :41:45 +0000 UTC bucket_id = sparkling-violet event_time = \"2020-05-11 10:41:45 +0000 UTC\" scenario = me/my-cool-scenario source_ip = xx.xx.xx.xx ... INFO [ 12 -05-2020 11 :50:43 ] node warning : no remediation bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy INFO [ 12 -05-2020 11 :50:43 ] Processing Overflow with no decisions yy.yy.yy.yy performed 'me/my-cool-scenario' ( 16 events over 2s ) at 2020 -05-11 11 :34:11 +0000 UTC bucket_id = quiet-leaf event_time = \"2020-05-11 11:34:11 +0000 UTC\" scenario = me/my-cool-scenario source_ip = yy.yy.yy.yy ... WARN [ 12 -05-2020 11 :51:05 ] read 78215 lines file = ./kern.log ... It seems to work correctly !","title":"Is it really working"},{"location":"write_configurations/scenarios/#hold-my-beer-and-watch-this","text":"Once I have acquire confidence in my scenario and I want it to trigger some bans, we can simply add : type : leaky debug : true name : me/my-cool-scenario description : \"detect cool stuff\" filter : \"evt.Meta.log_type == 'iptables_drop' && evt.Meta.service == 'tcp'\" groupby : evt.Meta.source_ip distinct : evt.Parsed.dst_port capacity : 15 leakspeed : 5s blackhole : 1m labels : type : scan service : tcp remediation : true scope : ip Adding remediation: true into the labels tells {{v0X.crowdsec.name}} that we should write a ban for the IP when the scenario is triggered ! Let's try : I copied the yaml file to a production system ( /etc/crowdsec/crowdsec/scenarios/mytest.yaml ) I restart {{v0X.crowdsec.name}} ( systemctl reload crowdsec ) Let's check if it seems correctly enabled : $ {{ v0X.cli.bin }} list ... INFO [ 0000 ] SCENARIOS: ---------------------------------------------------------------------------------------------------------------------------------- NAME \ud83d\udce6 STATUS VERSION LOCAL PATH ---------------------------------------------------------------------------------------------------------------------------------- ... mytest.yaml \ud83d\udeab enabled,local /etc/crowdsec/config/scenarios/mytest.yaml ... Let's launch (from an external machine, as {{v0X.crowdsec.name}} ignores events from private IPs by default) a real port-scan with a good old nmap : sudo nmap -sS xx.xx.xx.xx and on our server : $ tail -f /var/log/crowdsec.log ... time = \"12-05-2020 12:31:43\" level = warning msg = \"xx.xx.16.6 triggered a 4h0m0s ip ban remediation for [me/my-cool-scenario]\" bucket_id = wispy-breeze event_time = \"2020-05-12 12:31:43.953498645 +0200 CEST m=+64.533521568\" scenario = me/my-cool-scenario source_ip = xx.xx.16.6 ... ^C $ {{ v0X.cli.bin }} ban list INFO [ 0000 ] backend plugin 'database' loaded 8 local decisions: +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+-----------------+----------------------+------+--------+---------+--------------------------+--------+------------+ | local | xx.xx.xx.xx | me/my-cool-scenario | 4 | ban | FR | 21502 SFR SA | 79 | 3h58m27s | ... It worked !!!","title":"Hold my beer and watch this"},{"location":"write_configurations/whitelist/","text":"What are whitelists \u00b6 Whitelists are special parsers that allow you to \"discard\" events, and can exist at two different steps : Parser whitelists : Allows you to discard an event at parse time, so that it never hits the buckets. PostOverflow whitelists : Those are whitelists that are checked after the overflow happens. It is usually best for whitelisting process that can be expensive (such as performing reverse DNS on an IP, or performing a whois of an IP). Info While the whitelists are the same for parser or postoverflows, beware that field names might change. Source ip is usually in evt.Meta.source_ip when it's a log, but evt.Overflow.Source_ip when it's an overflow The whitelist can be based on several criteria : specific ip address : if the event/overflow IP is the same, event is whitelisted ip ranges : if the event/overflow IP belongs to this range, event is whitelisted a list of {{v0X.expr.htmlname}} expressions : if any expression returns true, event is whitelisted Here is an example showcasing configuration : name : crowdsecurity/my-whitelists description : \"Whitelist events from my ipv4 addresses\" #it's a normal parser, so we can restrict its scope with filter filter : \"1 == 1\" whitelist : reason : \"my ipv4 ranges\" ip : - \"127.0.0.1\" cidr : - \"192.168.0.0/16\" - \"10.0.0.0/8\" - \"172.16.0.0/12\" expression : #beware, this one will work *only* if you enabled the reverse dns (crowdsecurity/rdns) enrichment postoverflow parser - evt.Enriched.reverse_dns endsWith \".mycoolorg.com.\" #this one will work *only* if you enabled the geoip (crowdsecurity/geoip-enrich) enrichment parser - evt.Enriched.IsoCode == 'FR' Whitelists in parsing \u00b6 When a whitelist is present in parsing /etc/crowdsec/config/parsers/... , it will be checked/discarded before being poured to any bucket. These whitelists intentionally generate no logs and are useful to discard noisy false positive sources. Whitelist by ip \u00b6 Let's assume we have a setup with a crowdsecurity/nginx collection enabled and no whitelists. Thus, if I \"attack\" myself : nikto -host myfqdn.com my own IP will be flagged as being an attacker : $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-bad-user-agent]\" bucket_id = cool-smoke event_time = \"2020-07-07 16:13:16.579581642 +0200 CEST m=+358819.413561109\" scenario = crowdsecurity/http-bad-user-agent source_ip = 80 .x.x.x time = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-probing]\" bucket_id = green-silence event_time = \"2020-07-07 16:13:16.737579458 +0200 CEST m=+358819.571558901\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 16:13:17\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-crawl-non_statics]\" bucket_id = purple-snowflake event_time = \"2020-07-07 16:13:17.353641625 +0200 CEST m=+358820.187621068\" scenario = crowdsecurity/http-crawl-non_statics source_ip = 80 .x.x.x time = \"07-07-2020 16:13:18\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-sensitive-files]\" bucket_id = small-hill event_time = \"2020-07-07 16:13:18.005919055 +0200 CEST m=+358820.839898498\" scenario = crowdsecurity/http-sensitive-files source_ip = 80 .x.x.x ^C $ {{ v0X.cli.bin }} ban list 4 local decisions: +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | local | 80 .x.x.x | crowdsecurity/http-bad-user-agent | 4 | ban | FR | 21502 SFR SA | 60 | 3h59m3s | ... Create the whitelist by IP \u00b6 Let's create a /etc/crowdsec/crowdsec/parsers/s02-enrich/mywhitelists.yaml file with the following content : name : crowdsecurity/whitelists description : \"Whitelist events from my ip addresses\" whitelist : reason : \"my ip ranges\" ip : - \"80.x.x.x\" and reload {{v0X.crowdsec.name}} : sudo systemctl reload crowdsec Test the whitelist \u00b6 Thus, if we restart our attack : nikto -host myfqdn.com And we don't get bans : $ tail -f /var/log/crowdsec.log ... ^C $ {{ v0X.cli.bin }} ban list No local decisions. And 21 records from API, 15 distinct AS, 12 distinct countries Here, we don't get any logs, as the event have been discarded at parsing time. Create whitelist by expression \u00b6 Now, let's make something more tricky : let's whitelist a specific user-agent (of course, it's just an example, don't do this at home !). The hub's taxonomy will helps us to find which data is present in which field. Let's change our whitelist to : name : crowdsecurity/whitelists description : \"Whitelist events from private ipv4 addresses\" whitelist : reason : \"private ipv4 ranges\" expression : - evt.Parsed.http_user_agent == 'MySecretUserAgent' again, let's restart {{v0X.crowdsec.name}} ! For the record, I edited nikto's configuration to use 'MySecretUserAgent' as user-agent, and thus : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ... time = \"07-05-2020 09:39:09\" level = info msg = \"Event is whitelisted by Expr !\" filter = name = solitary-leaf stage = s02-enrich ... Whitelist in PostOverflows \u00b6 Whitelists in PostOverflows are applied after the bucket overflow happens. It has the advantage of being triggered only once we are about to take decision about an IP or Range, and thus happens a lot less often. A good example is the crowdsecurity/whitelist-good-actors collection. But let's craft ours based on our previous example ! First of all, install the crowdsecurity/rdns postoverflow : it will be in charge of enriching overflows with reverse dns information of the offending IP. Let's put the following file in /etc/crowdsec/config/postoverflows/s01-whitelists/mywhitelists.yaml : name : me/my_cool_whitelist description : lets whitelist our own reverse dns whitelist : reason : dont ban my ISP expression : #this is the reverse of my ip, you can get it by performing a \"host\" command on your public IP for example - evt.Enriched.reverse_dns endsWith '.asnieres.rev.numericable.fr.' After reloading {{v0X.crowdsec.name}}, and launching (again!) nikto : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 17:11:09\" level = info msg = \"Ban for 80.x.x.x whitelisted, reason [dont ban my ISP]\" id = cold-sunset name = me/my_cool_whitelist stage = s01 time = \"07-07-2020 17:11:09\" level = info msg = \"node warning : no remediation\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 17:11:09\" level = info msg = \"Processing Overflow with no decisions 80.x.x.x performed 'crowdsecurity/http-probing' (11 events over 313.983994ms) at 2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x ... This time, we can see that logs are being produced when the event is discarded.","title":"Whitelists"},{"location":"write_configurations/whitelist/#what-are-whitelists","text":"Whitelists are special parsers that allow you to \"discard\" events, and can exist at two different steps : Parser whitelists : Allows you to discard an event at parse time, so that it never hits the buckets. PostOverflow whitelists : Those are whitelists that are checked after the overflow happens. It is usually best for whitelisting process that can be expensive (such as performing reverse DNS on an IP, or performing a whois of an IP). Info While the whitelists are the same for parser or postoverflows, beware that field names might change. Source ip is usually in evt.Meta.source_ip when it's a log, but evt.Overflow.Source_ip when it's an overflow The whitelist can be based on several criteria : specific ip address : if the event/overflow IP is the same, event is whitelisted ip ranges : if the event/overflow IP belongs to this range, event is whitelisted a list of {{v0X.expr.htmlname}} expressions : if any expression returns true, event is whitelisted Here is an example showcasing configuration : name : crowdsecurity/my-whitelists description : \"Whitelist events from my ipv4 addresses\" #it's a normal parser, so we can restrict its scope with filter filter : \"1 == 1\" whitelist : reason : \"my ipv4 ranges\" ip : - \"127.0.0.1\" cidr : - \"192.168.0.0/16\" - \"10.0.0.0/8\" - \"172.16.0.0/12\" expression : #beware, this one will work *only* if you enabled the reverse dns (crowdsecurity/rdns) enrichment postoverflow parser - evt.Enriched.reverse_dns endsWith \".mycoolorg.com.\" #this one will work *only* if you enabled the geoip (crowdsecurity/geoip-enrich) enrichment parser - evt.Enriched.IsoCode == 'FR'","title":"What are whitelists"},{"location":"write_configurations/whitelist/#whitelists-in-parsing","text":"When a whitelist is present in parsing /etc/crowdsec/config/parsers/... , it will be checked/discarded before being poured to any bucket. These whitelists intentionally generate no logs and are useful to discard noisy false positive sources.","title":"Whitelists in parsing"},{"location":"write_configurations/whitelist/#whitelist-by-ip","text":"Let's assume we have a setup with a crowdsecurity/nginx collection enabled and no whitelists. Thus, if I \"attack\" myself : nikto -host myfqdn.com my own IP will be flagged as being an attacker : $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-bad-user-agent]\" bucket_id = cool-smoke event_time = \"2020-07-07 16:13:16.579581642 +0200 CEST m=+358819.413561109\" scenario = crowdsecurity/http-bad-user-agent source_ip = 80 .x.x.x time = \"07-07-2020 16:13:16\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-probing]\" bucket_id = green-silence event_time = \"2020-07-07 16:13:16.737579458 +0200 CEST m=+358819.571558901\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 16:13:17\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-crawl-non_statics]\" bucket_id = purple-snowflake event_time = \"2020-07-07 16:13:17.353641625 +0200 CEST m=+358820.187621068\" scenario = crowdsecurity/http-crawl-non_statics source_ip = 80 .x.x.x time = \"07-07-2020 16:13:18\" level = warning msg = \"80.x.x.x triggered a 4h0m0s ip ban remediation for [crowdsecurity/http-sensitive-files]\" bucket_id = small-hill event_time = \"2020-07-07 16:13:18.005919055 +0200 CEST m=+358820.839898498\" scenario = crowdsecurity/http-sensitive-files source_ip = 80 .x.x.x ^C $ {{ v0X.cli.bin }} ban list 4 local decisions: +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | SOURCE | IP | REASON | BANS | ACTION | COUNTRY | AS | EVENTS | EXPIRATION | +--------+---------------+-----------------------------------+------+--------+---------+---------------------------+--------+------------+ | local | 80 .x.x.x | crowdsecurity/http-bad-user-agent | 4 | ban | FR | 21502 SFR SA | 60 | 3h59m3s | ...","title":"Whitelist by ip"},{"location":"write_configurations/whitelist/#create-the-whitelist-by-ip","text":"Let's create a /etc/crowdsec/crowdsec/parsers/s02-enrich/mywhitelists.yaml file with the following content : name : crowdsecurity/whitelists description : \"Whitelist events from my ip addresses\" whitelist : reason : \"my ip ranges\" ip : - \"80.x.x.x\" and reload {{v0X.crowdsec.name}} : sudo systemctl reload crowdsec","title":"Create the whitelist by IP"},{"location":"write_configurations/whitelist/#test-the-whitelist","text":"Thus, if we restart our attack : nikto -host myfqdn.com And we don't get bans : $ tail -f /var/log/crowdsec.log ... ^C $ {{ v0X.cli.bin }} ban list No local decisions. And 21 records from API, 15 distinct AS, 12 distinct countries Here, we don't get any logs, as the event have been discarded at parsing time.","title":"Test the whitelist"},{"location":"write_configurations/whitelist/#create-whitelist-by-expression","text":"Now, let's make something more tricky : let's whitelist a specific user-agent (of course, it's just an example, don't do this at home !). The hub's taxonomy will helps us to find which data is present in which field. Let's change our whitelist to : name : crowdsecurity/whitelists description : \"Whitelist events from private ipv4 addresses\" whitelist : reason : \"private ipv4 ranges\" expression : - evt.Parsed.http_user_agent == 'MySecretUserAgent' again, let's restart {{v0X.crowdsec.name}} ! For the record, I edited nikto's configuration to use 'MySecretUserAgent' as user-agent, and thus : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ... time = \"07-05-2020 09:39:09\" level = info msg = \"Event is whitelisted by Expr !\" filter = name = solitary-leaf stage = s02-enrich ...","title":"Create whitelist by expression"},{"location":"write_configurations/whitelist/#whitelist-in-postoverflows","text":"Whitelists in PostOverflows are applied after the bucket overflow happens. It has the advantage of being triggered only once we are about to take decision about an IP or Range, and thus happens a lot less often. A good example is the crowdsecurity/whitelist-good-actors collection. But let's craft ours based on our previous example ! First of all, install the crowdsecurity/rdns postoverflow : it will be in charge of enriching overflows with reverse dns information of the offending IP. Let's put the following file in /etc/crowdsec/config/postoverflows/s01-whitelists/mywhitelists.yaml : name : me/my_cool_whitelist description : lets whitelist our own reverse dns whitelist : reason : dont ban my ISP expression : #this is the reverse of my ip, you can get it by performing a \"host\" command on your public IP for example - evt.Enriched.reverse_dns endsWith '.asnieres.rev.numericable.fr.' After reloading {{v0X.crowdsec.name}}, and launching (again!) nikto : nikto -host myfqdn.com $ tail -f /var/log/crowdsec.log ime = \"07-07-2020 17:11:09\" level = info msg = \"Ban for 80.x.x.x whitelisted, reason [dont ban my ISP]\" id = cold-sunset name = me/my_cool_whitelist stage = s01 time = \"07-07-2020 17:11:09\" level = info msg = \"node warning : no remediation\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x time = \"07-07-2020 17:11:09\" level = info msg = \"Processing Overflow with no decisions 80.x.x.x performed 'crowdsecurity/http-probing' (11 events over 313.983994ms) at 2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" bucket_id = blue-cloud event_time = \"2020-07-07 17:11:09.175068053 +0200 CEST m=+2308.040825320\" scenario = crowdsecurity/http-probing source_ip = 80 .x.x.x ... This time, we can see that logs are being produced when the event is discarded.","title":"Whitelist in PostOverflows"}]}